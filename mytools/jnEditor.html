<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juno Interactive Editor(v2.05)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        :root { 
            --primary-color: #3b82f6; /* 부드러운 파란색 */
            --border-color: #e5e7eb;  /* 연한 회색 */
            --background-light: #f9fafb; /* 더 따뜻한 느낌의 배경색 */
            --correct-color: #16a34a;  /* 톤 다운된 녹색 */
            --incorrect-color: #ef4444; /* 톤 다운된 빨간색 */
            --hover-color: #f59e0b;   /* 부드러운 주황색 */
        }
        .preview-top-bar {
            flex-direction: column; /* 다시 세로 정렬로 변경 */
            align-items: flex-start; /* 왼쪽 정렬로 변경 */
            gap: 8px;
            padding: 45px 25px 8px 25px; /* 버튼이 들어갈 위쪽 공간(padding) 확보 */
        }
        
        .view-mode-controls button {
            background-color: transparent;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 1.1em;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s ease-in-out;
        }
        .view-mode-controls button:hover {
            opacity: 1;
            background-color: #fff;
        }
        .view-mode-controls button.active {
            opacity: 1;
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .view-mode-controls {
            position: absolute;
            top: 20px;
            right: 45px;
            z-index: 20;
            display: flex;
            gap: 5px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 3px;
            background-color: #f0f3f5;
        }
        
        /* --- 화면 모드 레이아웃 --- */
        .editor-column, .preview-column {
            transition: all 0.3s ease-in-out;
        }
        .container.view-mode-editor .preview-column {
            display: none;
        }
        .container.view-mode-preview .editor-column {
            display: none;
        }
        /* --- 전체 화면 모드 시각적 구분 --- */
        .container.view-mode-editor #editor-tab-bar {
            border-top: 3px solid var(--primary-color);
            border-bottom: 1px solid var(--border-color);
        }
        /* --- 전체 화면 모드 최대 너비 제한 --- */
        .container.view-mode-editor .editor-column,
        .container.view-mode-preview .preview-column {
            max-width: 1100px;
            margin: 0 auto; /* 좌우 여백을 자동으로 계산하여 중앙 정렬 */
        }
        .container.view-mode-preview #preview-tab-bar {
            border-top: 3px solid var(--hover-color);
        }
        
        body { 
            font-family: 'Noto Sans KR', 'Malgun Gothic', sans-serif; /* Noto Sans KR 우선 적용 */
            background-color: #f4f7f9; 
            margin: 0; 
            padding: 20px; 
            line-height: 1.7; /* ✅ 줄 간격을 넉넉하게 하여 가독성 향상 */
        }
        body.resizing { cursor: ns-resize; user-select: none; }
        
        .container { display: flex; gap: 20px; position: relative; }
        .left-panel { width: 220px; display: flex; flex-direction: column; gap: 20px; position: sticky; top: 20px; align-self: flex-start; height: calc(100vh - 40px); overflow-y: auto; padding-bottom: 20px; box-sizing: border-box; padding-right: 2px; }
        .editor-column { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .preview-column { flex: 1; display: flex; flex-direction: column; background-color: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }

        #editor-title-input { font-size: 2em; font-weight: bold; padding: 10px 5px; border: none; border-bottom: 2px solid var(--border-color); outline: none; background: transparent; font-family: inherit; }
        #editor-title-input:focus { border-color: var(--primary-color); }
        
        .preview-top-bar {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 15px 25px 8px 25px;
            background-color: var(--background-light);
            border-radius: 8px 8px 0 0;
        }
        #preview-tab-bar {
            width: 100%;
            text-align: right;
            position: sticky; /* ✅ sticky 위치 지정 */
            top: 0;           /* ✅ 화면 맨 위에 고정 */
            z-index: 10;      /* ✅ 다른 요소 위에 표시 */
            background-color: var(--background-light); /* ✅ 배경색 추가 */
            padding-bottom: 8px; /* ✅ 아래쪽 여백 추가 */
            padding-right: 25px; /* ✅ 오른쪽 여백 추가됨 */
            box-sizing: border-box; /* ✅ 구조 안정성을 위해 추가됨 */
            border-bottom: 1px solid var(--border-color); /* ✅ 하단 경계선 추가 */
        }
        #preview-main-title {
            font-size: 1.8em;
            font-weight: 600;
            margin: 0;
	    font-family:Noto Sans KR;
        }
        
        .tab-bar { background: white; padding: 10px; border-radius: 8px 8px 0 0; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-bottom: 2px solid var(--primary-color);}
        
        .tab-bar.preview-tabs { 
            padding: 0;
            margin: 0;
            box-shadow: none; 
            border-bottom: none;
            background-color: transparent;
        }

        .tab-btn { padding: 8px 15px; border: 1px solid var(--border-color); background: #fff; border-radius: 5px; cursor: pointer; margin-right: 5px; font-size: 0.9em; }
        .preview-tabs .tab-btn {
            border: none;
            background: transparent;
            border-radius: 0;
            padding: 0 12px;
            margin: 0;
            font-size: 0.95em;
            color: #555;
            border-bottom: 2px solid transparent;
            transition: color 0.2s, border-color 0.2s;
            line-height: 2.5;
        }
        .preview-tabs .tab-btn:hover { color: var(--hover-color); }

        .tab-btn.active { background: var(--primary-color); color: white; border-color: var(--primary-color); font-weight: bold; }
        .preview-tabs .tab-btn.active {
            background: transparent;
            color: var(--hover-color);
            border-bottom: 2px solid var(--hover-color);
            font-weight: bold;
        }

        #add-tab-btn { background: var(--correct-color); color: white; border: none; }
        
        #editor { border-radius: 0 0 8px 8px; background-color: white; padding: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); min-height: 80vh; margin-top: -8px;}
        #preview { padding: 20px; }

        #toolbar, #block-adder, #file-manager { 
        background: white; 
        padding: 15px; 
        border-radius: 12px; /* ✅ 모서리를 더 둥글게 */
        /* ✅ 부드러운 그림자로 변경 */
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        #version-info { font-size: 0.8em; color: #888; text-align: center; margin-top: 10px; }
        #toolbar h4, #block-adder h4, #file-manager h4 { margin: 0 0 10px 0; font-size: 1em; }
        .toolbar-group { margin-bottom: 15px; }
        .toolbar-group button { border: 1px solid var(--border-color); background-color: #fff; cursor: pointer; padding: 5px; margin: 2px; border-radius: 4px; font-size: 1.1em; vertical-align: middle; min-width: 32px; }
        .toolbar-group button:hover { background-color: #e2e6ea; }
        .toolbar-group button svg, .toolbar-group button img { pointer-events: none; }
        .color-swatch { width: 24px; height: 24px; }
        #emoji-palette { display: flex; flex-wrap: wrap; gap: 5px; }
        #emoji-palette span { cursor: pointer; font-size: 1.1em; padding: 2px; }
        #block-adder { }

        .icon-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 8px; /* ✅ 간격을 조금 더 넓게 */
        }
        .icon-grid button {
            border: 1px solid var(--border-color);
            background-color: var(--background-light);
            cursor: pointer;
            padding: 8px 4px; /* ✅ 패딩 조정 */
            font-size: 1rem; /* ✅ 텍스트에 맞는 폰트 크기 */
            aspect-ratio: 1 / 1;
            border-radius: 8px; /* ✅ 모서리를 더 둥글게 */
            min-width: 0;
            /* ✅ 아이콘과 텍스트를 세로로 정렬하기 위한 스타일 추가 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }
        .icon-grid button:hover { background-color: #e2e6ea; }
        .icon-grid button img { width: 60%; height: auto; }

        #block-adder.disabled .icon-grid { opacity: 0.5; cursor: not-allowed; }

        #editor .block, #preview .block { line-height: 1.7; transition: box-shadow 0.2s; }
        #editor .block {
        position: relative;
        cursor: grab;
        border: 1px solid var(--border-color); /* ✅ 점선에서 실선으로 변경 */
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 8px; /* ✅ 모서리를 둥글게 */
        background-color: var(--background-light);
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* ✅ 전환 효과 추가 */
        }
        /* ✅ 마우스 호버 및 드래그 효과를 위한 스타일 추가 */
        #editor .block:hover {
        border-color: var(--primary-color);
        box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        #editor .block.dragging { opacity: 0.5; border-style: solid; }
        #editor .editable { cursor: text; background-color: #fff; border: 1px solid #ced4da; line-height: 1.8; padding: 5px 8px; }
        
        #editor .block[data-type="spacer"] { position: relative; min-height: 30px; padding: 5px 15px 10px; text-align: center; }
        .resize-handle { position: absolute; bottom: 0; left: 0; width: 100%; height: 10px; cursor: ns-resize; border-bottom: 3px solid rgba(0,0,0,0.2); }
        .resize-handle:hover { border-bottom-color: var(--primary-color); }
        
        .block-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 4px;
            z-index: 5;
        }
        .toggle-default-btn, .copy-block-btn, .delete-block-btn {
            background: transparent;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            opacity: 0.5;
            padding: 2px;
        }
        .toggle-default-btn:hover {
            opacity: 1;
            color: #ff7a00; /* 주황색 (hover-color) */
        }
        .copy-block-btn:hover {
            opacity: 1;
            color: var(--primary-color);
        }
        .delete-block-btn:hover {
            opacity: 1;
            color: var(--incorrect-color);
        }
        .drag-handle {
            cursor: grab;
            touch-action: none;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .block.copied {
            outline: 2px solid var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        }

        .block-title { display: inline-flex; align-items: center; font-weight: bold; font-size: 0.9em; color: #495057; background-color: #e9ecef; padding: 4px 12px; border-radius: 15px; margin-bottom: 15px; }
        .text-content { margin-top: -10px; }
        .block-title-text { display: inline-block; min-width: 30px; border-radius: 3px; padding: 0 5px; outline: none; }
        .block-title-text:focus { background-color: #fff; box-shadow: 0 0 0 1px var(--primary-color); }
        
        .block[data-type="text"] .block-title { background-color: #fff9c4; }
        .block[data-type="ox"] .block-title { background-color: #c8e6c9; }
        .block[data-type="mcq"] .block-title { background-color: #bbdefb; }
        .block[data-type="descriptive"] .block-title { background-color: #d1c4e9; }
        .block[data-type="fill-in"] .block-title { background-color: #ffccbc; }
        .block[data-type="table"] .block-title { background-color: #d7ccc8; }
        .block[data-type="math"] .block-title { background-color: #b2dfdb; }
        .block[data-type="line-quiz"] .block-title { background-color: #fce4ec; }
        .block[data-type="youtube"] .block-title { background-color: #ffcdd2; }
        .block[data-type="link"] .block-title { background-color: #E0F7FA; }
        .block[data-type="frame"] .block-title { background-color: #D1C4E9; }
	    .block[data-type="summary"] .block-title { background-color: #E1F5FE; }
        #editor .block[data-type="summary"] {
            border: 1px solid #e9ecef; /* 전체적인 테두리는 연한 회색 실선으로 변경 */
            border-bottom: 4px solid #adb5bd; /* 아래쪽에만 두껍고 진한 선을 추가해 입체감 부여 */
            background-color: #f8f9fa; /* 배경을 연한 회색으로 지정 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* 부드러운 그림자 효과 추가 */
        }

        #editor .block[data-type="summary"] p {
            color: #6c757d; /* 내부 안내 문구 색상을 조금 진한 회색으로 변경 */
        }

        .youtube-url-input { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .youtube-placeholder { display: flex; align-items: center; justify-content: center; flex-direction: column; padding: 20px; background-color: #f0f0f0; border: 1px dashed #ccc; border-radius: 8px; cursor: pointer; text-align: center; transition: background-color 0.2s; }
        .youtube-placeholder:hover { background-color: #e0e0e0; }
        .youtube-placeholder-icon { width: 50px; height: auto; margin-bottom: 10px; }
        .youtube-placeholder-text { font-weight: bold; color: #333; }
        .youtube-iframe-wrapper { position: relative; overflow: hidden; width: 100%; max-width: 640px; margin: 0 auto; padding-top: 56.25%; }
        .youtube-iframe-wrapper iframe { position: absolute; top: 0; left: 0; bottom: 0; right: 0; width: 100%; height: 100%; border: none; }
        .youtube-close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 28px;
            height: 28px;
            background: black;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            line-height: 24px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .link-editor-container, .frame-editor-container { display: flex; flex-direction: column; gap: 10px; }
        .link-editor-row, .frame-editor-row { display: flex; align-items: center; gap: 8px; }
        .link-editor-row > label:first-child, .frame-editor-row > label:first-child { font-weight: bold; flex-shrink: 0; width: 80px; }
        .link-editor-row input[type="text"], .link-editor-row input[type="url"],
        .frame-editor-row input[type="text"], .frame-editor-row input[type="url"] { flex-grow: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        .link-target-options { display: flex; flex-wrap: wrap; gap: 5px 15px; align-items: center; }
        .link-target-options label { white-space: nowrap; }
        .preview-link-wrapper { display: inline-flex; align-items: center; gap: 10px; text-decoration: none; padding: 5px; }
        .preview-link-label { font-weight: bold; color: #495057; background-color: #E0F7FA; padding: 6px 10px; border-radius: 15px; }
        .preview-link-title { padding: 6px 12px; background-color: #e3f2fd; border-radius: 4px; color: #0056b3; font-weight: bold; transition: background-color 0.2s; }
        .preview-link-wrapper:hover .preview-link-title { background-color: #d1e7fd; }

        .frame-preview-container { border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 10px; background-color: #fff; }
        .frame-preview-summary { display: flex; align-items: center; justify-content: space-between; padding: 8px; cursor: pointer; list-style: none; }
        .frame-preview-summary::-webkit-details-marker { display: none; }
        .frame-preview-title-pill { font-weight: bold; color: #495057; background-color: #D1C4E9; padding: 4px 12px; border-radius: 15px; }
        .frame-preview-toggle-icon { transition: transform 0.2s; padding: 0 10px; }
        .frame-preview-container[open] .frame-preview-toggle-icon { transform: rotate(180deg); }
        .frame-preview-content { padding: 15px; border-top: 1px solid var(--border-color); }
        .frame-preview-content iframe { width: 100%; max-width: 100%; min-height: 450px; border: none; }
        .frame-preview-content img { display: block; margin: 0 auto; border-radius: 4px; max-width: 100%; max-height: 600px; }
        .frame-source-link { display: block; text-align: right; font-size: 0.8em; margin-top: 10px; color: #6c757d; }
	/* --- 핵심 구절 요약 블록 스타일 시작 --- */
.summary-preview-container {
    margin-bottom: 15px;
    background-color: #f8f9fa; /* ✅ 컨테이너 전체에 연한 회색 배경 적용 */
    border: 1px solid #e9ecef;   /* ✅ 컨테이너 전체에 테두리 적용 */
    border-radius: 5px;
}
.summary-preview-summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 15px; /* ✅ 안쪽 여백을 주어 보기 좋게 만듦 */
    cursor: pointer;
    list-style: none;
}
.summary-preview-summary::-webkit-details-marker { display: none; }
.summary-preview-title-pill { 
    font-weight: bold; 
    color: #495057; 
    background-color: #E1F5FE; 
    padding: 4px 12px; 
    border-radius: 15px; 
}
.summary-preview-toggle-icon { 
    transition: transform 0.2s; 
    padding: 0 10px; 
}
.summary-preview-container[open] .summary-preview-toggle-icon { transform: rotate(180deg); }
.summary-preview-content { 
    padding: 15px; 
    color: #6c757d; /* 내부 글자색을 진한 회색으로 변경 */
}
.summary-preview-content ul { list-style-type: none; padding-left: 0; margin: 0; }
.summary-preview-content li { margin-bottom: 10px; }
.summary-preview-content strong { color: #495057; } /* 핵심구절 글자는 조금 더 진하게 */
/* --- 핵심 구절 요약 블록 스타일 끝 --- */

/* --- 순서도 블록 스타일 시작 --- */
.block[data-type="flowchart"] .block-title { background-color: #E0E0E0; }

.flowchart-editor-row {
    padding: 10px;
    margin-bottom: 5px;
    border: 1px dashed #ccc;
    border-radius: 4px;
    background: #fdfdfd;
    position: relative;
    transition: all 0.2s ease-in-out;
}
.flowchart-editor-row.focused {
    border-color: var(--primary-color);
    border-width: 1.5px;
    border-style: solid;
    box-shadow: 0 1px 4px rgba(59, 130, 246, 0.2);
}

.flowchart-row-controls {
    display: flex;
    align-items: center;
    gap: 5px;
    visibility: hidden;
    opacity: 0;
    height: 0;
    overflow: hidden;
    transition: opacity 0.2s ease-in-out;
}
.flowchart-editor-row.focused .flowchart-row-controls {
    visibility: visible;
    opacity: 1;
    height: auto;
    margin-bottom: 8px;
}

/* ✅ 버튼과 라벨 스타일의 우선순위를 높이기 위해 더 구체적으로 지정 */
.flowchart-row-controls button,
.flowchart-row-controls .flowchart-toggle-label {
    padding: 2px 8px;
    font-size: 0.8em;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
}
.flowchart-row-controls .flowchart-toggle-label {
    display: inline-flex;
    align-items: center;
    gap: 4px;
}

.delete-flowchart-row-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    background: transparent;
    border: none;
    cursor: pointer;
    opacity: 0.5;
}
.delete-flowchart-row-btn:hover { opacity: 1; color: var(--incorrect-color); }

.flowchart-nodes-container { display: flex; gap: 10px; align-items: stretch; }
.flowchart-node-editor { flex: 1; min-height: 50px; }
.flowchart-connector-editor {
    flex: 0 0 50px;
    text-align: center;
    border-left: 1px solid #eee;
    border-right: 1px solid #eee;
    display: flex;
    align-items: center;
    justify-content: center;
}

.flowchart-preview-container { margin-bottom: 15px; }
.flowchart-preview-row { display: flex; justify-content: center; align-items: stretch; gap: 15px; }
.flowchart-preview-node {
    flex: 1;
    padding: 12px;
    border: 1px solid #d1d5db;
    background-color: #f9fafb;
    border-radius: 6px;
}
.flowchart-preview-connector {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column; /* 세로 정렬을 허용하도록 이 줄을 추가합니다. */
    font-size: 1.2em;
    color: #6b7280;
    padding: 0 10px;
}
.flowchart-preview-arrow {
    text-align: center;
    font-size: 1.5em;
    color: #9ca3af;
    margin: 8px 0;
}
.flowchart-preview-row.layout-three .flowchart-preview-node {
    flex-basis: 30%;
    max-width: 32%;
}
.flowchart-editor-row .drag-handle { cursor: grab; padding-right: 8px; opacity: 0.5; }
.flowchart-editor-row .drag-handle:active { cursor: grabbing; }
.flowchart-editor-row.dragging { opacity: 0.5; background-color: #e2e6ea; pointer-events: none; }
/* --- 순서도 블록 스타일 끝 --- */



/* --- 마인드맵 미리보기 스타일 시작 --- */
/* 기본형(토글) 마인드맵 스타일 */
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list {
    list-style: none;
    margin: 0;
    padding-left: 30px;
    position: relative;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list.mindmap-list-root {
    padding-left: 0;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list.mindmap-list-root::before {
    display: none;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list::before {
    content: '';
    position: absolute;
    left: 15px;
    top: 0;
    width: 1px;
    height: 100%;
    background: #a0aec0;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-item {
    position: relative;
    padding: 4px 0;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-item::before {
    content: '';
    position: absolute;
    top: 16px;
    left: -15px;
    width: 15px;
    height: 1px;
    background: #a0aec0;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list.mindmap-list-root > .mindmap-item::before {
    display: none;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-item:last-child::after {
    content: '';
    position: absolute;
    top: 17px;
    left: -15px;
    width: 1px;
    height: 100%;
    background: #fff; /* 부모 컨테이너 배경색과 동일하게 */
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-node {
    font-weight: normal; 
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list.mindmap-list-root > .mindmap-item > .mindmap-node,
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) .mindmap-list.mindmap-list-root > .mindmap-item > details > summary > .mindmap-node {
    font-weight: bold;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) summary {
    list-style: none;
    cursor: pointer;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) summary::-webkit-details-marker {
    display: none;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) summary > .mindmap-node::before {
    content: '▼';
    font-size: 0.6em;
    margin-right: 6px;
    display: inline-block;
    color: #868e96;
    transition: transform 0.2s;
    vertical-align: middle;
}
#preview .block[data-type="mindmap"] .mindmap-preview:not(.layout-orgchart) details:not([open]) > summary > .mindmap-node::before {
    content: '▶';
    transform: none;
}

/* --- 조직도형 전용 스타일 시작 --- */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart {
    text-align: center;
    padding: 20px 0;
}
/* 조직도형 리스트 기본 스타일 제거 */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart ul,
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart li {
    list-style: none;
    margin: 0;
    padding: 0;
}
/* 조직도형 레이아웃 Flexbox 설정 */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-list {
    display: flex;
    justify-content: center;
    position: relative;
    padding-top: 40px;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart > .orgchart-list {
    padding-top: 0;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    padding-left: 10px;
    padding-right: 10px;
}

/* --- 조직도형 선 그리기 --- */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-node-container::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    width: 1px;
    height: 20px;
    background-color: #a0aec0;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item:not(:has(.orgchart-list)) .orgchart-node-container::after {
    display: none;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item::before {
    content: '';
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 1px;
    height: 20px;
    background-color: #a0aec0;
}
/* 3. 형제 노드를 잇는 가로선 */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item::after {
    content: '';
    position: absolute;
    top: -20px;
    left: 0;
    width: 100%;
    height: 1px;
    background-color: #a0aec0;
}

/* --- 조직도형 선 모양 다듬기 (예외 처리) --- */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart > .orgchart-list > .orgchart-item::before,
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart > .orgchart-list > .orgchart-item::after {
    display: none;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item:first-child::after {
    width: 50%;
    left: 50%;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item:last-child::after {
    width: 50%;
    left: 0;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-item:only-child::after {
    display: none;
}

/* --- 조직도형 노드 디자인 --- */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-node-container {
    position: relative;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-node {
    padding: 8px 15px; border-radius: 6px; display: inline-block; min-width: 80px;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart .orgchart-list .orgchart-list .orgchart-node {
    background-color: #f9fafb;
}
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart > .orgchart-list > .orgchart-item > .orgchart-node-container > .orgchart-node {
    background-color: var(--primary-color); color: white; border: 2px solid #1e40af; font-weight: bold; font-size: 1.05em; border-radius: 8px;
}
/* --- 조직도형 전용 스타일 끝 --- */

/* --- 마인드맵 에디터 스타일 시작 --- */
.block[data-type="mindmap"] .mindmap-editor-container {
    border: 1px solid #ccc;
    padding: 10px 15px;
    border-radius: 5px;
    background-color: #fdfdfd; /* 내부 배경색을 살짝 추가하여 구분감 부여 */
}
/* 기본 리스트 스타일만 초기화합니다. padding은 여기서 건드리지 않습니다. */
.block[data-type="mindmap"] .mindmap-editor-container ul,
.block[data-type="mindmap"] .mindmap-editor-container li {
    list-style: none;
    margin: 0;
}
.block[data-type="mindmap"] .mindmap-editor-item {
    position: relative;
}
.block[data-type="mindmap"] .mindmap-node-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px;
    border-radius: 4px;
    transition: background-color 0.2s;
}
.block[data-type="mindmap"] .mindmap-node-wrapper:hover {
    background-color: #f0f3f5;
}
.block[data-type="mindmap"] .mindmap-node {
    flex-grow: 1;
}
.block[data-type="mindmap"] .mindmap-node .editable {
    background-color: transparent;
    border: none;
    padding: 3px 5px;
    outline: none;
    width: 100%;
}
.block[data-type="mindmap"] .mindmap-node .editable:focus {
    background-color: white;
    box-shadow: 0 0 0 1px var(--primary-color);
}
.block[data-type="mindmap"] .mindmap-node-actions {
    visibility: hidden;
}
.block[data-type="mindmap"] .mindmap-node-wrapper:hover .mindmap-node-actions {
    visibility: visible;
}
.block[data-type="mindmap"] .mindmap-add-child,
.block[data-type="mindmap"] .mindmap-delete-node {
    border: 1px solid #ccc;
    background-color: white;
    border-radius: 50%;
    cursor: pointer;
    width: 22px;
    height: 22px;
    font-weight: bold;
    line-height: 20px;
    text-align: center;
}
.block[data-type="mindmap"] .mindmap-add-child:hover { color: var(--correct-color); }
.block[data-type="mindmap"] .mindmap-delete-node:hover { color: var(--incorrect-color); }
.block[data-type="mindmap"] .mindmap-add-sibling-node,
.block[data-type="mindmap"] .mindmap-indent-node,
.block[data-type="mindmap"] .mindmap-outdent-node {
    border: 1px solid #ccc;
    background-color: white;
    border-radius: 50%;
    cursor: pointer;
    width: 22px;
    height: 22px;
    font-weight: bold;
    line-height: 20px;
    text-align: center;
}
.block[data-type="mindmap"] .mindmap-add-sibling-node:hover,
.block[data-type="mindmap"] .mindmap-indent-node:hover,
.block[data-type="mindmap"] .mindmap-outdent-node:hover {
    color: var(--primary-color);
}

/* 하위 목록(ul)이 들여쓰기를 담당합니다. */
.block[data-type="mindmap"] .mindmap-children-list {
    position: relative;
    padding-left: 35px;
}
/* 세로 줄 라인 */
.block[data-type="mindmap"] .mindmap-children-list::before {
    content: '';
    position: absolute;
    left: 10px;
    top: 0;
    width: 1px;
    height: 100%;
    background-color: #d1d5db; /* 라인 색을 약간 진하게 */
}
/* 각 항목(li)으로 뻗어나가는 가로 줄 라인 */
.block[data-type="mindmap"] .mindmap-children-list > .mindmap-editor-item::before {
    content: '';
    position: absolute;
    top: 22px;
    left: 10px;
    width: 15px;
    height: 1px;
    background-color: #d1d5db;
}
/* 마지막 항목의 세로줄이 아래로 더 길어지지 않게 가려줍니다. */
.block[data-type="mindmap"] .mindmap-children-list > .mindmap-editor-item:last-child::after {
    content: '';
    position: absolute;
    left: 10px;
    top: 23px;
    width: 1px;
    height: calc(100% - 22px);
    background-color: #fdfdfd; /* 컨테이너 배경색과 동일하게 덮어쓰기 */
}
/* 최상위 루트 항목은 들여쓰기와 라인이 필요 없으므로 재설정합니다. */
.block[data-type="mindmap"] .mindmap-editor-container > .mindmap-children-list {
    padding-left: 0;
}
.block[data-type="mindmap"] .mindmap-editor-container > .mindmap-children-list::before {
    display: none;
}
/* --- 하위 노드 테두리 제거 --- */
#preview .block[data-type="mindmap"] .mindmap-preview.layout-orgchart details .orgchart-node {
    border: none;
    background-color: #f9fafb; /* 테두리가 없어져서 배경색을 살짝 추가해 구분감을 줌 */
}

/* --- 마인드맵 에디터 스타일 끝 --- */

/* --- 마인드맵 단축키 설명 스타일 --- */
.mindmap-shortcut-guide {
    font-size: 0.8em;
    color: #6c757d;
    margin: -10px 0 15px 5px;
}

.delete-line-quiz-item {
    background: transparent;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.4em;
    font-weight: bold;
    padding: 0 8px;
    margin-left: auto; /* 버튼을 오른쪽 끝으로 밀어냄 */
}
.delete-line-quiz-item:hover {
    color: var(--incorrect-color);
}

.delete-fill-in-item {
    position: absolute; /* <-- 아래 4줄을 수정해주세요 */
    top: 50%;
    right: 5px;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.4em;
    font-weight: bold;
    padding: 0 8px;
    margin-left: 5px;
}
.delete-fill-in-item:hover {
    color: var(--incorrect-color);
}

.flowchart-preview-row.first-col-narrow .flowchart-preview-node:first-child {
    flex-grow: 0;
    flex-shrink: 0;
    flex-basis: 17%; /* 첫 번째 칸의 너비를 25% 정도로 설정 */
    max-width: 180px; /* 너무 커지지 않도록 최대 너비도 설정 */
}
.flowchart-first-col-narrow-toggle {
    font-size: 0.9em;
    cursor: pointer;
    display: none; /* 기본적으로 숨김 */
}

/* --- 유튜브 블록 스타일 시작 --- */
.youtube-title-editor {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-bottom: 10px;
}
.youtube-title-editor strong {
    flex-shrink: 0;
}
.youtube-title-editor input {
    flex-grow: 1;
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 4px;
}
.youtube-preview-title {
    display: inline-flex;
    align-items: center;
    gap: 10px;
}
.youtube-preview-title .pill {
    background-color: #ffcdd2;
    padding: 4px 12px;
    border-radius: 15px;
    display: inline-flex;
    align-items: center;
    font-weight: bold;
}
/* --- 유튜브 블록 스타일 끝 --- */

/* --- 드래그 앤 드롭 퀴즈 스타일 시작 --- */
.block[data-type="drag-drop"] .block-title { background-color: #C5E1A5; } /* 제목 색상 추가 */

.drag-drop-item-editor {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-bottom: 8px;
    background-color: #fff;
    padding: 8px;
    border-radius: 4px;
}
.drag-drop-item-editor .editable {
    border: 1px solid #e0e0e0;
    padding: 5px;
    min-width: 50px;
    flex: 1;
}
#editor .drag-drop-item-editor .drag-drop-answer {
    background-color: #fffde7;
    border: 1px dashed #c9bc8f;
    font-weight: bold;
    text-align: center;
    flex: 0 1 120px; /* 너비를 유연하게 조절 */
}

.drag-drop-preview-container .sentence {
    margin-bottom: 10px; /* 간격을 20px에서 10px로 수정 */
    line-height: 2.2;
    padding: 10px;
    background: #fafafa;
    border-radius: 4px;
}
.drag-drop-preview-container .drop-target {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 100px;
    max-width: 250px;
    height: 28px;
    border: 1px dashed #adb5bd;
    background-color: #e9ecef;
    vertical-align: middle;
    margin: 0 5px;
    border-radius: 4px;
    font-weight: bold;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding: 0 8px;
    box-sizing: border-box;
}
.drag-drop-preview-container .drop-target.drag-over {
    background-color: #d1c4e9;
    border-style: solid;
}
.drag-drop-preview-container .drop-target.correct { background-color: #d4edda; border-color: var(--correct-color); }
.drag-drop-preview-container .drop-target.incorrect { background-color: #f8d7da; border-color: var(--incorrect-color); }

.drag-drop-preview-container .source-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 15px;
    border: 1px solid #e0e0e0;
    background-color: #f8f9fa;
    border-radius: 4px;
    min-height: 40px;
}
.drag-drop-preview-container .drag-source {
    padding: 6px 14px;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 15px;
    cursor: grab;
    user-select: none;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.drag-drop-preview-container .drag-source:active {
    cursor: grabbing;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
.drag-drop-preview-container .drag-source.dragging {
    opacity: 0.5;
    background-color: transparent;
    border: 2px dotted var(--hover-color);
    color: var(--hover-color);
}
.drag-drop-preview-container .drag-source.selected {
    background-color: transparent;
    border: 2px dotted var(--hover-color);
    color: var(--hover-color);
}
/* --- 드래그 앤 드롭 퀴즈 스타일 끝 --- */

.delete-drag-drop-item {
    background: transparent;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.4em;
    font-weight: bold;
    padding: 0 8px;
    margin-left: 5px;
}
.delete-drag-drop-item:hover {
    color: var(--incorrect-color);
}

/* --- 순서 배열 퀴즈 스타일 시작 --- */
.block[data-type="ordering"] .block-title { background-color: #FFDAB9; }

.block[data-type="classification"] .block-title { background-color: #FFECB3; } /* 분류하기 퀴즈 */

.ordering-preview-container {
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
}

.ordering-target-container, .ordering-source-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 15px;
    border: 1px dashed #adb5bd;
    border-radius: 4px;
    min-height: 50px;
    align-content: flex-start;
}

.ordering-source-container {
    background-color: #f8f9fa;
    border-style: solid;
}

.ordering-target-container.drag-over {
    background-color: #e0f2f1; /* 연민트 */
    border-color: var(--primary-color);
}

.ordering-target-container.correct {
    border-color: var(--correct-color);
    background-color: #e8f5e9;
}

.ordering-target-container.incorrect {
    border-color: var(--incorrect-color);
    background-color: #ffebee;
}

.ordering-item {
    padding: 6px 14px;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 15px;
    cursor: grab;
    user-select: none;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.ordering-item:active {
    cursor: grabbing;
}
.ordering-item.selected {
    background-color: transparent;
    border: 2px dotted var(--hover-color);
    color: var(--hover-color);
}
.ordering-item.selected {
    background-color: transparent;
    border: 2px dotted var(--hover-color);
    color: var(--hover-color);
}

.ordering-drop-indicator {
width: 4px;
height: 30px;
background-color: var(--hover-color);
border-radius: 2px;
align-self: center;
}
.ordering-item.dragging {
    opacity: 0.5;
    background-color: transparent;
    border: 2px dotted var(--hover-color);
    color: var(--hover-color);
}

/* --- 순서 배열 퀴즈 (에디터) --- */
.ordering-item-editor {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    margin-bottom: 5px;
    background-color: #fff;
    border: 1px dashed var(--border-color);
    border-radius: 4px;
}
.ordering-item-editor .editable {
    flex-grow: 1;
    border: 1px solid #ccc;
    padding: 5px;
    border-radius: 3px;
}
.delete-ordering-item {
    background: transparent;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.4em;
    font-weight: bold;
    padding: 0 5px;
    line-height: 1;
}
.delete-ordering-item:hover {
    color: var(--incorrect-color);
}
/* --- 순서 배열 퀴즈 (미리보기) --- */
.ordering-preview-item {
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #eee;
}
.ordering-preview-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
.ordering-item-title {
    font-weight: bold;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
}
.ordering-item-feedback {
    margin-left: 8px;
    font-size: 1.2em;
}
/* 선택지 컨테이너 테두리 제거 */
.ordering-source-container {
    border-style: none;
    background-color: transparent;
    padding: 15px 0 0 0;
    justify-content: flex-start;
}

/* --- 순서 배열 퀴즈 스타일 끝 --- */

/* --- 수식 블록 스타일 시작 --- */
.block-title-container {
    display: flex;
    align-items: center;
    gap: 12px; /* 제목과 링크 사이 간격 */
    margin-bottom: 10px; /* 수식 입력 상자와의 간격 */
}
.block-title-container .block-title {
    margin-bottom: 0; /* 기존 제목의 아래쪽 여백 제거 */
}
.math-guide-link {
    font-size: 0.85em;
    color: var(--primary-color);
    text-decoration: none;
    border-bottom: 1px dashed var(--primary-color);
    padding-bottom: 1px;
    transition: all 0.2s;
}
.math-guide-link:hover {
    color: #0056b3;
    border-bottom-style: solid;
}
/* --- 수식 블록 스타일 끝 --- */

#preview .block[data-type="text"]:not(.no-title-block) {
    background-color: transparent; /* 바깥 배경을 투명하게 */
    border-color: transparent;      /* 바깥 테두리도 투명하게 */
    padding: 0;                     /* 불필요한 안쪽 여백 제거 */
    box-shadow: none;
}

/* --- 일반 텍스트 토글 블록 스타일 시작 --- */
.text-preview-container {
    margin-bottom: 15px;
    background-color: #f8f9fa; /* ✅ 컨테이너 전체에 연한 회색 배경 적용 */
    border: 1px solid #e9ecef;   /* ✅ 컨테이너 전체에 테두리 적용 */
    border-radius: 5px;
}
.text-preview-summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 15px; /* ✅ 안쪽 여백을 주어 보기 좋게 만듦 */
    cursor: pointer;
    list-style: none;
}
.text-preview-summary::-webkit-details-marker { display: none; }
.text-preview-title-pill {
    font-weight: bold;
    color: #495057;
    background-color: #fff9c4;
    padding: 4px 12px;
    border-radius: 15px;
    display: inline-flex;
    align-items: center;
}
.text-preview-toggle-icon {
    transition: transform 0.2s;
    padding: 0 10px;
}
.text-preview-container:not([open]) .text-preview-toggle-icon {
    transform: rotate(-90deg);
}

.text-preview-content-wrapper {
    padding: 15px;
    background-color: transparent; /* ✅ 기존 배경과 테두리는 제거 */
    border: none;
}
.text-preview-content {
    background-color: #fff;
    border: 1px solid #ced4da;
    padding: 10px 12px;
    border-radius: 4px;
    line-height: 2.3
}
/* --- 일반 텍스트 토글 블록 스타일 끝 --- */

/* --- 에디터 내 구절풀이 텍스트 스타일 --- */

/* --- 인터랙티브 빈칸 퀴즈 스타일 시작 --- */
.interactive-cloze-container {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}
.cloze-blank {
    display: inline-block;
    min-width: 80px;
    padding: 0 8px;
    height: 26px; /* 높이를 지정하여 빈칸 모양 유지 */
    line-height: 26px; /* 텍스트 세로 중앙 정렬 */
    vertical-align: bottom; /* 다른 텍스트와 기준선 맞춤 */
    border-bottom: 2px solid #333;
    text-align: center;
    font-weight: bold;
    color: var(--primary-color);
    cursor: pointer;
}
.cloze-blank.filled.correct {
    background-color: #d4edda;
    border-color: var(--correct-color);
    color: var(--correct-color);
}
.cloze-blank.filled.incorrect {
    background-color: #f8d7da;
    border-color: var(--incorrect-color);
    color: var(--incorrect-color);
}
.cloze-choices {
    display: inline-flex;
    gap: 6px;    font-size: 0.9em;
    flex-wrap: wrap;
}
.cloze-choice {
    padding: 3px 10px;
    border: 1px solid #ccc;
    background-color: #f8f9fa;
    border-radius: 15px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.cloze-choice:hover {
    background-color: #e9ecef;
    border-color: #adb5bd;
}
.cloze-choice.used {
    opacity: 0.4;
    cursor: not-allowed;
    background-color: #e9ecef;
}
/* --- 인터랙티브 빈칸 퀴즈 스타일 끝 --- */

.explainable-in-editor {
    background-color: #e3f2fd;
    color: #0d47a1;
    border-bottom: 1px dashed #90caf9;
    cursor: pointer;
    border-radius: 3px;
    padding: 1px 4px;
}


        .inline-link-from-text {
            background-color: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px;
            padding: 2px 6px; text-decoration: none; color: #0d47a1; transition: all 0.2s ease;
        }
        .inline-link-from-text:hover { background-color: #bbdefb; border-color: #42a5f5; color: #000; }
        .inline-image-from-text {
            max-width: 100%; max-height: 300px; border: 1px solid var(--border-color); border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); vertical-align: middle; margin: 2px 4px;
        }

        #preview .block:not(.no-title-block) {
            background-color: #fff; /* 흰색 배경 추가 */
            border: 1px solid #e9ecef; /* 전체 테두리는 더 연하게 */
            border-left: 5px solid #bbdefb; /* 왼쪽에 부드러운 중간 회색 강조 테두리 */
            box-shadow: 0 3px 6px rgba(0,0,0,0.04); /* 그림자를 더 은은하게 */
            border-radius: 8px; /* 모서리를 더 둥글게 */
            padding: 20px; /* 내부 여백도 살짝 넓혀서 시원하게 */
            margin-bottom: 30px; /* 블록 간 하단 여백 증가 */
        }
        #preview .block:not(.no-title-block):hover {
                border-left-color: var(--primary-color);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08); /* 그림자를 조금 더 진하게 */
                transform: translateY(-2px); /* 살짝 위로 떠오르는 효과 */
            }
        #preview .block.no-title-block { border-color: transparent; padding: 0; margin-bottom: 0; background-color: transparent; box-shadow: none; }
        #preview .block-title { display: inline-flex; width: fit-content; }
        
        .text-border-black { border: 2px solid black; padding: 0 2px; border-radius: 3px; }
        .text-border-gray { border: 2px solid gray; padding: 0 2px; border-radius: 3px; } /* 이 줄 추가 */
        .text-border-red { border: 2px solid red; padding: 0 2px; border-radius: 3px; }
        .text-border-violet { border: 2px solid violet; padding: 0 2px; border-radius: 3px; } /* 이 줄 추가 */
        .text-border-blue { border: 2px solid blue; padding: 0 2px; border-radius: 3px; }
        .text-border-green { border: 2px solid green; padding: 0 2px; border-radius: 3px; }

        .text-highlight-gray { background-color: #eeeeee; border: 2px solid #bdbdbd; padding: 1px 3px; border-radius: 3px; }
        .text-highlight-violet { background-color: #f3e5f5; border: 2px solid #ce93d8; padding: 1px 3px; border-radius: 3px; }
        .text-highlight-red { background-color: #ffebee; border: 2px solid #e57373; padding: 1px 3px; border-radius: 3px; }
        .text-highlight-yellow { background-color: #fffde7; border: 2px solid #fff176; padding: 1px 3px; border-radius: 3px; }
        .text-highlight-blue { background-color: #e3f2fd; border: 2px solid #90caf9; padding: 1px 3px; border-radius: 3px; }
        .text-highlight-green { background-color: #e8f5e9; border: 2px solid #a5d6a7; padding: 1px 3px; border-radius: 3px; }

        #preview .explainable {
            color: #546E7A; /* 차분한 청회색 */
            border-bottom: 1px dotted #78909C; /* 은은한 점선 밑줄 */
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease-in-out; /* 부드러운 전환 효과 */
        }
        #preview .explainable:hover {
            color: var(--primary-color); /* 마우스 올리면 선명한 파란색으로 */
            border-bottom: 1px solid var(--primary-color); /* 밑줄도 선명하게 */
        }
        
        .ox-question-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 15px; }
        .ox-question-row .question-text { flex-grow: 1; padding-left: 1.8em; text-indent: -1.8em;}
        .ox-answer-selector-editor {
            display: inline-flex;
            gap: 8px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .ox-choice-btn-editor {
            display: inline-block;
            width: 32px;
            height: 32px;
            border: 1px solid #ccc;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #f8f9fa;
        }
        .ox-answer-selector-editor input[type="radio"]:checked + .ox-choice-btn-editor {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        #preview .ox-choices button {
            width: 40px;
            height: 40px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            background-color: transparent;
            font-size: 1.1em;
            font-weight: bold;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin: 0 4px;
        }
        #preview .ox-choices button:hover {
            border-color: var(--hover-color);
            color: var(--hover-color);
        }
        #preview .ox-choices button.selected {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
            transform: scale(1.05);
        }
        .ox-preview-item {margin-bottom: 15px;}
        .ox-choices { flex-shrink: 0; }
        
        .quiz-title-container-editor, .ox-item-editor, .mcq-option-editor { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .delete-ox-item {
            background: transparent;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2em; /* 크기 약간 축소 */
            font-weight: bold;
            line-height: 1;
            margin-left: 8px; /* X버튼과 간격 추가 */
        }
        .delete-ox-item:hover {
            color: var(--incorrect-color);
        }
        .quiz-title-container-editor .editable, .ox-item-editor .editable, .mcq-option-editor .editable { flex-grow: 1; }
        .ox-item-editor { border-top: 1px solid #eee; padding-top: 10px; }
        .ox-item-editor:first-child { border-top: none; padding-top: 0; }

        .mcq-passage-container-editor {
            margin-bottom: 15px;
        }
        .mcq-passage-preview {
            background-color: var(--background-light);
            border: 1px solid var(--border-color);
            padding: 12px 15px;
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 0.95em;
            line-height: 1.8;
        }
        .mcq-option-editor { margin-bottom: 5px; }
        .descriptive-editor-row {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    margin-bottom: 10px;
                }
                .descriptive-editor-row strong {
                    flex-shrink: 0;
                }
                .descriptive-editor-row .editable {
                    flex-grow: 1;
                }
        .quiz-title-preview { font-size: 1.2em; font-weight: bold; margin-bottom: 15px; }
        .retry-quiz-btn { font-size: 0.8em; margin-left: 10px; cursor: pointer; color: #6c757d; background: #f1f1f1; border: 1px solid #ddd; padding: 5px 10px; border-radius: 4px; }
        .mcq-options-preview { margin-left: 20px; }
        /* [수정] CSS만으로 들여쓰기를 구현하는 최종 코드 */
        #preview .mcq-preview-option {
            transition: background-color 0.2s;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            /* --- 아래 두 줄로 들여쓰기 효과를 냅니다 --- */
            padding-left: 1.3em;
            text-indent: -1.3em;
        }

        #preview .mcq-preview-option:hover {
             background-color: #e9ecef;
        }
        .mcq-preview-option:hover { background-color: #e9ecef; }
        
        .quiz-controls { display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-top: 10px; }
        .quiz-controls .feedback { margin: 0; padding: 4px 8px; text-align: left; flex-grow: 1; }
        
        .descriptive-student-answer { width: 100%; min-height: 60px; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; margin-top: 10px; box-sizing: border-box; }
        .show-answer-btn, .hide-answer-btn, .check-fill-in-btn, .check-line-quiz-btn, .check-answer-btn { padding: 5px 10px; border: 1px solid var(--primary-color); background-color: var(--primary-color); color: white; border-radius: 4px; cursor: pointer; }

        .fill-in-item-editor { padding: 10px; margin-bottom: 5px; border-radius: 4px; background: #fff; }
        .fill-in-question-container { display: flex; align-items: center; gap: 8px; position: relative;}
        .fill-in-question.placeholder-active { color: #888; }
        .fill-in-answers-container { margin-left: 2em; margin-top: 5px; font-size: 0.9em; color: #555; }
        .fill-in-answer-wrapper { display: flex; align-items: center; gap: 5px; margin-bottom: 2px;}
        .fill-in-answer-input { border: 1px solid #ccc; border-radius: 3px; padding: 2px 4px; background-color: #e3f2fd; }
        .fill-in-preview-item { margin-bottom: 15px; }
        #editor .fill-in-question {
            padding-right: 30px; /* 버튼이 들어갈 공간 확보 */
        }
        .blank-input-preview { 
            min-width: 50px; 
            border: none; 
            border-bottom: 1px solid #333; 
            text-align: center; 
            font-family: inherit; 
            font-size: 1em; 
            color: #16a34a !important; 
            font-weight: bold !important; 
        }
        .blank-input-preview.correct { background-color: #d4edda; border-color: var(--correct-color); }
        .blank-input-preview.incorrect { background-color: #f8d7da; border-color: var(--incorrect-color); }
        
        .table-editor-container > div:not(.table-records-container) { margin-bottom: 15px; }
        .table-title-editor, .table-desc-editor { display: flex; gap: 8px; align-items: center;}
        .table-title-editor .editable, .table-desc-editor .editable { flex-grow: 1; }
        .fields-container { display: flex; gap: 5px; }
        .table-field { flex: 1; font-weight: bold; text-align: center; }
        .table-record-row-wrapper { margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px solid #eee;}
        .table-record-row { display: flex; gap: 5px; }
        .table-record-cell { flex: 1; }
        .add-table-row-btn { width: 100%; padding: 8px; margin-top: 10px; }
        
        .table-preview-container table { width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed; }
        .table-preview-container th, .table-preview-container td { border: 1px solid var(--border-color); padding: 8px; text-align: left; word-break: break-all; vertical-align: top;}
        .table-preview-container th:first-child, .table-preview-container td:first-child { width: 120px; }
        .table-preview-container thead { background-color: var(--background-light); }
        .table-preview-container h3 { margin-bottom: 5px; }
        .table-preview-container p { margin-top: 0; font-size: 0.9em; color: #666; }

        .math-editor-field { background-color: #fff; border: 1px solid var(--border-color); padding: 10px; border-radius: 4px; min-height: 40px; }
        .math-editor-field.mq-focused { border-color: var(--primary-color); box-shadow: 0 0 0 1px var(--primary-color); }
        .math-preview-field { padding: 10px; text-align: center; font-size: 1.2em; overflow-x: auto; }
        
        .line-quiz-item-editor { display: flex; align-items: stretch; gap: 10px; margin-bottom: 5px; }
        .line-quiz-item-editor .editable { flex: 1; }
        .line-quiz-item-editor > * { display: flex; align-items: center; }
        .line-quiz-preview { position: relative; display: flex; justify-content: space-between; }
        .line-quiz-column { display: flex; flex-direction: column; gap: 10px; width: 45%; }
        .line-quiz-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .line-quiz-item { display: flex; align-items: center; padding: 8px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; min-height: 36px; }
        .line-quiz-item .text { flex-grow: 1; }
        .line-quiz-item .dot { flex-shrink: 0; width: 16px; height: 16px; background-color: #ccc; border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.5); }
        .line-quiz-item .dot:hover { background-color: #aaa; }
        .line-quiz-item .dot.selected { background-color: var(--primary-color); }
        .line-quiz-item .dot.disabled { cursor: default; }

        .feedback { margin-top: 5px; padding: 4px 8px; border-radius: 4px; font-weight: bold; text-align: center; display: none; }
        .feedback.show { display: block; }
        .feedback-answer-box {
            display: inline-block;
            padding: 6px 12px;
            background-color: var(--correct-color);
            color: white;
            font-weight: bold;
            border-radius: 4px;
        }
        .feedback.correct { color: var(--correct-color); }
        .feedback.incorrect { color: var(--incorrect-color); }
        .feedback .correct-highlight { background-color: var(--correct-color); color: white; padding: 2px 6px; border-radius: 4px; }
        .feedback .incorrect-highlight { background-color: var(--incorrect-color); color: white; padding: 2px 6px; border-radius: 4px; }

        .explanation { background: #fffbe6; border: 1px solid #ffe58f; padding: 10px; margin-top: 10px; border-radius: 5px; display: none; }
        .explanation.show { display: block; }
        
        /* --- 구절풀이 팝업 스타일 시작 --- */
        .explanation-popup {
            position: absolute;
            background-color: #fffbe6; /* 배경을 베이지색으로 */
            color: #5d4037; /* 글자색 변경 */
            border: 1px solid #ffe58f; /* 테두리 추가 */
            border-radius: 8px; /* 모서리를 더 둥글게 */
            padding: 12px 30px 12px 18px; /* 오른쪽 여백 확보 */
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* 입체감을 위한 그림자 */
            max-width: 300px;
            font-size: 0.9em;
            white-space: pre-wrap;
            /* 애니메이션 효과 */
            display: none; /* 기본적으로 숨김 */
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        .explanation-popup.show {
            display: block;
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        /* 팝업 위쪽 화살표 모양 (테두리) */
        .explanation-popup::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 20px;
            border: 9px solid transparent;
            border-bottom-color: #ffe58f;
        }
        /* 팝업 위쪽 화살표 모양 (내용) */
        .explanation-popup::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 21px;
            border: 8px solid transparent;
            border-bottom-color: #fffbe6;
        }
        .popup-close-btn {
            position: absolute;
            top: 2px;
            right: 5px;
            background: transparent;
            border: none;
            font-size: 1.5em;
            line-height: 1;
            color: #c0c0c0;
            cursor: pointer;
            transition: color 0.2s;
        }
        .popup-close-btn:hover {
            color: #5d4037;
        }
        /* --- 구절풀이 팝업 스타일 끝 --- */

        /* --- 객관식 정답 스텝퍼 UI 스타일 시작 --- */
        .mcq-answer-stepper {
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
        }
        .mcq-answer-btn {
            background-color: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            width: 32px;
            height: 32px;
            line-height: 32px;
            text-align: center;
            color: #495057;
        }
        .mcq-answer-btn:hover {
            background-color: #e9ecef;
        }
        .mcq-answer-display {
            width: 40px;
            height: 32px;
            line-height: 32px;
            text-align: center;
            font-weight: bold;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
            background-color: #fff;
        }
        /* --- 객관식 정답 스텝퍼 UI 스타일 끝 --- */

        /* --- 객관식 선택 선지 하이라이트 스타일 시작 --- */
        #preview .mcq-preview-option.selected {
            font-weight: bold;
        }
        #preview .mcq-preview-option.selected.correct {
            background-color: #e8f5e9; /* 연한 초록 */
            border: 1px solid var(--correct-color);
        }
        #preview .mcq-preview-option.selected.incorrect {
            background-color: #ffebee; /* 연한 빨강 */
            border: 1px solid var(--incorrect-color);
        }
        /* --- 객관식 선택 선지 하이라이트 스타일 끝 --- */

        /* --- 오늘의 퀴즈 스타일 시작 --- */
        .daily-quiz-editor {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        .daily-quiz-preview {
            background-color: #fffaf0;
            border: 1px solid #f0e68c;
            border-left: 5px solid #d8bfd8;
            border-radius: 8px;
            padding: 15px 20px;
        }
        .daily-quiz-preview .quiz-title-preview {
            font-size: 1.1em;
            color: #5d4037;
        }
        .daily-quiz-preview .mcq-options-preview {
            margin-left: 0;
        }
        .daily-quiz-preview .mcq-preview-option {
            border: 1px solid #e0e0e0;
            margin-bottom: 8px;
            background-color: #fff;
        }
        /* --- 오늘의 퀴즈 스타일 끝 --- */

        .new-proverb-btn {
            margin-left: auto; /* 버튼을 오른쪽으로 정렬 */
            background-color: #f0e68c;
            border: 1px solid #d8bfd8;
            color: #5d4037;
            font-weight: bold;
        }
        
        /* --- 글꼴 크기 및 색상 버튼 스타일 시작 --- */
        .toolbar-btn-group {
            display: inline-flex;
            vertical-align: middle;
            margin: 2px;
        }
        .toolbar-btn-group button {
            margin: 0;
            border-radius: 0;
            border-right-width: 0;
        }
        .toolbar-btn-group button:first-child {
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }
        .toolbar-btn-group button:last-child {
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
            border-right-width: 1px;
        }
        
        .dropdown {
            position: relative;
            display: inline-block;
            vertical-align: middle;
        }
        .dropdown-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .color-indicator {
            display: inline-block;
            width: 14px;
            height: 4px;
            background-color: black;
            border-radius: 2px;
        }
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1001;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .dropdown-menu.show {
            display: grid; /* block에서 grid로 변경하여 팔레트 정렬 */
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        .color-palette .color-swatch {
             width: 28px;
             height: 28px;
             margin: 0;
        }
        /* --- 글꼴 크기 및 색상 버튼 스타일 끝 --- */
        
        /* --- 개별 스타일 팔레트 드롭다운 스타일 시작 --- */
        .style-grid-mini {
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            padding: 5px;
            width: auto; /* 버튼 크기에 맞춰 전체 너비 축소 */
        }
        .dropdown-menu.style-grid-mini.show {
            display: grid; 
        }
        .style-grid-mini button {
            width: 15px; /* 버튼 너비 축소 */
            height: 15px; /* 버튼 높이 축소 */
            min-width: 0;
            margin: 0;
        }
        /* 오른쪽 정렬이 필요한 팝업 메뉴를 위한 스타일 (넘침 문제 해결) */
        .dropdown-menu-right {
            left: 50%; /* 1. 왼쪽을 기준으로 부모(버튼)의 중앙에 위치 */
            transform: translateX(-50%); /* 2. 팝업 자체 너비의 절반만큼 왼쪽으로 이동 */
        }

        /* --- 개별 스타일 팔레트 드롭다운 스타일 끝 --- */

        .explanation-modal-header {
            padding: 15px 25px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
            border-radius: 8px 8px 0 0;
        }
        .explanation-modal-header .selected-text-display {
            color: #6c757d;
            font-weight: normal;
        }
        .mini-toolbar {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .mini-toolbar button {
            border: 1px solid var(--border-color);
            background-color: #fff;
            cursor: pointer;
            padding: 5px;
            margin: 2px;
            border-radius: 4px;
            font-size: 1em;
            vertical-align: middle;
            min-width: 32px;
        }
        .mini-toolbar button:hover {
            background-color: #e2e6ea;
        }


        #explanation-emoji-palette {
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            margin-bottom: 10px;
        }
        .modal-emoji {
            cursor: pointer;
            font-size: 1.4em;
            margin-right: 8px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .modal-emoji:hover {
            opacity: 1;
        }

        .editor-column .tab-btn { position: relative; padding-right: 28px; }
        .editor-column .tab-btn .delete-tab-btn {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            font-size: 1.1em;
            line-height: 1;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        .editor-column .tab-btn:hover .delete-tab-btn { opacity: 1; }
        .editor-column .tab-btn .delete-tab-btn:hover { color: var(--incorrect-color); font-weight: bold; }
        .editor-column .tab-btn.dragging { opacity: 0.5; background: #e2e6ea; }

        .exported-body .tab-content { display: none; }
        .exported-body .tab-content.active { display: block; }

        /* 좌측 패널 스크롤바 완전히 숨기기 */
        .left-panel::-webkit-scrollbar {
            display: none; /* 스크롤바를 보이지 않게 처리 */
        }
        
        /* --- 반응형 디자인을 위한 미디어 쿼리 --- */
        @media (max-width: 1024px) {
            body {
                padding: 10px; /* 모바일에서는 전체 여백을 줄입니다. */
            }

            .container {
                flex-direction: column; /* 3단 가로 배치를 세로로 쌓습니다. */
            }

            .left-panel {
                position: static; /* 화면에 붙어있던 효과를 해제합니다. */
                width: 100%;
                height: auto; /* 내용에 따라 높이가 자동 조절됩니다. */
                overflow-y: visible; /* 스크롤을 해제합니다. */
                padding-right: 0; /* 스크롤바를 위해 추가했던 여백을 제거합니다. */
            }
        }

        .blank-container {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .blank-choices {
            font-size: 0.9em;
            color: #6c757d;
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
    .revealable-cloze {
        border: 1px dashed var(--primary-color);
        color: var(--primary-color);
        padding: 1px 5px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .revealable-cloze:hover {
        background-color: #e3f2fd; /* Light blue */
    }
    .revealed-answer {
        font-weight: bold;
        color: var(--correct-color); /* Green */
        padding: 1px 5px;
        cursor: pointer;
    }

/* --- 맨 위로 가기 버튼 스타일 시작 --- */
    #scrollToTopBtn {
        position: fixed;
        bottom: 30px;
        right: 40px;
        width: 50px;
        height: 50px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.5em;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        opacity: 0; /* ✅ 기본적으로 투명하게 */
        visibility: hidden; /* ✅ 화면에서 완전히 숨김 */
        pointer-events: none; /* ✅ 숨겨졌을 때 클릭되지 않도록 */
        transition: all 0.2s ease-in-out;
    }
    #scrollToTopBtn.show {
        opacity: 0.8;
        visibility: visible;
        pointer-events: auto;
    }

    #scrollToTopBtn:hover {
        opacity: 1;
        transform: translateY(-3px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
    }

    #scrollToTopBtn:active {
        transform: translateY(0);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    /* --- 맨 위로 가기 버튼 스타일 끝 --- */

    /* --- 분류하기 퀴즈 에디터 스타일 --- */
    .classification-editor-container hr {
        border: 0;
        height: 1px;
        background-color: var(--border-color);
    }
    .classification-category-editor-row,
    .classification-item-editor-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        margin-bottom: 5px;
        background-color: #fff;
        border: 1px dashed var(--border-color);
        border-radius: 4px;
    }
    .classification-category-editor-row input,
    .classification-item-editor-row .item-text-input {
        flex-grow: 1;
        border: 1px solid #ccc;
        padding: 5px;
        border-radius: 3px;
    }
    .classification-item-editor-row .item-category-select {
        flex-basis: 150px; /* 카테고리 선택 드롭다운 너비 고정 */
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 3px;
        background-color: #f8f9fa;
    }
    .delete-classification-category,
    .delete-classification-item {
        background: transparent;
        border: none;
        color: #aaa;
        cursor: pointer;
        font-size: 1.4em;
        font-weight: bold;
        padding: 0 5px;
        line-height: 1;
    }
    .delete-classification-category:hover,
    .delete-classification-item:hover {
        color: var(--incorrect-color);
    }

    /* --- 분류하기 퀴즈 미리보기 스타일 --- */
    .classification-preview-container {
        margin-top: 15px;
    }
    .classification-categories-preview {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        align-items: stretch;
        flex-wrap: wrap; /* 공간이 부족하면 다음 줄로 넘어가도록 설정 */
    }
    .classification-category-bin {
        flex: 1 0 180px; /* 기본 너비를 180px로 설정하고, 공간이 남으면 늘어남 */
        display: flex;
        flex-direction: column;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--background-light);
    }
    .classification-category-bin .category-title {
        font-weight: bold;
        text-align: center;
        padding: 8px;
        border-bottom: 1px solid var(--border-color);
        background-color: #f0f3f5;
    }
    .category-drop-zone {
        min-height: 80px;
        padding: 10px;
        flex-grow: 1;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        transition: background-color 0.2s;
    }
    .category-drop-zone.drag-over {
        background-color: #e0f2f1; /* 연한 민트색 */
    }
    .classification-items-source {
        min-height: 50px;
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--background-light);
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: center;
    }
    .classification-item-card {
        padding: 6px 14px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 15px;
        cursor: grab;
        user-select: none;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        transition: all 0.2s;
    }
    .classification-item-card:active {
        cursor: grabbing;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .classification-item-card.dragging {
        opacity: 0.5;
    }
    .classification-item-card.correct {
        border-color: var(--correct-color);
        background-color: #e8f5e9;
    }
    .classification-item-card.incorrect {
        border-color: var(--incorrect-color);
        background-color: #ffebee;
    }
    
    </style>
</head>
<body>
    <div class="container">
        <div class="view-mode-controls">
            <button data-view-mode="editor" title="편집기 모드">🖥️</button>
            <button data-view-mode="split" class="active" title="분할 모드">📑</button>
            <button data-view-mode="preview" title="미리보기 모드">🔍</button>
        </div>
        <button id="scrollToTopBtn" title="맨 위로 이동">▲</button>

        <div class="left-panel">
            <div id="file-manager">
                <h4>파일 관리</h4>
                <div class="icon-grid">
                    <button id="new-work-btn" title="새 파일 만들기">🆕</button>
                    <button id="load-work-btn" title="불러오기">📂</button>
                    <button id="save-work-btn" title="내용 저장하기">💾</button>
                    <button id="export-html-btn" title="HTML로 내보내기">📑</button>
                </div>
                <div id="version-info">Juno Interactive Editor(v2.05)</div>
            </div>
            <div id="toolbar">
                <h4>서식 도구</h4>
                <div class="toolbar-group">
                    <button data-command="customRemoveFormat" title="서식 지우기"><s>A</s></button>
                    <button data-command="bold" title="굵게"><b>B</b></button>
                    <button data-command="underline" title="밑줄"><u>U</u></button>
                    <div class="dropdown">
                        <button class="dropdown-toggle" data-command="toggleBgColorDropdown" title="배경색">🟨</button>
                        <div class="dropdown-menu style-grid-mini">
                            <button class="color-swatch" data-command="backColor" data-value="#EAEAEA" style="background-color:#EAEAEA;" title="연회색"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#FFFACD" style="background-color:#FFFACD;" title="연노랑"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#FFDAB9" style="background-color:#FFDAB9;" title="연주황"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#FFD6D6" style="background-color:#FFD6D6;" title="연빨강"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#E6E6FA" style="background-color:#E6E6FA;" title="연보라"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#D3FCD3" style="background-color:#D3FCD3;" title="연초록"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#D2EAFF" style="background-color:#D2EAFF;" title="연파랑"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#E0F2F1" style="background-color:#E0F2F1;" title="연민트"></button>
                        </div>
                    </div>
                    <button title="왼쪽 정렬" data-command="justifyLeft"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M2 3h12v2H2zm0 4h9v2H2zm0 4h12v2H2z"></path></svg></button>
                    <button title="가운데 정렬" data-command="justifyCenter"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M4 3h8v2H4zm-2 4h12v2H2zm2 4h8v2H4z"></path></svg></button>
                    <button title="오른쪽 정렬" data-command="justifyRight"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M2 3h12v2H2zm3 4h9v2H5zm-3 4h12v2H2z"></path></svg></button>
                    <div class="dropdown">
                        <button class="dropdown-toggle" data-command="toggleBorderDropdown" title="테두리">▭</button>
                        <div class="dropdown-menu style-grid-mini">
                            <button data-command="applyTextBorder" data-value="black" title="검정 테두리" style="border: 2px solid black;"></button>
                            <button data-command="applyTextBorder" data-value="gray" title="회색 테두리" style="border: 2px solid gray;"></button>
                            <button data-command="applyTextBorder" data-value="red" title="빨강 테두리" style="border: 2px solid red;"></button>
                            <button data-command="applyTextBorder" data-value="violet" title="보라 테두리" style="border: 2px solid violet;"></button>
                            <button data-command="applyTextBorder" data-value="blue" title="파랑 테두리" style="border: 2px solid blue;"></button>
                            <button data-command="applyTextBorder" data-value="green" title="초록 테두리" style="border: 2px solid green;"></button>
                        </div>
                    </div>
                    <div class="toolbar-btn-group">
                        <button data-command="increaseFontSize" title="글자 크게">A⁺</button>
                        <button data-command="decreaseFontSize" title="글자 작게">A⁻</button>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-toggle" data-command="fontColor" title="글꼴 색상">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M7.13 11.168H3.856L3 13.312h1.088l.896-2.144H7.13zm-1.12-1.744h-.032L5.224 7.64l-.768 1.784h1.536zM2 2v2h12V2H2zm11.536 7.424c0 .448-.128.848-.384 1.2s-.592.624-1.008.816c-.416.192-.896.288-1.44.288-.608 0-1.136-.128-1.584-.384s-.8-! .592-.912c-.272-.32-.464-.704-.576-1.152L8 8.688H2.416l1.632-4.016h2.24l-1.328 3.328h2.992L9.28 4.672h2.24l-.944 2.24c.544.128.992.384 1.344.768.352.384.528.864.528 1.424z"></path></svg>
                            <span class="color-indicator"></span>
                        </button>
                        <div class="dropdown-menu color-palette">
                            <button class="color-swatch" data-value="#000000" style="background-color:#000000;" title="검정"></button>
                            <button class="color-swatch" data-value="#ff0000" style="background-color:#ff0000;" title="빨강"></button>
                            <button class="color-swatch" data-value="#0000ff" style="background-color:#0000ff;" title="파랑"></button>
                            <button class="color-swatch" data-command="backColor" data-value="#008000" style="background-color:#008000;" title="초록"></button>
                            <button class="color-swatch" data-value="#ffa500" style="background-color:#ffa500;" title="주황"></button>
                            <button class="color-swatch" data-value="#800080" style="background-color:#800080;" title="보라"></button>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropdown-toggle" data-command="toggleHighlightDropdown" title="강조 (배경+테두리)">🔲</button>
                        <div class="dropdown-menu style-grid-mini dropdown-menu-right">
                            <button data-command="applyTextHighlight" data-value="gray" title="회색 강조" style="background-color: #eeeeee; border: 2px solid #bdbdbd;"></button>
                            <button data-command="applyTextHighlight" data-value="violet" title="보라 강조" style="background-color: #f3e5f5; border: 2px solid #ce93d8;"></button>
                            <button data-command="applyTextHighlight" data-value="red" title="빨강 강조" style="background-color: #ffebee; border: 2px solid #e57373;"></button>
                            <button data-command="applyTextHighlight" data-value="yellow" title="노랑 강조" style="background-color: #fffde7; border: 2px solid #fff176;"></button>
                            <button data-command="applyTextHighlight" data-value="blue" title="파랑 강조" style="background-color: #e3f2fd; border: 2px solid #90caf9;"></button>
                            <button data-command="applyTextHighlight" data-value="green" title="초록 강조" style="background-color: #e8f5e9; border: 2px solid #a5d6a7;"></button>
                        </div>
                    </div>
                </div>
                <hr style="border: 0; height: 0; border-top: 1px solid rgba(0, 0, 0, 0.1); border-bottom: 1px solid rgba(255, 255, 255, 0.3);">
                <div class="toolbar-group">
                    <button data-command="outdent" title="내어쓰기"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M1 3h14v2H1zm0 4h10v2H1zm0 4h14v2H1zm4-6V7l-4 2 4 2V7z"></path></svg></button>
                    <button data-command="indent" title="들여쓰기"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M1 3h14v2H1zm0 4h10v2H1zm0 4h14v2H1zm11-6v4l4-2-4-2z"></path></svg></button>
                    <button id="paste-block-btn" title="블록 붙여넣기">📋+</button>
                    <button id="add-explanation-btn" title="구절풀이 추가">💬</button>
                </div>
                <div class="toolbar-group">
                    <h4>이모지</h4>
                    <div id="emoji-palette"></div>
                </div>
            </div>
            <div id="block-adder">
                <h4>➕ 콘텐츠 블록</h4>
                <div class="icon-grid">
                    <button data-type="text" title="일반 텍스트"><div class="text-2xl">📝</div><span class="mt-1">텍스트</span></button>
                    <button data-type="summary" title="핵심 구절 요약" style="background-color: #E1F5FE;"><div class="text-2xl">📖</div><span class="mt-1">구절풀이</span></button>
                    <button data-type="spacer" title="빈 블록 (공백)"><div class="text-2xl">↔️</div><span class="mt-1">공백</span></button>
                    <button data-type="table" title="표 삽입"><div class="text-2xl">田</div><span class="mt-1">표</span></button>
                    <button data-type="flowchart" title="순서도" style="background-color: #E0E0E0;"><div class="text-2xl">➔</div><span class="mt-1">순서도</span></button>
                    <button data-type="mindmap" title="마인드맵" style="background-color: #CFD8DC;"><div class="text-2xl">🔀</div><span class="mt-1">마인드맵</span></button>
                    <button data-type="mcq" title="객관식 퀴즈"><div class="text-2xl">🔢</div><span class="mt-1">객관식</span></button>
                    <button data-type="descriptive" title="서술형"><div class="text-2xl">✍️</div><span class="mt-1">서술형</span></button>
                    <button data-type="ox" title="OX 퀴즈"><div class="text-2xl">⭕</div><span class="mt-1">OX</span></button>
                    <button data-type="fill-in" title="빈칸 넣기"><div class="text-2xl">[]</div><span class="mt-1">빈칸넣기</span></button>
                    <button data-type="line-quiz" title="선긋기 퀴즈"><div class="text-2xl">〰️</div><span class="mt-1">선긋기</span></button>
                    <button data-type="drag-drop" title="드래그 앤 드롭 퀴즈" style="background-color: #C5E1A5;"><div class="text-2xl">✋</div><span class="mt-1">드래그</span></button>
                    <button data-type="ordering" title="순서 배열 퀴즈" style="background-color: #FFDAB9;"><div class="text-2xl">📊</div><span class="mt-1">순서배열</span></button>
                    <button data-type="classification" title="분류하기 퀴즈" style="background-color: #FFECB3;"><div class="text-2xl">🗂️</div><span class="mt-1">분류하기</span></button>
                    <button data-type="math" title="수식"><div class="text-2xl">➗</div><span class="mt-1">수식</span></button>
                    <button data-type="youtube" title="유튜브" style="background-color: #ffcdd2;"><div class="text-2xl">🎬</div><span class="mt-1">유튜브</span></button>
                    <button data-type="link" title="링크 삽입" style="background-color: #E0F7FA;"><div class="text-2xl">🔗</div><span class="mt-1">링크</span></button>
                    <button data-type="frame" title="프레임 삽입" style="background-color: #D1C4E9;"><div class="text-2xl">🖼️</div><span class="mt-1">프레임</span></button>
                    <button data-type="daily-quiz" title="오늘의 퀴즈" style="background-color: #D8BFD8;"><div class="text-2xl">📅</div><span class="mt-1">오늘의<br>퀴즈</span></button>
                </div>
            </div>
        </div>

        <div class="editor-column">
            <input type="text" id="editor-title-input" placeholder="전체 제목을 입력하세요">
            <div id="editor-tab-bar" class="tab-bar">
                <div id="editor-tab-buttons" style="display: inline-block;"></div>
                <button id="add-tab-btn" class="tab-btn">+</button>
            </div>
            <div id="editor"></div>
        </div>

        <div class="preview-column">
            <div class="preview-top-bar">
                <h1 id="preview-main-title">학습지</h1>
            </div>
            <div id="preview-tab-bar" class="tab-bar preview-tabs">
                <div id="preview-tab-buttons" style="display: inline-block;"></div>
            </div>
            <div id="preview"></div>
        </div>
    </div>
    <input type="file" id="file-loader" style="display: none;" accept=".json">
    <div id="explanationPopup" class="explanation-popup"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let blockClipboard = null;
        // --- 데이터 및 상태 관리 ---
        const emojiList = ['▶️','➡️','⬇️','↔️','✨','💬','📝','📒','💡','📌','📍','☑️','🔸','💠','▪️','●','💕','💔','『','』','❓','❗','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣'];
        const DEFAULT_TITLE_TEXT = '전체 제목을 입력하세요';
        let contentData = {};
        let tabOrder = [];
        let activeTabId = null;
        let blockIdCounter = 0;
        let savedRange = null;
        let isDirty = false;
        const FILL_IN_PLACEHOLDER = '문장에 []를 입력하여 빈칸을 만드세요.';

        // --- DOM 요소 ---
        const editorTitleInput = document.getElementById('editor-title-input');
        const previewMainTitle = document.getElementById('preview-main-title');
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const blockAdder = document.getElementById('block-adder');
        const toolbar = document.getElementById('toolbar');
        const emojiPalette = document.getElementById('emoji-palette');
        const explanationPopup = document.getElementById('explanationPopup');
        const editorTabButtons = document.getElementById('editor-tab-buttons');
        const previewTabButtons = document.getElementById('preview-tab-buttons');
        const addTabBtn = document.getElementById('add-tab-btn');
        const fileLoader = document.getElementById('file-loader');

        // --- 화면 보기 모드 제어 ---
        const container = document.querySelector('.container');
        const viewModeControls = document.querySelector('.view-mode-controls');

        if (viewModeControls) {
            viewModeControls.addEventListener('click', e => {
                const clickedButton = e.target.closest('button');
                if (!clickedButton) return;

                const viewMode = clickedButton.dataset.viewMode;

                // 1. 모든 뷰 모드 클래스를 먼저 제거합니다.
                container.classList.remove('view-mode-editor', 'view-mode-split', 'view-mode-preview');
                
                // 2. 클릭한 버튼에 해당하는 뷰 모드 클래스를 추가합니다.
                container.classList.add(`view-mode-${viewMode}`);

                // 3. 모든 버튼에서 'active' 스타일을 제거하고,
                viewModeControls.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                
                // 4. 클릭한 버튼에만 'active' 스타일을 적용합니다.
                clickedButton.classList.add('active');
                updateBlockAdderState();
            });
        }

        // --- 전체 제목 이벤트 ---
        editorTitleInput.addEventListener('click', () => { editorTitleInput.select(); });
        editorTitleInput.addEventListener('input', () => {
            const titleValue = editorTitleInput.value.trim();
            previewMainTitle.textContent = (titleValue === '' || titleValue === DEFAULT_TITLE_TEXT) ? '학습지' : titleValue;
            isDirty = true;
        });
        
        // --- 초기화 ---
        function initialize() {
            initEmojiPalette();
            if (tabOrder.length === 0) {
                editor.innerHTML = "<p style='color: #888;'>위쪽 '+' 버튼을 눌러 첫 단원을 추가하세요.</p>";
                preview.innerHTML = "";
            }
            updateBlockAdderState();
        }

        function initEmojiPalette() {
            emojiPalette.innerHTML = emojiList.map(emoji => `<span title="${emoji}">${emoji}</span>`).join('');
        }
        
        // --- UI 상태 관리 ---
        function updateBlockAdderState() {
            const isInPreviewMode = container.classList.contains('view-mode-preview');
            if (tabOrder.length === 0 || isInPreviewMode) {
                blockAdder.classList.add('disabled');
            } else {
                blockAdder.classList.remove('disabled');
            }
        }
        
        function syncInputAttributes(container) {
            container.querySelectorAll('input[type="url"], input[type="text"], input[type="number"], input[type="hidden"], textarea').forEach(input => {
                input.setAttribute('value', input.value);
            });
            container.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => {
                if (input.checked) {
                    input.setAttribute('checked', 'checked');
                } else {
                    input.removeAttribute('checked');
                }
            });
            container.querySelectorAll('select').forEach(select => {
                // 먼저 모든 옵션에서 'selected' 속성을 제거합니다.
                select.querySelectorAll('option').forEach(option => {
                    option.removeAttribute('selected');
                });

                // 현재 선택된 값과 일치하는 옵션을 찾아 'selected' 속성을 추가합니다.
                const selectedOption = select.querySelector(`option[value="${select.value}"]`);
                if (selectedOption) {
                    selectedOption.setAttribute('selected', 'selected');
                }
            });
        }
        
        // --- 파일 관리 ---
        function newFile() {
            if (isDirty && !confirm('현재 작업중인 내용이 사라집니다. 새 파일을 만드시겠습니까?')) {
                return;
            }
            contentData = {};
            tabOrder = [];
            activeTabId = null;
            editorTitleInput.value = '';
            previewMainTitle.textContent = '학습지';
            editorTabButtons.innerHTML = '';
            previewTabButtons.innerHTML = '';
            initialize();
            isDirty = false;
        }

        document.getElementById('new-work-btn').addEventListener('click', newFile);

        document.getElementById('save-work-btn').addEventListener('click', () => {
            if (activeTabId) {
                syncInputAttributes(editor);
                contentData[activeTabId].html = editor.innerHTML;
            }
            const fullData = {
                title: editorTitleInput.value,
                tabs: contentData,
                order: tabOrder
            };
            const dataStr = JSON.stringify(fullData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            const now = new Date();
            const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
            const timeStr = `${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            const title = editorTitleInput.value.replace(/[\\/:*?"<>|]/g, '_') || '제목없음';
            const filename = `${title}_${dateStr}_${timeStr}.json`;

            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            isDirty = false;
        });

        document.getElementById('load-work-btn').addEventListener('click', () => {
            if (isDirty && !confirm('현재 작업중인 내용이 사라집니다. 계속하시겠습니까?')) {
                return;
            }
            fileLoader.click();
        });
        
        fileLoader.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const loadedData = JSON.parse(event.target.result);
                    const loadedTitle = loadedData.title || "";
                    editorTitleInput.value = loadedTitle;
                    previewMainTitle.textContent = (loadedTitle.trim() === '') ? '학습지' : loadedTitle;
                    contentData = loadedData.tabs;
                    tabOrder = loadedData.order || Object.keys(contentData);
                    rebuildUIFromData();
                    isDirty = false;
                } catch (err) {
                    alert('올바른 저장 파일이 아닙니다.');
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        function rebuildUIFromData() {
            editorTabButtons.innerHTML = '';
            previewTabButtons.innerHTML = '';
            
            if (tabOrder.length > 0) {
                tabOrder.forEach(tabId => {
                    if(contentData[tabId]) {
                        createTabButton(tabId, contentData[tabId].name, editorTabButtons, true);
                        createTabButton(tabId, contentData[tabId].name, previewTabButtons, false);
                    }
                });
                const firstValidTab = tabOrder.find(id => contentData[id]);
                if(firstValidTab) switchTab(firstValidTab);
                else initialize();

            } else {
                initialize();
            }
            updateBlockAdderState();
        }

        document.getElementById('export-html-btn').addEventListener('click', () => {
            if (tabOrder.length === 0) {
                alert("내보낼 내용이 없습니다. 먼저 단원을 추가하고 내용을 작성해주세요.");
                return;
            }
            if (activeTabId) {
                syncInputAttributes(editor);
                contentData[activeTabId].html = editor.innerHTML;
            }

            const titleValue = editorTitleInput.value.trim();
            const title = (titleValue === '' || titleValue === DEFAULT_TITLE_TEXT) ? '학습지' : titleValue;
            
            const styles = Array.from(document.styleSheets)
                .map(s => {
                    try { return Array.from(s.cssRules).map(r => r.cssText).join('\n'); }
                    catch (e) { return ''; }
                })
                .join('\n');

            let tabButtonsHtml = '';
            let tabContentsHtml = '';
            const tempEditorContainer = document.createElement('div');

            tabOrder.forEach((tabId, index) => {
                const tabData = contentData[tabId];
                if (!tabData) return;
                
                tabButtonsHtml += `<button class="tab-btn ${index === 0 ? 'active' : ''}" data-tab-id="${tabId}">${tabData.name}</button>`;
                
                tempEditorContainer.innerHTML = tabData.html;
                let currentTabContent = `<h2 style="display:none;">${tabData.name}</h2>`;

                tempEditorContainer.querySelectorAll('.block').forEach(editorBlock => {
                    const wrapper = document.createElement('div');
                    const previewBlock = document.createElement('div');
                    wrapper.appendChild(previewBlock);
                    
                    updatePreviewBlock(editorBlock, previewBlock);
                    
                    currentTabContent += wrapper.innerHTML;
                });

                tabContentsHtml += `<div class="tab-content ${index === 0 ? 'active' : ''}" data-tab-content-id="${tabId}">${currentTabContent}</div>`;
            });
            
            const finalPreviewTitle = previewMainTitle.textContent;
            
            const bodyHtml = `
                <div class="preview-top-bar">
                    <h1 id="preview-main-title">${finalPreviewTitle}</h1>
                </div>
                <div id="preview-tab-bar" class="tab-bar preview-tabs">
                    <div id="preview-tab-buttons">${tabButtonsHtml}</div>
                </div>
                <div id="preview">${tabContentsHtml}</div>
                <button id="scrollToTopBtn" title="맨 위로 이동">▲</button>
                <div id="explanationPopup" class="explanation-popup"></div>
            `;
            
            const interactiveScript = getExportableInteractiveScript();

            const finalHtml = `<!DOCTYPE html>
                <html lang="ko">
                <head>
                    <meta charset="UTF-8">
                    <title>${title}</title>
                    <style>${styles}</style>
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"><\/script>
                    <script>
                        window.MathJax = {
                          tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']] },
                          svg: { fontCache: 'global' }
                        };
                    <\/script>
                    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"><\/script>
                </head>
                <body class="exported-body" style="background-color: #f4f7f9; font-family: 'Malgun Gothic', sans-serif;">
                    <div id="exported-container" style="width: 90%; max-width: 1100px; margin: 20px auto; background: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                        ${bodyHtml}
                    </div>
                    <script>${interactiveScript}<\/script>
                </body>
                </html>`;

            const blob = new Blob([finalHtml], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[\\/:*?"<>|]/g, '_')}.html`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // --- 탭 관리 ---
        function addNewTab(name = null) {
            const tabName = name || prompt("새 단원 이름을 입력하세요:", `새 단원 ${tabOrder.length + 1}`);
            if (!tabName) return;
            if(tabOrder.length === 0) editor.innerHTML = ''; 
            const tabId = `tab-${Date.now()}`;
            contentData[tabId] = { name: tabName, html: `` };
            tabOrder.push(tabId);

            createTabButton(tabId, tabName, editorTabButtons, true);
            createTabButton(tabId, tabName, previewTabButtons, false);
            
            switchTab(tabId);
            updateBlockAdderState();
            isDirty = true;
        }

        function createTabButton(tabId, name, container, isEditor) {
            const button = document.createElement('button');
            button.className = 'tab-btn';
            button.dataset.tabId = tabId;

            const nameSpan = document.createElement('span');
            nameSpan.textContent = name;
            button.appendChild(nameSpan);

            if (isEditor) {
                button.draggable = true;
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-tab-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = '단원 삭제';
                button.appendChild(deleteBtn);
            }
            container.appendChild(button);
        }

        function deleteTab(tabId) {
            if (!confirm(`'${contentData[tabId].name}' 단원을 정말 삭제하시겠습니까?`)) return;

            const tabIndex = tabOrder.indexOf(tabId);

            delete contentData[tabId];
            tabOrder.splice(tabIndex, 1);

            document.querySelectorAll(`.tab-btn[data-tab-id="${tabId}"]`).forEach(btn => btn.remove());
            isDirty = true;
            
            if (activeTabId === tabId) {
                if (tabOrder.length > 0) {
                    const newActiveIndex = Math.max(0, tabIndex - 1);
                    switchTab(tabOrder[newActiveIndex]);
                } else {
                    activeTabId = null;
                    initialize();
                }
            }
        }
        
        function renameTab(tabId) {
            const currentName = contentData[tabId].name;
            const newName = prompt("단원 이름을 수정하세요:", currentName);
            if (newName && newName !== currentName) {
                contentData[tabId].name = newName;
                document.querySelectorAll(`.tab-btn[data-tab-id="${tabId}"]`).forEach(btn => btn.querySelector('span:first-child').textContent = newName);
                renderFullPreview();
                isDirty = true;
            }
        }

        function switchTab(tabId) {
            if (activeTabId && contentData[activeTabId]) {
                 syncInputAttributes(editor);
                 contentData[activeTabId].html = editor.innerHTML;
            }
            activeTabId = tabId;
            editor.innerHTML = contentData[tabId].html;
            
            try {
                editor.querySelectorAll('.math-editor-field').forEach(mathField => {
                    const latexOutput = mathField.nextElementSibling;
                    const MQ = MathQuill.getInterface(2);
                    const mathQuillField = MQ.MathField(mathField, {
                        handlers: {
                            edit: () => {
                                latexOutput.value = mathQuillField.latex();
                                renderFullPreview();
                                isDirty = true;
                            }
                        }
                    });
                    mathQuillField.latex(mathField.nextElementSibling.getAttribute('value') || '');
                });
            } catch(e) {
                console.error("수식 편집기 초기화 중 오류 발생:", e);
                // 여기에 사용자에게 알리는 로직을 추가할 수도 있습니다.
            }

            renderFullPreview();
            document.querySelectorAll('#editor-tab-buttons .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tabId === tabId);
            });
             document.querySelectorAll('#preview-tab-buttons .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tabId === tabId);
            });

            // ✅ 탭 전환 시 미리보기 영역의 최상단으로 스크롤하는 코드 추가
            document.querySelector('.preview-column').scrollIntoView({ behavior: 'smooth' });
        }
        
        // --- 블록 추가/수정 ~ 미리보기 렌더링 ~ 인터랙티브 블록 초기화 ---
        function addBlock(type) {
            blockIdCounter++;
            const editorBlock = document.createElement('div');
            editorBlock.className = 'block';
            editorBlock.dataset.type = type;
            editorBlock.dataset.id = `block-${blockIdCounter}`;
            let content = '';
            switch (type) {
                case 'text':
                    content = `<input type="hidden" class="toggle-state-input" value="open">
                            <div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="toggle-default-btn" title="미리보기 토글 기본값 (펼침/닫힘)">👁️</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                            <div class="block-title">📝 <span class="block-title-text" contenteditable="true">일반 텍스트</span></div><br><small>🖼️ [](이미지URL) 🔗[주소명](URL)  ❓ [□□|정답] ❓ [빈칸넣기 정답] ❓ [오답1,*정답,오답2]</small><div class="editable" contenteditable="true"></div>`;
                    break;
                case 'ox':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div><div class="block-title">⭕ OX 퀴즈</div>
                                <div class="quiz-title-container-editor">
                                    <strong>퀴즈 제목:</strong>
                                    <div class="editable quiz-title-editor" contenteditable="true" placeholder="퀴즈 제목 (선택 사항)"></div>
                                </div>
                                <div class="ox-items-container"></div><button class="add-ox-item">+ 퀴즈 추가</button>`;
                    break;
                case 'mcq':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div><div class="block-title">🔢 객관식</div>
                                <div class="quiz-title-container-editor">
                                   <strong>문제:</strong>
                                   <div class="editable mcq-question-editor" contenteditable="true" placeholder="문제를 입력하세요..."></div>
                                </div>
                                <div class="mcq-passage-container-editor">
                                   <strong>보기:</strong>
                                   <div class="editable mcq-passage-editor" contenteditable="true" placeholder="필요시 지문, 표, 이미지 등을 여기에 입력하세요..."></div>
                                </div>
                                <h4>선지</h4><div class="mcq-options-container"></div><button class="add-mcq-option">+ 선지 추가</button>
                                <hr><strong>정답 선택:</strong>
                                <div class="mcq-answer-stepper">
                                    <button type="button" class="mcq-answer-btn" data-step="-1">-</button>
                                    <span class="mcq-answer-display">1</span>
                                    <button type="button" class="mcq-answer-btn" data-step="1">+</button>
                                    <input type="hidden" class="mcq-answer" value="1">
                                </div><br>
                                <strong>해설:</strong><div class="editable mcq-explanation-editor" contenteditable="true" placeholder="해설을 입력하세요..."></div>`;
                    break;
                case 'spacer':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div><div class="block-title">↔️ 빈 블록 (공백)</div><div class="resize-handle"></div>`;
                    break;
                case 'descriptive':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div><div class="block-title">✍️ 서술형</div>
                               <div class="descriptive-editor-row">
                                   <strong>문제:</strong>
                                   <div class="editable" contenteditable="true" placeholder="문제를 입력하세요..."></div>
                               </div>
                               <div class="descriptive-editor-row">
                                   <strong>정답:</strong>
                                   <div class="editable" contenteditable="true" placeholder="정답을 입력하세요 (여러 개일 경우 , 로 구분)..."></div>
                               </div>`;
                    break;
                case 'fill-in':
                     content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div><div class="block-title">[] 빈칸 넣기</div>
                               <div class="quiz-title-container-editor">
                                   <strong>제목:</strong>
                                   <div class="editable quiz-title-editor" contenteditable="true" placeholder="퀴즈 전체 제목 (선택 사항)"></div>
                               </div>
                               <div class="fill-in-items-container"></div>
                               <button class="add-fill-in-item">+ 문항 추가</button>`;
                    break;
                case 'table':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                               <div class="block-title">田 <span class="block-title-text" contenteditable="true">표</span></div>
                               <div class="table-editor-container">
                                   <div class="table-title-editor">
                                       <strong>표 제목:</strong>
                                       <div class="editable table-title" contenteditable="true" placeholder="표의 제목을 입력하세요."></div>
                                   </div>
                                   <div class="table-desc-editor">
                                       <strong>설명:</strong>
                                       <div class="editable table-desc" contenteditable="true" placeholder="표에 대한 설명을 입력하세요 (선택 사항)."></div>
                                   </div>
                                   <div class="table-fields-editor">
                                       <strong>필드명 (열):</strong>
                                       <div class="fields-container">
                                           <div class="editable table-field" contenteditable="true"></div>
                                           <div class="editable table-field" contenteditable="true"></div>
                                           <div class="editable table-field" contenteditable="true"></div>
                                           <div class="editable table-field" contenteditable="true"></div>
                                       </div>
                                   </div>
                                   <div class="table-records-container"></div>
                                   <button class="add-table-row-btn">+ 행 추가</button>
                               </div>`;
                    break;
		case 'math':
		    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
		               <div class="block-title-container">
		                   <div class="block-title">➗ 수식</div>
		                   <a href="https://katex.org/docs/supported.html" target="_blank" class="math-guide-link">
		                       ℹ️ 수식 입력 설명서
		                   </a>
		               </div>
		               <div class="math-editor-field" id="math-field-${blockIdCounter}"></div>
		               <input type="hidden" class="latex-output">`;
			    break;
                case 'line-quiz':
                     content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                                <div class="block-title">〰️ 선긋기 퀴즈</div>
                                <div class="quiz-title-container-editor">
                                    <strong>퀴즈 제목:</strong>
                                    <div class="editable quiz-title-editor" contenteditable="true" placeholder="퀴즈 제목을 입력하세요."></div>
                                </div>
                                <div class="line-quiz-items-container"></div>
                                <button class="add-line-quiz-item">+ 항목 추가</button>`;
                    break;
		        case 'youtube':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                            <div class="block-title">🎬 유튜브</div>
                            <div class="youtube-title-editor">
                                <strong>제목:</strong>
                                <input type="text" class="youtube-title-input" placeholder="영상 제목 (선택 사항)">
                            </div>
                            <div class="youtube-title-editor" style="margin-top: 5px;">
                                <strong>URL:</strong>
                                <input type="url" class="youtube-url-input" placeholder="유튜브 동영상 주소(URL)를 여기에 붙여넣으세요...">
                            </div>`;
                    break;
                case 'link':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                               <div class="block-title">🔗 링크</div>
                               <div class="link-editor-container">
                                   <div class="link-editor-row">
                                       <label for="link-title-${blockIdCounter}">링크 제목:</label>
                                       <input type="text" id="link-title-${blockIdCounter}" class="link-title-input" placeholder="예: 네이버 바로가기">
                                   </div>
                                   <div class="link-editor-row">
                                       <label for="link-url-${blockIdCounter}">URL 주소:</label>
                                       <input type="url" id="link-url-${blockIdCounter}" class="link-url-input" placeholder="https://www.naver.com">
                                   </div>
                                   <div class="link-editor-row">
                                       <label>링크 방식:</label>
                                       <div class="link-target-options">
                                           <label><input type="radio" name="link-target-${blockIdCounter}" value="_blank" checked> 새 탭에서 열기</label>
                                           <label><input type="radio" name="link-target-${blockIdCounter}" value="_self"> 현재 탭에서 열기</label>
                                       </div>
                                   </div>
                               </div>`;
                    break;
                case 'frame':
                    content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                               <div class="block-title">🖼️ 프레임</div>
                               <div class="frame-editor-container">
                                   <div class="frame-editor-row"><label>제목:</label><input type="text" class="frame-title-input" placeholder="프레임의 제목을 입력하세요."></div>
                                   <div class="frame-editor-row"><label>URL:</label><input type="url" class="frame-url-input" placeholder="웹사이트 주소 또는 이미지 주소"></div>
                                   <div class="frame-editor-row"><label>출처 URL:</label><input type="url" class="frame-source-input" placeholder="비워두면 위 URL로 자동 입력됩니다."></div>
                                   <div class="frame-editor-row"><label></label><label><input type="checkbox" class="frame-expanded-check"> 처음부터 펼쳐진 상태로 보이기</label></div>
                               </div>`;
                    break;
		case 'summary':
                	content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                           <div class="block-title" style="background-color: #E1F5FE;">📖 핵심 구절 요약</div>
                           <p style="color:#888; text-align:center;">텍스트 블록의 구절풀이가 자동으로 요약되어 표시됨.</p>`;
                break;
        case 'ordering':
            content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                    <div class="block-title">📊 순서 배열 퀴즈</div>
                    <div class="quiz-title-container-editor">
                        <strong>전체 문제 설명:</strong>
                        <div class="editable quiz-title-editor" contenteditable="true" placeholder="예: 아래 문장들을 순서에 맞게 배열하세요."></div>
                    </div>
                    <div class="ordering-items-container"></div>
                    <button class="add-ordering-item">+ 문항 추가</button>
                    <small>💡 각 단어나 구절을 '//'(슬래시 2개)로 구분하여 **정답 순서대로** 입력하세요.</small>`;
            break;
        case 'drag-drop':
            content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                    <div class="block-title">✋ 드래그 앤 드롭</div>
                    <div class="quiz-title-container-editor">
                        <strong>퀴즈 제목:</strong>
                        <div class="editable quiz-title-editor" contenteditable="true" placeholder="퀴즈 전체 제목 (선택 사항)"></div>
                    </div>
                    <div class="drag-drop-items-container"></div>
                    <button class="add-drag-drop-item">+ 문항 추가</button>`;
            break;      
        case 'flowchart':
            content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                       <div class="block-title">➔ <span class="block-title-text" contenteditable="true">순서도</span></div>
                       <div class="flowchart-items-container"></div>
                       <button class="add-flowchart-row">+ 단계 추가</button>`;
            break; 
        case 'classification':
           content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                      <div class="block-title">🗂️ 분류하기 퀴즈</div>
                      <div class="quiz-title-container-editor">
                          <strong>문제 설명:</strong>
                          <div class="editable quiz-title-editor" contenteditable="true" placeholder="예: 항목을 올바른 그룹으로 분류하세요."></div>
                      </div>
                      <div class="classification-editor-container">
                          <strong>카테고리 설정:</strong>
                          <div class="classification-categories-editor"></div>
                          <button class="add-classification-category">+ 카테고리 추가</button>
                          <hr style="margin: 15px 0;">
                          <strong>항목(카드) 설정:</strong>
                          <div class="classification-items-editor"></div>
                          <button class="add-classification-item">+ 항목 추가</button>
                      </div>`;
           break;
        case 'mindmap':
            editorBlock.dataset.layout = 'default'; // ✅ 레이아웃 기본 상태를 'default'로 설정
            content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="change-mindmap-layout" title="레이아웃 변경 (기본형)" style="cursor: pointer;">🎨</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                       <div class="block-title">🔀 <span class="block-title-text" contenteditable="true">마인드맵</span></div>
                       <br><small class="mindmap-shortcut-guide">(Ctrl+Enter) 새 항목, (Tab/Shift+Tab) 수준 변경, (Alt+↑/↓) 순서 변경</small>
                       <div class="mindmap-editor-container">
                           <ul class="mindmap-children-list">
                               <li class="mindmap-editor-item">
                                   <div class="mindmap-node-wrapper">
                                       <div class="mindmap-node">
                                           <span class="editable" contenteditable="true">중심 주제</span>
                                       </div>
                                       <div class="mindmap-node-actions">
                                           <button class="mindmap-add-child" title="하위 항목 추가">+</button>
                                       </div>
                                   </div>
                                   <ul class="mindmap-children-list"></ul>
                               </li>
                           </ul>
                       </div>`;
            break;
        case 'daily-quiz':
            content = `<div class="block-controls"><button class="drag-handle" title="블록 이동" draggable="true">✥</button><button class="copy-block-btn" title="블록 복사">📋</button><button class="delete-block-btn" title="블록 삭제">🗑️</button></div>
                       <div class="block-title" style="background-color: #D8BFD8;">📅 <span class="block-title-text" contenteditable="true">오늘의 퀴즈</span></div>
                       <div class="daily-quiz-editor">
                           <strong>퀴즈 종류 선택:</strong>
                           <select class="daily-quiz-type-select">
                               <option value="proverbs">속담 퀴즈</option>
                               </select>
                       </div>
                       <small>💡 나중에 '명언 퀴즈' 등을 추가하고 싶으면, 'quiz_data_sayings.json' 파일을 만든 뒤, 위 코드에서 주석 처리된 option 태그를 활성화하세요.</small>`;
            break;
        }

            editorBlock.innerHTML = content;
            if (type === 'spacer') {
                editorBlock.style.height = '40px';
            }
            
            let currentBlock = null;
            if (savedRange) {
                let node = savedRange.startContainer;
                currentBlock = (node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement).closest('.block');
            }

            if (currentBlock && currentBlock.parentNode === editor) {
                currentBlock.after(editorBlock);
            } else {
                editor.appendChild(editorBlock);
            }
            isDirty = true;

            if (type === 'ox') addOxItem(editorBlock);
            if (type === 'mcq') {
                addMcqOption(editorBlock);
                const questionInput = editorBlock.querySelector('.quiz-title-container-editor .editable');
                if (questionInput) questionInput.focus();
            }
            if (type === 'fill-in') addFillInItem(editorBlock);
            if (type === 'table') {
                addTableRow(editorBlock);
                const titleInput = editorBlock.querySelector('.table-title');
                if(titleInput) titleInput.focus();
            }
            if (type === 'math') {
                const mathFieldEl = editorBlock.querySelector('.math-editor-field');
                const latexOutput = editorBlock.querySelector('.latex-output');
                const MQ = MathQuill.getInterface(2);
                MQ.MathField(mathFieldEl, {
                    handlers: {
                        edit: () => {
                            latexOutput.value = MQ(mathFieldEl).latex();
                            renderFullPreview();
                            isDirty = true;
                        }
                    }
                });
            }
            if (type === 'line-quiz'){
                addLineQuizItem(editorBlock);
                addLineQuizItem(editorBlock);
                addLineQuizItem(editorBlock);
            }
            if (type === 'drag-drop') {
                addOrderingItem(editorBlock);
                addDragDropItem(editorBlock);
                addDragDropItem(editorBlock);
            }
            if (type === 'classification') {
                const categoryContainer = editorBlock.querySelector('.classification-categories-editor');
                const itemContainer = editorBlock.querySelector('.classification-items-editor');
                // 기본 카테고리 2개 추가
                addClassificationCategory(categoryContainer, '카테고리 A');
                addClassificationCategory(categoryContainer, '카테고리 B');
                // 기본 항목 2개 추가
                addClassificationItem(itemContainer, '항목 1');
                addClassificationItem(itemContainer, '항목 2');
                // 드롭다운 메뉴 업데이트
                updateAllCategoryDropdowns(editorBlock);
            }

            renderFullPreview(); // ✅ 블록 추가 후 즉시 미리보기 전체를 갱신
        }

        function addOxItem(block) {
            const container = block.querySelector('.ox-items-container');
            const newItem = document.createElement('div');
            newItem.className = 'ox-item-editor';
            const itemIndex = container.children.length + 1;
            
            const uniqueId = `${block.dataset.id}-${itemIndex}`;
            newItem.innerHTML = `<strong>Q${itemIndex}.</strong>
                                 <div class="editable" contenteditable="true" placeholder="문제를 입력하세요..."></div>
                                 <div class="ox-answer-selector-editor">
                                    <input type="radio" id="ox-O-${uniqueId}" name="ox-answer-${uniqueId}" value="O" checked style="display:none;">
                                    <label for="ox-O-${uniqueId}" class="ox-choice-btn-editor">O</label>
                                    <input type="radio" id="ox-X-${uniqueId}" name="ox-answer-${uniqueId}" value="X" style="display:none;">
                                    <label for="ox-X-${uniqueId}" class="ox-choice-btn-editor">X</label>
                                    <button class="delete-ox-item" title="문항 삭제">&times;</button>
                                 </div>`;
            container.appendChild(newItem);
        }

        function renumberOxItems(container) {
            const items = container.querySelectorAll('.ox-item-editor');
            items.forEach((item, index) => {
                const numberEl = item.querySelector('strong');
                if (numberEl) {
                    numberEl.textContent = `Q${index + 1}.`;
                }
            });
        }

        function addMcqOption(block) {
            const container = block.querySelector('.mcq-options-container');
            const newOption = document.createElement('div');
            newOption.className = 'mcq-option-editor';
            newOption.innerHTML = `<span>${container.children.length + 1}. </span><div class="editable" contenteditable="true"></div>`;
            container.appendChild(newOption);

            const newEditable = newOption.querySelector('.editable');
            if(newEditable) newEditable.focus();
        }

        function addFillInItem(block) {
            const container = block.querySelector('.fill-in-items-container');
            const itemIndex = container.children.length + 1;
            const newItem = document.createElement('div');
            newItem.className = 'fill-in-item-editor';
            // ✅ 정답 입력칸(fill-in-answers-container)과 플레이스홀더를 제거합니다.
            newItem.innerHTML = `
                <div class="fill-in-question-container">
                    <strong>${itemIndex}.</strong>
                    <div class="editable fill-in-question" contenteditable="true"></div>
                    <button class="delete-fill-in-item" title="문항 삭제">&times;</button>
                </div>`;
            container.appendChild(newItem);
            
            const newEditable = newItem.querySelector('.editable');
            if(newEditable) newEditable.focus();
        }

        function renumberFillInItems(container) {
            const items = container.querySelectorAll('.fill-in-item-editor');
            items.forEach((item, index) => {
                const numberEl = item.querySelector('strong');
                if (numberEl) {
                    numberEl.textContent = `${index + 1}.`;
                }
            });
        }

        function addTableRow(block) {
            const recordsContainer = block.querySelector('.table-records-container');
            const newRowWrapper = document.createElement('div');
            newRowWrapper.className = 'table-record-row-wrapper';
            
            const numColumns = Math.max(1, Array.from(block.querySelectorAll('.table-field')).filter(f => f.textContent.trim() !== '').length);
            
            let cellsHTML = '';
            for(let i=0; i < numColumns; i++) {
                cellsHTML += `<div class="editable table-record-cell" contenteditable="true"></div>`;
            }

            // ✅ 정답 입력칸(table-row-answers)을 제거합니다.
            newRowWrapper.innerHTML = `<div class="table-record-row">${cellsHTML}</div>`;
            recordsContainer.appendChild(newRowWrapper);
        }

        function addLineQuizItem(block) {
            const container = block.querySelector('.line-quiz-items-container');
            const itemIndex = container.children.length + 1;
            const newItem = document.createElement('div');
            newItem.className = 'line-quiz-item-editor';
            newItem.innerHTML = `
                <strong>${itemIndex}.</strong>
                <div class="editable line-quiz-left" contenteditable="true"></div>
                <span class="dot-separator">● ↔ ●</span>
                <div class="editable line-quiz-right" contenteditable="true"></div>
                <button class="delete-line-quiz-item" title="항목 삭제">&times;</button>`;
            container.appendChild(newItem);
        }

        function renumberLineQuizItems(container) {
            const items = container.querySelectorAll('.line-quiz-item-editor');
            items.forEach((item, index) => {
                const numberEl = item.querySelector('strong');
                if (numberEl) {
                    numberEl.textContent = `${index + 1}.`;
                }
            });
        }

        function addFlowchartRow(block, layout = 'one') {
            const container = block.querySelector('.flowchart-items-container');
            const isFirstRow = container.children.length === 0;
            const newRow = document.createElement('div');
            newRow.className = 'flowchart-editor-row';
            newRow.dataset.layout = layout;
            newRow.draggable = true;

            let nodesHtml = '';
            if (layout === 'one') { nodesHtml = '<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>'; }
            else if (layout === 'two') { nodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }
            else if (layout === 'connected') { nodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-connector-editor"><div class="editable" contenteditable="true">→</div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }
            else if (layout === 'three') { nodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }
            else if (layout === 'connected-three') { nodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-connector-editor"><div class="editable" contenteditable="true">→</div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-connector-editor"><div class="editable" contenteditable="true">→</div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }

            const arrowToggleHtml = isFirstRow ? '' : `<label class="flowchart-toggle-label" style="margin-left: 15px;"><input type="checkbox" class="flowchart-arrow-toggle" checked> 윗 화살표 표시</label>`;
            const narrowToggleDisplay = (layout !== 'one') ? 'inline-block' : 'none';

            newRow.innerHTML = `
                <button class="delete-flowchart-row-btn" title="단계 삭제">❌</button>
                <div class="flowchart-row-controls">
                    <span class="drag-handle" title="순서 이동" draggable="true">✥</span>
                    <strong>레이아웃:</strong>
                    <button class="change-flowchart-layout" data-layout="one">1칸</button>
                    <button class="change-flowchart-layout" data-layout="two">2칸</button>
                    <button class="change-flowchart-layout" data-layout="three">3칸</button>
                    <button class="change-flowchart-layout" data-layout="connected">연결형 2칸</button>
                    <button class="change-flowchart-layout" data-layout="connected-three">연결형 3칸</button>
                    <label class="flowchart-first-col-narrow-toggle flowchart-toggle-label" style="margin-left: auto; display: ${narrowToggleDisplay};"><input type="checkbox" class="flowchart-first-col-narrow-checkbox"> 첫 칸 좁게</label>
                    ${arrowToggleHtml}
                </div>
                <div class="flowchart-nodes-container">${nodesHtml}</div>`;
            container.appendChild(newRow);
        }

        function changeFlowchartLayout(rowElement, newLayout) {
            // 1. 기존 노드의 내용을 배열에 저장합니다.
            const oldNodes = rowElement.querySelectorAll('.flowchart-node-editor .editable');
            const oldContents = Array.from(oldNodes).map(node => node.innerHTML);
        
            const container = rowElement.querySelector('.flowchart-nodes-container');
            rowElement.dataset.layout = newLayout;
            
            const narrowToggle = rowElement.querySelector('.flowchart-first-col-narrow-toggle');
            if(narrowToggle) {
                narrowToggle.style.display = (newLayout !== 'one') ? 'inline-block' : 'none';
            }
        
            // 2. 새로운 레이아웃의 HTML 구조를 만듭니다.
            const tempContainer = document.createElement('div');
            let newNodesHtml = '';
            if (newLayout === 'one') { newNodesHtml = '<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>'; }
            else if (newLayout === 'two') { newNodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }
            else if (newLayout === 'connected') { newNodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-connector-editor"><div class="editable" contenteditable="true">→</div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }
            else if (newLayout === 'three') { newNodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`; }
            else if (newLayout === 'connected-three') { newNodesHtml = `<div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-connector-editor"><div class="editable" contenteditable="true">→</div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div><div class="flowchart-connector-editor"><div class="editable" contenteditable="true">→</div></div><div class="flowchart-node-editor"><div class="editable" contenteditable="true"></div></div>`;}
            tempContainer.innerHTML = newNodesHtml;

            // 3. 저장해둔 내용을 새로운 노드에 순서대로 채워 넣습니다.
            const newNodes = tempContainer.querySelectorAll('.flowchart-node-editor .editable');
            newNodes.forEach((newNode, index) => {
                if (oldContents[index]) {
                    newNode.innerHTML = oldContents[index];
                }
            });

            // 4. 내용이 채워진 새로운 구조로 교체합니다.
            container.innerHTML = tempContainer.innerHTML;
            renderFullPreview();
            isDirty = true;
        }
        
        function deleteFlowchartRow(rowElement) {
            if (confirm('이 단계를 정말 삭제하시겠습니까?')) {
                rowElement.remove();
                renderFullPreview();
                isDirty = true;
            }
        }

        function addDragDropItem(block) {
            const container = block.querySelector('.drag-drop-items-container');
            const itemIndex = container.children.length + 1;
            const newItem = document.createElement('div');
            newItem.className = 'drag-drop-item-editor';
            newItem.innerHTML = `
                <strong>${itemIndex}.</strong>
                <div class="editable drag-drop-part1" contenteditable="true" placeholder="문장 앞부분"></div>
                <div class="editable drag-drop-answer" contenteditable="true" placeholder="정답"></div>
                <div class="editable drag-drop-part2" contenteditable="true" placeholder="문장 뒷부분"></div>
                <button class="delete-drag-drop-item" title="문항 삭제">&times;</button>`;
            container.appendChild(newItem);
        }

        function renumberDragDropItems(container) {
            const items = container.querySelectorAll('.drag-drop-item-editor');
            items.forEach((item, index) => {
                const numberEl = item.querySelector('strong');
                if (numberEl) {
                    numberEl.textContent = `${index + 1}.`;
                }
            });
        }

        function addOrderingItem(block) {
            const container = block.querySelector('.ordering-items-container');
            const itemIndex = container.children.length + 1;
            const newItem = document.createElement('div');
            newItem.className = 'ordering-item-editor';
            newItem.innerHTML = `
                <strong>${itemIndex}.</strong>
                <div class="editable ordering-answer-input" contenteditable="true" placeholder="정답 순서대로 //로 구분하여 입력"></div>
                <button class="delete-ordering-item" title="문항 삭제">&times;</button>`;
            container.appendChild(newItem);
        }

        function renumberOrderingItems(container) {
            const items = container.querySelectorAll('.ordering-item-editor');
            items.forEach((item, index) => {
                const numberEl = item.querySelector('strong');
                if (numberEl) numberEl.textContent = `${index + 1}.`;
            });
        }

        function renderFullPreview() {
            if (!activeTabId) {
                preview.innerHTML = "";
                return;
            }
            
            const tempEditor = document.createElement('div');
            syncInputAttributes(editor);
            tempEditor.innerHTML = editor.innerHTML;

            preview.innerHTML = '';
            
            tempEditor.querySelectorAll('.block').forEach(editorBlock => {
                const previewBlock = document.createElement('div');
                preview.appendChild(previewBlock);
                updatePreviewBlock(editorBlock, previewBlock);
            });
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([preview]);
            }
            initializeAllInteractiveBlocks();
            adjustBlankInputWidths(preview);

            // --- [추가] 마인드맵 높이 자동 조절 ---
            preview.querySelectorAll('.mindmap-preview.layout-orgchart').forEach(mindmapContainer => {
                // 높이를 초기화하여 다시 계산하도록 함
                mindmapContainer.style.height = 'auto';

                let maxHeight = 0;
                // 모든 자식 요소들의 위치와 크기를 파악하여 가장 아래쪽 좌표를 찾음
                const containerTop = mindmapContainer.getBoundingClientRect().top;
                mindmapContainer.querySelectorAll('.orgchart-node').forEach(el => {
                    const rect = el.getBoundingClientRect();
                    const bottom = rect.bottom - containerTop;
                    if (bottom > maxHeight) {
                        maxHeight = bottom;
                    }
                });
                // 컨테이너 높이를 가장 아래쪽 요소에 맞게 설정 (여유 공간 추가)
                mindmapContainer.style.height = (maxHeight + 20) + 'px';
            });
        }

        function updatePreviewBlock(editorBlock, previewBlock) {
            const type = editorBlock.dataset.type;
            let content = '';
            let blockTitleHtml = `<div class="block-title">${editorBlock.querySelector(".block-title").innerHTML}</div>`;

            previewBlock.className = editorBlock.className;
            previewBlock.dataset.type = type;

            if (type === 'text') {
                const customTitleEl = editorBlock.querySelector('.block-title-text');
                const customTitle = customTitleEl ? customTitleEl.textContent.trim() : '일반 텍스트';

                const renderResult = parseAndRenderText(editorBlock.querySelector('.editable').innerHTML);
                const textBody = renderResult.html;
                const hasCheckButtonBlanks = renderResult.hasCheckButtonBlanks; // ✅ 올바른 변수명으로 수정

                const toggleState = editorBlock.querySelector('.toggle-state-input')?.value || 'open';
                const openAttribute = (toggleState === 'open') ? 'open' : '';

                const dataAttempts = hasCheckButtonBlanks ? 'data-attempts="0"' : ''; // ✅ 올바른 변수명으로 수정

                if (customTitle === '') {
                    blockTitleHtml = ``;
                    content = `<div class="text-content-container" ${dataAttempts}>
                                    <div class="text-content">${textBody}</div>
                                </div>`;
                    previewBlock.classList.add('no-title-block');
                } else {
                    blockTitleHtml = '';
                    previewBlock.classList.remove('no-title-block');
                    content = `<details class="text-preview-container" ${openAttribute} ${dataAttempts}>
                                    <summary class="text-preview-summary">
                                        <span class="text-preview-title-pill">📝 ${customTitle}</span>
                                        <span class="text-preview-toggle-icon">▼</span>
                                    </summary>
                                    <div class="text-preview-content-wrapper">
                                        <div class="text-preview-content">${textBody}</div>
                                    </div>
                                </details>`;
                }

                if (hasCheckButtonBlanks) { // ✅ 올바른 변수명으로 수정
                    const quizControls = `
                        <div class="quiz-controls" style="text-align: right; margin-top: 10px; padding: 0 15px 15px;">
                            <span class="feedback"></span>
                            <button class="check-fill-in-btn">정답 확인</button>
                            <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                        </div>`;

                    const tempWrapper = document.createElement('div');
                    tempWrapper.innerHTML = content;
                    const containerElement = tempWrapper.firstChild;
                    if (customTitle === '') {
                        containerElement.innerHTML += quizControls;
                    } else {
                        containerElement.querySelector('.text-preview-content-wrapper').insertAdjacentHTML('afterend', quizControls);
                    }
                    content = tempWrapper.innerHTML;
                }
            } else if (type === 'ox') {
                const quizTitle = editorBlock.querySelector('.quiz-title-editor')?.innerHTML || '';
                let itemsContent = '';
                editorBlock.querySelectorAll('.ox-item-editor').forEach((item, index) => {
                    const question = item.querySelector('.editable').innerHTML;
                    const answer = item.querySelector('input[type="radio"]:checked')?.value || 'O';
                    itemsContent += `<div class="ox-preview-item">
                                        <div class="ox-question-row">
                                        <div class="question-text"><strong>Q${index + 1}.</strong> ${question}</div>
                                        <div class="ox-choices" data-answer="${answer}"><button data-choice="O">O</button><button data-choice="X">X</button></div>
                                        </div>
                                        <div class="feedback"></div>
                                    </div>`;
                });
                content = `<div class="quiz-container"><div class="quiz-title-preview">${quizTitle}</div>${itemsContent}<div class="quiz-controls"><button class="retry-quiz-btn">다시 풀기</button></div></div>`;
            } else if (type === 'mcq') {
                const question = editorBlock.querySelector('.mcq-question-editor').innerHTML;
                const passage = editorBlock.querySelector('.mcq-passage-editor').innerHTML;
                const explanation = editorBlock.querySelector('.mcq-explanation-editor').innerHTML;
                const answer = editorBlock.querySelector('.mcq-answer').getAttribute('value') || '1';
                const numberChars = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩'];

                if (!question.trim() && !passage.trim()) {
                    blockTitleHtml = '';
                    previewBlock.classList.add('no-title-block');
                }

                content = `<div class="mcq-preview-item" data-attempts="0" data-answer="${answer}" data-explanation="${btoa(encodeURIComponent(explanation))}">`;
                
                if (passage.trim()) {
                    const parsedPassage = parseAndRenderText(passage);
                    content += `<div class="mcq-passage-preview">${parsedPassage.html}</div>`;
                }

                if(question.trim()) {
                    content += `<p><strong>Q.</strong> ${question}</p>`;
                }
                content += `<div class="mcq-options-preview">`;
                editorBlock.querySelectorAll('.mcq-options-container .editable').forEach((opt, index) => {
                    if (opt.innerHTML.trim()) {
                       content += `<div class="mcq-preview-option" data-choice="${index + 1}">${numberChars[index] || (index+1)+'.'} ${opt.innerHTML}</div>`;
                    }
                });
                content += `</div>
                            <div class="quiz-controls">
                                <span class="feedback"></span>
                                <button class="retry-quiz-btn">다시 풀기</button>
                            </div>
                            <div class="explanation"></div>
                            </div>`;
            } else if (type === 'descriptive') {
                const question = editorBlock.querySelectorAll('.editable')[0].innerHTML;
                const answers = editorBlock.querySelectorAll('.editable')[1].textContent.split(',').map(ans => ans.trim()).filter(Boolean);
                const answersData = btoa(encodeURIComponent(JSON.stringify(answers)));
                content = `<div class="descriptive-preview-item" data-answers="${answersData}">
                            <div style="margin-bottom: 10px;"><strong>Q.</strong> ${question}</div>
                            <textarea class="descriptive-student-answer" placeholder="답을 입력하세요..."></textarea>
                            <div class="quiz-controls">
                                <span class="feedback"></span>
                                <button class="check-answer-btn">정답 확인</button>
                                <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                            </div>
                        </div>`;
            } else if (type === 'fill-in') {
                const quizTitle = editorBlock.querySelector('.quiz-title-editor')?.innerHTML || '';
                let itemsContent = '';
                let hasBlanksInBlock = false; 

                editorBlock.querySelectorAll('.fill-in-item-editor').forEach((item, index) => {
                    const questionDiv = item.querySelector('.fill-in-question');
                    if (questionDiv.textContent.trim() === '') return;

                    const renderResult = parseAndRenderText(questionDiv.innerHTML);
                    if (renderResult.hasCheckButtonBlanks) {
                        hasBlanksInBlock = true;
                    }
                    
                    itemsContent += `<div class="fill-in-preview-item">
                                    <strong>${index + 1}.</strong> ${renderResult.html}
                                </div>`;
                });

                if (itemsContent.trim() === '') {
                    previewBlock.remove();
                    return;
                }

                content = `<div class="fill-in-container" data-attempts="0"><div class="quiz-title-preview">${quizTitle}</div>${itemsContent}`;
                
                if (hasBlanksInBlock) {
                    content += `
                        <div class="quiz-controls">
                            <span class="feedback"></span>
                            <button class="check-fill-in-btn">정답 확인</button>
                            <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                        </div>`;
                }
                content += `</div>`;
            } else if (type === 'table') {
                const customTitleEl = editorBlock.querySelector('.block-title-text');
                const customTitle = customTitleEl ? customTitleEl.textContent.trim() : '표 삽입';

                if (customTitle === '') {
                    blockTitleHtml = ``;
                    previewBlock.classList.add('no-title-block');
                } else {
                    blockTitleHtml = `<div class="block-title">田 ${customTitle}</div>`;
                    previewBlock.classList.remove('no-title-block');
                }

                const title = editorBlock.querySelector('.table-title').innerHTML;
                const description = editorBlock.querySelector('.table-desc').innerHTML;
                const activeHeaderElements = Array.from(editorBlock.querySelectorAll('.table-field')).filter(f => f.textContent.trim() !== '');
                const headers = activeHeaderElements.map(f => f.innerHTML);
                const numColumns = headers.length;

                let hasBlanks = false;

                let tableHTML = `<div class="table-preview-container" data-attempts="0">`;
                if (editorBlock.querySelector('.table-title').textContent.trim()) {
                    tableHTML += `<h3>${title}</h3>`;
                }
                if (editorBlock.querySelector('.table-desc').textContent.trim()) {
                    tableHTML += `<p>${description}</p>`;
                }
                tableHTML += `<table>`;

                if (headers.length > 0) {
                    tableHTML += `<thead><tr>`;
                    headers.forEach(header => {
                        tableHTML += `<th>${header || '&nbsp;'}</th>`;
                    });
                    tableHTML += `</tr></thead>`;
                }

                tableHTML += `<tbody>`;
                editorBlock.querySelectorAll('.table-record-row-wrapper').forEach(rowWrapper => {
                    tableHTML += `<tr>`;
                    const cells = rowWrapper.querySelectorAll('.table-record-cell');

                    for (let i = 0; i < numColumns; i++) {
                        const cellContent = cells[i] ? cells[i].innerHTML : '';
                        
                        const renderResult = parseAndRenderText(cellContent);
                        if (renderResult.hasCheckButtonBlanks) {
                            hasBlanks = true;
                        }
                        tableHTML += `<td>${renderResult.html}</td>`;
                    }
                    tableHTML += `</tr>`;
                });
                tableHTML += `</tbody>`;

                tableHTML += `</table>`;

                if (hasBlanks) {
                    tableHTML += `
                        <div class="quiz-controls">
                            <span class="feedback"></span>
                            <button class="check-fill-in-btn">정답 확인</button>
                            <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                        </div>`;
                }
                tableHTML += `</div>`;
                content = tableHTML;
            } else if (type === 'math') {
                const latex = editorBlock.querySelector('.latex-output').getAttribute('value') || '';
                content = `<div class="math-preview-field">$$${latex}$$</div>`;
            } else if (type === 'line-quiz') {
                const quizTitle = editorBlock.querySelector('.quiz-title-editor').innerHTML;
                const pairs = Array.from(editorBlock.querySelectorAll('.line-quiz-item-editor')).map(row => ({
                    left: row.querySelector('.line-quiz-left').innerHTML,
                    right: row.querySelector('.line-quiz-right').innerHTML
                })).filter(p => p.left.trim() && p.right.trim());

                if (pairs.length > 0) {
                    let leftHTML = '';
                    let rightHTML = '';

                    const indexedPairs = pairs.map((pair, index) => ({...pair, id: index}));
                    const shuffledPairs = shuffle([...indexedPairs]);

                    indexedPairs.forEach(pair => {
                        leftHTML += `<div class="line-quiz-item" data-id="${pair.id}"><span class="text">${pair.left}</span><span class="dot" data-id="${pair.id}"></span></div>`;
                    });

                    shuffledPairs.forEach(pair => {
                        rightHTML += `<div class="line-quiz-item" data-id="${pair.id}"><span class="dot" data-id="${pair.id}"></span><span class="text">${pair.right}</span></div>`;
                    });

                    content = `<div class="quiz-container">
                                <div class="quiz-title-preview">${quizTitle}</div>
                                <div class="line-quiz-preview">
                                    <div class="line-quiz-column">${leftHTML}</div>
                                    <canvas class="line-quiz-canvas"></canvas>
                                    <div class="line-quiz-column">${rightHTML}</div>
                                </div>
                                <div class="quiz-controls">
                                    <button class="check-line-quiz-btn">정답 확인</button>
                                    <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                                </div>
                            </div>`;
                } else {
                    content = '<p style="color:#888">항목을 입력해주세요.</p>';
                }
            } else if (type === 'youtube') {
                const titleInput = editorBlock.querySelector('.youtube-title-input');
                const userTitle = titleInput ? titleInput.getAttribute('value') || '' : '';

                if (userTitle.trim() === '') {
                    blockTitleHtml = `<div class="block-title">🎬 <b>유튜브</b></div>`;
                } else {
                    blockTitleHtml = `<div class="block-title youtube-preview-title">
                                        <span class="pill">🎬 </span>
                                        <span>${userTitle}</span>
                                    </div>`;
                }

                const url = editorBlock.querySelector('.youtube-url-input').getAttribute('value') || '';
                const videoId = parseYoutubeUrl(url);
                if (videoId) {
                    content = `<div class="youtube-placeholder" data-video-id="${videoId}">
                                🎬
                                <div class="youtube-placeholder-text">클릭하여 영상 보기</div>
                            </div>`;
                } else {
                    content = `<p style="color:#888; text-align:center;">유튜브 주소를 입력하면 동영상이 여기에 표시됩니다.</p>`;
                }
            } else if (type === 'link') {
                blockTitleHtml = '';
                previewBlock.classList.add('no-title-block');

                const title = editorBlock.querySelector('.link-title-input').getAttribute('value') || '제목 없음';
                let url = editorBlock.querySelector('.link-url-input').getAttribute('value') || '';
                const targetRadio = editorBlock.querySelector('input[name^="link-target"]:checked');
                const target = targetRadio ? targetRadio.value : '_blank';

                if (url && !/^https?:\/\//i.test(url)) {
                    url = 'https://' + url;
                }

                if (!url) {
                    content = '<p style="color:#888;">URL 주소를 입력하면 링크가 여기에 표시됩니다.</p>';
                } else {
                    content = `<a href="${url}" target="${target}" class="preview-link-wrapper">
                                <span class="preview-link-label">(🔗 링크 )</span>
                                <span class="preview-link-title">${title}</span>
                            </a>`;
                }
            } else if (type === 'frame') {
                    blockTitleHtml = ''; 
                    previewBlock.classList.add('no-title-block');

                    const title = editorBlock.querySelector('.frame-title-input').getAttribute('value') || '프레임 콘텐츠';
                    const url = editorBlock.querySelector('.frame-url-input').getAttribute('value') || '';
                    let sourceUrl = editorBlock.querySelector('.frame-source-input').getAttribute('value') || '';
                    const isExpanded = editorBlock.querySelector('.frame-expanded-check').checked;

                    if (!sourceUrl) sourceUrl = url;

                    if (!url) {
                        content = '<p style="color:#888; text-align:center;">프레임에 표시할 URL을 입력해주세요.</p>';
                    } else {
                        const isOpen = isExpanded ? 'open' : '';
                        let frameContent = '';
                        if (/\.(jpg|jpeg|png|gif|svg|webp)(\?.*)?$/i.test(url)) {
                            frameContent = `<img src="${url}" alt="${title}">`;
                        } else {
                            frameContent = `<iframe src="${url}" title="${title}" loading="lazy"></iframe>`;
                        }

                        content = `<details class="frame-preview-container" ${isOpen}>
                                    <summary class="frame-preview-summary">
                                        <span class="frame-preview-title-pill">🖼️ ${title}</span>
                                        <span class="frame-preview-toggle-icon">▼</span>
                                    </summary>
                                    <div class="frame-preview-content">
                                        ${frameContent}
                                        ${sourceUrl ? `<a href="${sourceUrl}" target="_blank" class="frame-source-link">출처 방문하기</a>` : ''}
                                    </div>
                                </details>`;
                    }

            } else if (type === 'ordering') {
                const quizTitle = editorBlock.querySelector('.quiz-title-editor').innerHTML;
                let itemsContent = '';
                const items = editorBlock.querySelectorAll('.ordering-item-editor');

                items.forEach((item, index) => {
                    const answerInput = item.querySelector('.ordering-answer-input').textContent.trim();
                    const correctItems = answerInput.split('//').map(item => item.trim()).filter(Boolean);

                    if (correctItems.length > 0) {
                        const correctAnswerString = correctItems.join(' // ');
                        const shuffledItems = shuffle([...correctItems]);
                        let choicesHTML = '';
                        shuffledItems.forEach(itemText => {
                            choicesHTML += `<span class="ordering-item" draggable="true">${itemText}</span>`;
                        });

                        itemsContent += `
                            <div class="ordering-preview-item" data-answer="${btoa(encodeURIComponent(correctAnswerString))}">
                                <div class="ordering-item-title">
                                    <span>Q${index + 1}.</span>
                                    <span class="ordering-item-feedback"></span>
                                </div>
                                <div class="ordering-target-container"></div>
                                <div class="ordering-source-container">${choicesHTML}</div>
                            </div>`;
                    }
                });

                if (itemsContent) {
                    content = `<div class="ordering-preview-container">
                                    <div class="quiz-title-preview">${quizTitle}</div>
                                    ${itemsContent}
                                    <div class="quiz-controls">
                                        <span class="feedback"></span>
                                        <button class="check-ordering-btn">정답 확인</button>
                                        <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                                    </div>
                               </div>`;
                } else {
                    content = '<p style="color:#888">문항을 추가하고, 정답 순서대로 단어를 입력해주세요.</p>';
                }
            } else if (type === 'drag-drop') {
                const quizTitle = editorBlock.querySelector('.quiz-title-editor').innerHTML;
                let sentencesHTML = '';
                const answers = [];

                editorBlock.querySelectorAll('.drag-drop-item-editor').forEach((item, index) => {
                    const part1 = item.querySelector('.drag-drop-part1').innerHTML;
                    const answer = item.querySelector('.drag-drop-answer').textContent.trim();
                    const part2 = item.querySelector('.drag-drop-part2').innerHTML;
                    
                    if (answer) {
                        sentencesHTML += `<div class="sentence">
                                            <strong>${index + 1}.</strong> 
                                            ${part1} 
                                            <span class="drop-target" data-answer="${answer}"></span> 
                                            ${part2}
                                        </div>`;
                        answers.push(answer);
                    }
                });

                if (answers.length > 0) {
                    let choicesHTML = '';
                    shuffle(answers).forEach(ans => {
                        choicesHTML += `<span class="drag-source" draggable="true">${ans}</span>`;
                    });

                    content = `<div class="drag-drop-preview-container">
                                <div class="quiz-title-preview">${quizTitle}</div>
                                <div class="sentences-container">${sentencesHTML}</div>
                                <p><strong>선택지</strong></p>
                                <div class="source-container">${choicesHTML}</div>
                                <div class="quiz-controls">
                                    <span class="feedback"></span>
                                    <button class="check-drag-drop-btn">정답 확인</button>
                                    <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                                </div>
                            </div>`;
                } else {
                    content = '<p style="color:#888">문항을 추가하고 정답을 입력해주세요.</p>';
                }

            } else if (type === 'summary') {
                blockTitleHtml = '';
                previewBlock.classList.add('no-title-block');

                const phrases = [];

                let currentBlock = editorBlock.previousElementSibling;
                while (currentBlock) {
                    if (currentBlock.dataset.type === 'summary') {
                        break;
                    }

                    if (currentBlock.dataset.type === 'text') {
                        const newPhrases = [];
                        currentBlock.querySelectorAll('.explainable-in-editor').forEach(span => {
                            const text = span.textContent;
                            const explanation = span.dataset.explanation;
                            if (explanation && explanation.trim() !== '') {
                                newPhrases.push({ key: text, explanation: explanation });
                            }
                        });
                        phrases.unshift(...newPhrases);
                    }
                    currentBlock = currentBlock.previousElementSibling;
                }

                let summaryContentHtml = '';
                if (phrases.length > 0) {
                    let listHtml = '<ul>';
                    phrases.forEach(phrase => {
                        listHtml += `<li><strong>▪️${phrase.key}</strong> : ${phrase.explanation}</li>`;
                    });
                    listHtml += '</ul>';
                    summaryContentHtml = listHtml;
                } else {
                    summaryContentHtml = '<p style="color:#888; text-align:center;">요약할 구절풀이를 포함한 텍스트 블록이 위에 없습니다.</p>';
                }

                content = `<details class="summary-preview-container">
                            <summary class="summary-preview-summary">
                                <span class="summary-preview-title-pill">📖 핵심 구절 요약</span>
                                <span class="summary-preview-toggle-icon">▼</span>
                            </summary>
                            <div class="summary-preview-content">
                                ${summaryContentHtml}
                            </div>
                        </details>`;
            } else if (type === 'flowchart') {
            const customTitleEl = editorBlock.querySelector('.block-title-text');
            const customTitle = customTitleEl ? customTitleEl.textContent.trim() : '순서도';
            blockTitleHtml = `<div class="block-title">➔ ${customTitle}</div>`;
            let hasInteractiveElements = false;
            let flowchartContent = '';
            const rows = editorBlock.querySelectorAll('.flowchart-editor-row');

            rows.forEach((row, index) => {
                if (index > 0) {
                    const arrowToggle = row.querySelector('.flowchart-arrow-toggle');
                    const showArrow = arrowToggle ? arrowToggle.checked : true;
                    if (showArrow) {
                        flowchartContent += '<div class="flowchart-preview-arrow">↓</div>';
                    }
                }

                const layout = row.dataset.layout || 'one';
                const isNarrow = row.querySelector('.flowchart-first-col-narrow-checkbox')?.checked;
                const narrowClass = (layout !== 'one' && isNarrow) ? ' first-col-narrow' : '';

                flowchartContent += `<div class="flowchart-preview-row layout-${layout}${narrowClass}">`;

                const nodes = row.querySelectorAll('.flowchart-node-editor .editable');
                const connectors = row.querySelectorAll('.flowchart-connector-editor .editable');

                const renderNode = (node) => {
                    if (!node) return '<div class="flowchart-preview-node"></div>';
                    const renderResult = parseAndRenderText(node.innerHTML);
                    if (renderResult.hasCheckButtonBlanks) hasInteractiveElements = true;
                    return `<div class="flowchart-preview-node">${renderResult.html}</div>`;
                };

                if (layout === 'one') { flowchartContent += renderNode(nodes[0]); }
                else if (layout === 'two') { flowchartContent += renderNode(nodes[0]); flowchartContent += renderNode(nodes[1]); }
                else if (layout === 'connected') {
                    const connectorContent = connectors[0] ? connectors[0].innerHTML : '';
                    flowchartContent += renderNode(nodes[0]);
                    flowchartContent += `<div class="flowchart-preview-connector">${connectorContent}</div>`;
                    flowchartContent += renderNode(nodes[1]);
                } else if (layout === 'three') { flowchartContent += renderNode(nodes[0]); flowchartContent += renderNode(nodes[1]); flowchartContent += renderNode(nodes[2]); }
                else if (layout === 'connected-three') {
                    const connector1Content = connectors[0] ? connectors[0].innerHTML : '';
                    const connector2Content = connectors[1] ? connectors[1].innerHTML : '';
                    flowchartContent += renderNode(nodes[0]);
                    flowchartContent += `<div class="flowchart-preview-connector">${connector1Content}</div>`;
                    flowchartContent += renderNode(nodes[1]);
                    flowchartContent += `<div class="flowchart-preview-connector">${connector2Content}</div>`;
                    flowchartContent += renderNode(nodes[2]);
                }
                flowchartContent += '</div>';
            });

            content = `<div class="flowchart-preview-container">${flowchartContent}</div>`;
            if (hasInteractiveElements) {
                previewBlock.dataset.attempts = "0"; 
                content += `<div class="quiz-controls" style="text-align: right; margin-top: 10px; padding: 0 15px 15px;"><span class="feedback"></span><button class="check-fill-in-btn">정답 확인</button><button class="retry-quiz-btn" style="display:none;">다시 풀기</button></div>`;
            }
        } else if (type === 'classification') {
            const quizTitle = editorBlock.querySelector('.quiz-title-editor').innerHTML;

            const categoryNodes = editorBlock.querySelectorAll('.classification-category-editor-row input');
            const categories = Array.from(categoryNodes).map(input => input.value.trim()).filter(Boolean);

            const itemNodes = editorBlock.querySelectorAll('.classification-item-editor-row');
            let items = Array.from(itemNodes).map(row => ({
                text: row.querySelector('.item-text-input').value.trim(),
                correctCategory: row.querySelector('.item-category-select').value
            })).filter(item => item.text);

            if (items.length > 0 && categories.length > 0) {
                const shuffledItems = shuffle([...items]);

                let categoriesHTML = '';
                categories.forEach(catName => {
                    categoriesHTML += `
                        <div class="classification-category-bin">
                            <div class="category-title">${catName}</div>
                            <div class="category-drop-zone" data-category-name="${catName}"></div>
                        </div>`;
                });

                let itemsHTML = '';
                shuffledItems.forEach(item => {
                    itemsHTML += `<span class="classification-item-card" draggable="true" data-correct-category="${item.correctCategory}">${item.text}</span>`;
                });

                content = `<div class="classification-preview-container">
                                <div class="quiz-title-preview">${quizTitle}</div>
                                <p style="margin: 5px 0 10px;"><strong>카테고리</strong></p>
                                <div class="classification-categories-preview">${categoriesHTML}</div>
                                <p style="margin: 15px 0 10px;"><strong>항목 카드</strong></p>
                                <div class="classification-items-source">${itemsHTML}</div>
                                <div class="quiz-controls">
                                    <span class="feedback"></span>
                                    <button class="check-classification-btn">정답 확인</button>
                                    <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                                </div>
                        </div>`;
            } else {
                content = '<p style="color:#888; text-align:center;">카테고리와 항목을 모두 입력해주세요.</p>';
            }
        } else if (type === 'mindmap') {
            const customTitle = editorBlock.querySelector('.block-title-text').textContent.trim() || '마인드맵';
            blockTitleHtml = `<div class="block-title">🔀 ${customTitle}</div>`;
            const layout = editorBlock.dataset.layout || 'default';

            const buildPreviewList = (ulElement, isRoot = false) => {
                if (!ulElement) return '';
                const liElements = Array.from(ulElement.children).filter(node => node.classList.contains('mindmap-editor-item'));
                if (liElements.length === 0) return '';
                
                if (layout === 'orgchart') {
                    const listTag = isRoot ? 'div' : 'ul';
                    let html = `<${listTag} class="orgchart-list">`;
                    liElements.forEach(li => {
                        const nodeText = li.querySelector('.mindmap-node .editable')?.innerHTML.trim() || '';
                        const childrenUl = li.querySelector('.mindmap-children-list');
                        const hasChildren = childrenUl && childrenUl.children.length > 0;
                        if (nodeText) {
                            html += `<li class="orgchart-item">
                                        <div class="orgchart-node-container">
                                            <span class="orgchart-node">${nodeText}</span>
                                        </div>
                                        ${hasChildren ? buildPreviewList(childrenUl, false) : ''}
                                     </li>`;
                        }
                    });
                    html += `</${listTag}>`;
                    return html;

                } else { // Default layout
                    let html = `<ul class="mindmap-list">`;
                    liElements.forEach(li => {
                        const nodeText = li.querySelector('.mindmap-node .editable')?.innerHTML.trim() || '';
                        const childrenUl = li.querySelector('.mindmap-children-list');
                        if (nodeText) {
                            html += `<li class="mindmap-item">`;
                            if (childrenUl && childrenUl.children.length > 0) {
                                html += `<details open><summary><span class="mindmap-node">${nodeText}</span></summary>${buildPreviewList(childrenUl, false)}</details>`;
                            } else {
                                html += `<span class="mindmap-node">${nodeText}</span>`;
                            }
                            html += '</li>';
                        }
                    });
                    html += '</ul>';
                    // Root list in default view shouldn't have the vertical line from parent
                    if (isRoot) {
                       const tempDiv = document.createElement('div');
                       tempDiv.innerHTML = html;
                       const rootList = tempDiv.querySelector('.mindmap-list');
                       if(rootList) rootList.classList.add('mindmap-list-root');
                       html = tempDiv.innerHTML;
                    }
                    return html;
                }
            };
            
            const rootUl = editorBlock.querySelector('.mindmap-editor-container > .mindmap-children-list');
            const previewHtml = buildPreviewList(rootUl, true);
            
            if (previewHtml) {
                const layoutClass = layout === 'orgchart' ? 'layout-orgchart' : '';
                content = `<div class="mindmap-preview ${layoutClass}">${previewHtml}</div>`;
            } else {
                content = '<p style="color:#888;">마인드맵 내용이 없습니다.</p>';
            }
        } else if (type === 'daily-quiz') {
                blockTitleHtml = ''; // 별도 컨테이너 사용
                previewBlock.classList.add('no-title-block');
                
                const quizType = editorBlock.querySelector('.daily-quiz-type-select').value;
                previewBlock.dataset.quizType = quizType; // 내보내기를 위해 퀴즈 타입 저장
                const fileName = `quiz_data_${quizType}.json`;

                // 퀴즈 콘텐츠를 렌더링하는 내부 함수
                const renderQuizContent = (quizData, items) => {
                    const correctAnswer = quizData.proverb;
                    const currentQuizIndex = items.findIndex(item => item.proverb === correctAnswer);
                    
                    let wrongAnswers = [];
                    while(wrongAnswers.length < 3) {
                        const randomIndex = Math.floor(Math.random() * items.length);
                        if (randomIndex !== currentQuizIndex && !wrongAnswers.includes(items[randomIndex].proverb)) {
                            wrongAnswers.push(items[randomIndex].proverb);
                        }
                    }

                    const choices = shuffle([correctAnswer, ...wrongAnswers]);
                    const answerIndex = choices.indexOf(correctAnswer) + 1;
                    
                    let choicesHtml = '';
                    const numberChars = ['①', '②', '③', '④'];
                    choices.forEach((choice, index) => {
                        choicesHtml += `<div class="mcq-preview-option" data-choice="${index + 1}">${numberChars[index]} ${choice}</div>`;
                    });

                    // ✅ [수정] new-proverb-btn 버튼 추가
                    return `
                        <div class="daily-quiz-preview">
                            <div class="mcq-preview-item" data-attempts="0" data-answer="${answerIndex}" data-explanation="${btoa(encodeURIComponent(quizData.example || ''))}" data-current-proverb="${btoa(encodeURIComponent(correctAnswer))}">
                                <div class="quiz-title-preview"><strong>[오늘의 퀴즈]</strong> 다음 설명에 해당하는 것은 무엇일까요?</div>
                                <div class="mcq-passage-preview">${quizData.explanation.replace(/\n/g, '<br>')}</div>
                                <div class="mcq-options-preview">${choicesHtml}</div>
                                <div class="quiz-controls" style="display: none;">
                                    <span class="feedback"></span>
                                    <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                                    <button class="new-proverb-btn" style="display:none;">다른 속담 더 풀어보기</button>
                                </div>
                                <div class="explanation"></div>
                            </div>
                        </div>
                    `;
                };

                (async () => {
                    try {
                        const response = await fetch(fileName);
                        if (!response.ok) throw new Error(`데이터 파일(${fileName})을 불러올 수 없습니다.`);
                        const proverbs = await response.json();
                        previewBlock._proverbData = proverbs; // ✅ [중요] 데이터를 블록에 저장

                        const now = new Date();
                        const start = new Date(now.getFullYear(), 0, 0);
                        const diff = now - start;
                        const oneDay = 1000 * 60 * 60 * 24;
                        const dayOfYear = Math.floor(diff / oneDay);

                        const todaysProverbIndex = dayOfYear % proverbs.length;
                        const todaysQuizData = proverbs[todaysProverbIndex];
                        
                        previewBlock.innerHTML = renderQuizContent(todaysQuizData, proverbs);

                    } catch (error) {
                        previewBlock.innerHTML = `<div class="daily-quiz-preview" style="color: var(--incorrect-color); text-align: center;">${error.message}</div>`;
                    }
                })();
        } else if (type === 'spacer') {
            const height = editorBlock.style.height || '40px';
            previewBlock.outerHTML = `<div style="height: ${height};"></div>`;
            return;
        }

        previewBlock.innerHTML = blockTitleHtml + content;
        }

        function parseAndRenderText(html) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            let hasCheckButtonBlanks = false; // ✅ '정답 확인' 버튼이 필요한 빈칸만 감지

            tempDiv.querySelectorAll('.explainable-in-editor').forEach(span => {
                const explanationHtml = span.dataset.explanation || '';
                if (explanationHtml.trim() !== '') {
                    span.classList.remove('explainable-in-editor');
                    span.classList.add('explainable');
                } else {
                    const fragment = document.createDocumentFragment();
                    while (span.firstChild) {
                        fragment.appendChild(span.firstChild);
                    }
                    span.parentNode.replaceChild(fragment, span);
                }
            });

            function processNode(node) {
                if (node.nodeType !== Node.TEXT_NODE) {
                    Array.from(node.childNodes).forEach(processNode);
                    return;
                }

                const text = node.textContent;
                const parent = node.parentNode;

                const regex = /\[\]\(([^)]+)\)|\[([^\]]+)\]\(([^)]+)\)|\[([^|\]]+)\|([^\]]+)\]|\[([^\]]+)\](?![\(\]])/g;
                let match;
                let lastIndex = 0;
                const newNodes = [];

                while ((match = regex.exec(text)) !== null) {
                    if (match.index > lastIndex) {
                        newNodes.push(document.createTextNode(text.substring(lastIndex, match.index)));
                    }

                    if (match[1]) {
                        const trimmedUrl = match[1].trim();
                        if (/\.(jpg|jpeg|png|gif|svg|webp)(\?.*)?$/i.test(trimmedUrl)) {
                            const img = document.createElement('img');
                            img.src = trimmedUrl;
                            img.className = 'inline-image-from-text';
                            img.alt = '사용자 삽입 이미지';
                            newNodes.push(img);
                        } else {
                            newNodes.push(document.createTextNode(match[0]));
                        }
                    }
                    else if (match[2] && match[3]) {
                        const linkText = match[2];
                        const linkContent = match[3].trim();
                        if (/^(https?:\/\/|www\.)/i.test(linkContent)) {
                            let url = linkContent;
                            if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
                            const a = document.createElement('a');
                            a.href = url;
                            a.target = '_blank';
                            a.className = 'inline-link-from-text';
                            a.textContent = linkText;
                            newNodes.push(a);
                        } else {
                            newNodes.push(document.createTextNode(match[0]));
                        }
                    }
                    else if (match[4] && match[5]) {
                        const hint = match[4].trim();
                        const answer = match[5].trim();
                        const encodedAnswer = btoa(encodeURIComponent(answer));
                        const encodedHint = btoa(encodeURIComponent(hint));
                        const span = document.createElement('span');
                        span.className = 'revealable-cloze';
                        span.dataset.answer = encodedAnswer;
                        span.dataset.hint = encodedHint;
                        span.textContent = hint;
                        newNodes.push(span);
                    }
                    else if (match[6]) {
                        const content = match[6].trim();
                        if (!content) {
                            newNodes.push(document.createTextNode(match[0]));
                            continue;
                        }

                        if (content.includes(',')) {
                            const choices = content.split(',').map(c => c.trim());
                            let correctAnswer = '';
                            const cleanChoices = choices.map(choice => {
                                if (choice.startsWith('*')) {
                                    const cleanAnswer = choice.substring(1).trim();
                                    correctAnswer = cleanAnswer;
                                    return cleanAnswer;
                                }
                                return choice;
                            }).filter(Boolean);

                            if (!correctAnswer && cleanChoices.length > 0) correctAnswer = cleanChoices[0];

                            const fixedChoices = [...cleanChoices];
                            shuffle(fixedChoices);
                            const answerData = btoa(encodeURIComponent(correctAnswer));

                            const containerSpan = document.createElement('span');
                            containerSpan.className = 'interactive-cloze-container';
                            containerSpan.dataset.answer = answerData;

                            const blankSpan = document.createElement('span');
                            blankSpan.className = 'cloze-blank';
                            blankSpan.innerHTML = '&nbsp;';

                            const choicesSpan = document.createElement('span');
                            choicesSpan.className = 'cloze-choices';
                            fixedChoices.forEach(choiceText => {
                                const choice = document.createElement('span');
                                choice.className = 'cloze-choice';
                                choice.textContent = choiceText;
                                choicesSpan.appendChild(choice);
                            });

                            containerSpan.appendChild(blankSpan);
                            containerSpan.appendChild(choicesSpan);
                            newNodes.push(containerSpan);

                        } else {
                            hasCheckButtonBlanks = true; // ✅ [정답] 형식일 때만 true로 설정
                            const answerData = btoa(encodeURIComponent(content));
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.className = 'blank-input-preview';
                            input.dataset.answer = answerData;
                            newNodes.push(input);
                        }
                    }
                    lastIndex = regex.lastIndex;
                }

                if (lastIndex < text.length) {
                    newNodes.push(document.createTextNode(text.substring(lastIndex)));
                }

                if (newNodes.length > 0) {
                    const fragment = document.createDocumentFragment();
                    fragment.append(...newNodes);
                    parent.replaceChild(fragment, node);
                }
            }

            processNode(tempDiv);

            return { html: tempDiv.innerHTML, hasCheckButtonBlanks: hasCheckButtonBlanks };
        }

        function initializeAllInteractiveBlocks() {
            preview.querySelectorAll('.line-quiz-preview').forEach(quizEl => {
                if (!quizEl.lineQuizInstance) { 
                    initializeLineQuiz(quizEl);
                } else {
                    quizEl.lineQuizInstance.reset();
                }
            });
        }

        function initializeLineQuiz(quizEl) {
            if (quizEl.lineQuizInstance) {
                quizEl.lineQuizInstance.reset();
                return;
            }

            const canvas = quizEl.querySelector('.line-quiz-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const allDots = quizEl.querySelectorAll('.dot');
            
            let selectedDot = null;
            let connections = []; 

            const matchItemHeights = () => {
                const leftItems = Array.from(quizEl.querySelectorAll('.line-quiz-column:first-child .line-quiz-item'));
                const rightItems = Array.from(quizEl.querySelectorAll('.line-quiz-column:last-child .line-quiz-item'));
                const numItems = Math.min(leftItems.length, rightItems.length);

                for (let i = 0; i < numItems; i++) {
                    leftItems[i].style.height = '';
                    rightItems[i].style.height = '';
                    const leftHeight = leftItems[i].offsetHeight;
                    const rightHeight = rightItems[i].offsetHeight;
                    const maxHeight = Math.max(leftHeight, rightHeight);
                    if (maxHeight > 36) {
                         leftItems[i].style.height = `${maxHeight}px`;
                         rightItems[i].style.height = `${maxHeight}px`;
                    }
                }
            };
            
            const resizeCanvas = () => {
                if (!quizEl.isConnected) return;
                canvas.width = quizEl.clientWidth;
                canvas.height = quizEl.clientHeight;
                matchItemHeights();
                redrawLines();
            };

            const getDotPosition = (dot) => {
                const dotRect = dot.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                    x: dotRect.left - canvasRect.left + dotRect.width / 2,
                    y: dotRect.top - canvasRect.top + dotRect.height / 2
                };
            };

            const redrawLines = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                connections.forEach(conn => {
                    const startDot = quizEl.querySelector(`.line-quiz-column:first-child .dot[data-id="${conn.leftId}"]`);
                    const endDot = quizEl.querySelector(`.line-quiz-column:last-child .dot[data-id="${conn.rightId}"]`);
                    if (!startDot || !endDot) return;
                    
                    const startPos = getDotPosition(startDot);
                    const endPos = getDotPosition(endDot);
                    ctx.beginPath();
                    ctx.moveTo(startPos.x, startPos.y);
                    ctx.lineTo(endPos.x, endPos.y);
                    ctx.strokeStyle = conn.color || '#007bff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                });
            };

            const handleDotClick = (e) => {
                const dot = e.target;
                if (!dot.classList.contains('dot') || dot.classList.contains('disabled')) return;

                if (!selectedDot) {
                    selectedDot = dot;
                    dot.classList.add('selected');
                } else {
                    if (selectedDot.closest('.line-quiz-column') === dot.closest('.line-quiz-column')) {
                        selectedDot.classList.remove('selected');
                        selectedDot = dot;
                        dot.classList.add('selected');
                        return;
                    }

                    const leftDot = selectedDot.closest('.line-quiz-column:first-child') ? selectedDot : dot;
                    const rightDot = selectedDot.closest('.line-quiz-column:last-child') ? selectedDot : dot;
                    
                    const leftId = leftDot.dataset.id;
                    const rightId = rightDot.dataset.id;

                    connections = connections.filter(c => c.leftId !== leftId);
                    connections.push({ leftId, rightId });
                    
                    redrawLines();

                    selectedDot.classList.remove('selected');
                    selectedDot = null;
                }
            };
            
            const instance = {
                checkAnswers: () => {
                    connections.forEach(conn => {
                        const isCorrect = conn.leftId === conn.rightId;
                        conn.color = isCorrect ? '#28a745' : '#dc3545';
                    });
                    redrawLines();
                    allDots.forEach(d => d.classList.add('disabled'));
                },
                reset: () => {
                    connections = [];
                    selectedDot = null;
                    allDots.forEach(dot => dot.classList.remove('selected', 'disabled'));
                    
                    const rightColumnEl = quizEl.querySelector('.line-quiz-column:last-child');
                    const rightItems = Array.from(rightColumnEl.querySelectorAll('.line-quiz-item'));
                    
                    shuffle(rightItems);

		    rightColumnEl.innerHTML = '';
                    rightItems.forEach(item => rightColumnEl.appendChild(item));
                    
                    redrawLines();
                    setTimeout(resizeCanvas, 0);
                }
            };

            quizEl.lineQuizInstance = instance;
            quizEl.addEventListener('click', handleDotClick);
            
            const resizeObserver = new ResizeObserver(resizeCanvas);
            resizeObserver.observe(quizEl);
        }

        function saveSelection() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                // ✅ 커서가 에디터 내부에 있을 때만 저장하도록 조건을 강화
                if (editor.contains(range.startContainer)) {
                    savedRange = range;
                }
            }
        }
        function restoreSelection() {
            if (savedRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedRange);
            }
        }

        function wrapSelectionWithSpan(className) {
            restoreSelection();
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.getRangeAt(0).collapsed) return;

            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.className = className;
            
            try {
                range.surroundContents(span);
                selection.removeAllRanges();
                savedRange = null;
                renderFullPreview(); 
            } catch(e) {
                console.error("선택 영역을 감쌀 수 없습니다.", e);
            }
        }
        
        function smartRemoveFormat() {
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.isCollapsed) return;
        
            // 1단계: 브라우저 기본 서식 제거 기능 실행
            document.execCommand('removeFormat', false, null);
        
            // 2단계: 클래스 기반 서식을 더 확실하게 제거
            const range = selection.getRangeAt(0);
            const formattingTagsSelector = '[class*="text-border-"], [class*="text-highlight-"]';
            
            // 제거할 태그들을 Set으로 관리하여 중복 제거
            const spansToUnwrap = new Set();
            
            // 케이스 1: 선택 영역이 서식 태그 내부에 있을 경우 (부모 찾기)
            let currentNode = range.commonAncestorContainer;
            while (currentNode && currentNode !== editor) {
                if (currentNode.nodeType === Node.ELEMENT_NODE && currentNode.matches(formattingTagsSelector)) {
                    spansToUnwrap.add(currentNode);
                }
                currentNode = currentNode.parentNode;
            }

            // 케이스 2: 선택 영역이 여러 서식 태그를 포함할 경우 (자식 찾기)
            const container = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
                ? range.commonAncestorContainer
                : range.commonAncestorContainer.parentElement;

            if (container) {
                container.querySelectorAll(formattingTagsSelector).forEach(span => {
                    if (selection.containsNode(span, true) || range.intersectsNode(span)) {
                        spansToUnwrap.add(span);
                    }
                });
            }
            
            // 수집된 모든 태그의 서식을 제거
            spansToUnwrap.forEach(span => {
                const parent = span.parentNode;
                while (span.firstChild) {
                    parent.insertBefore(span.firstChild, span);
                }
                if (parent) {
                    parent.removeChild(span);
                    parent.normalize();
                }
            });
        }

        function changeFontSize(direction) {
            restoreSelection();
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.isCollapsed) return;
        
            const range = selection.getRangeAt(0);
            const content = range.extractContents();
            
            const walker = document.createTreeWalker(content, Node.ELEMENT_NODE, null, false);
            const nodesToProcess = [];
            while(walker.nextNode()) {
                if(walker.currentNode.nodeName === 'SPAN' && walker.currentNode.style.fontSize) {
                    nodesToProcess.push(walker.currentNode);
                } else if (walker.currentNode.nodeName === 'FONT') { // <font> 태그 처리
                    const span = document.createElement('span');
                    span.innerHTML = walker.currentNode.innerHTML;
                    // 기존 스타일 복사 (색상 등)
                    if(walker.currentNode.color) span.style.color = walker.currentNode.color;
                    walker.currentNode.parentNode.replaceChild(span, walker.currentNode);
                    nodesToProcess.push(span);
                }
            }

            // 이미 스타일이 적용된 SPAN이 없는 경우, 전체를 감싸서 처리
            if (nodesToProcess.length === 0 && content.textContent.trim() !== '') {
                const span = document.createElement('span');
                span.appendChild(content);
                range.insertNode(span);
                nodesToProcess.push(span);
            } else {
                range.insertNode(content);
            }
        
            nodesToProcess.forEach(node => {
                const currentSize = parseFloat(window.getComputedStyle(node).fontSize);
                const newSize = direction === 'increase' ? currentSize + 1 : Math.max(8, currentSize - 1); // 최소 8px
                node.style.fontSize = `${newSize}px`;
            });
            
            editor.normalize();
            renderFullPreview();
            saveSelection(); // 작업 후 선택 영역 다시 저장
        }


        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function parseYoutubeUrl(url) {
            if (!url) return null;
            let videoId = null;
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            if (match && match[2].length === 11) {
                videoId = match[2];
            }
            return videoId;
        }

        addTabBtn.addEventListener('click', () => addNewTab());

        editorTabButtons.addEventListener('click', e => {
            const target = e.target;
            const tabButton = target.closest('.tab-btn');
            if (!tabButton) return;

            if (target.classList.contains('delete-tab-btn')) {
                e.stopPropagation();
                deleteTab(tabButton.dataset.tabId);
            } else {
                switchTab(tabButton.dataset.tabId);
            }
        });

        previewTabButtons.addEventListener('click', e => {
             const tabButton = e.target.closest('.tab-btn');
             if(tabButton) switchTab(tabButton.dataset.tabId);
        });

        editorTabButtons.addEventListener('dblclick', e => {
            const tabButton = e.target.closest('.tab-btn');
            if(tabButton && !e.target.classList.contains('delete-tab-btn')) {
                renameTab(tabButton.dataset.tabId);
            }
        });

        let draggedTab = null;
        editorTabButtons.addEventListener('dragstart', e => {
            draggedTab = e.target.closest('.tab-btn');
            if (draggedTab) {
                setTimeout(() => draggedTab.classList.add('dragging'), 0);
            }
        });

        editorTabButtons.addEventListener('dragend', e => {
            if (draggedTab) {
                draggedTab.classList.remove('dragging');
                
                const newOrder = Array.from(editorTabButtons.querySelectorAll('.tab-btn')).map(btn => btn.dataset.tabId);
                tabOrder = newOrder;
                isDirty = true;

                rebuildUIFromData();
            }
        });

        editorTabButtons.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterTab(editorTabButtons, e.clientX);
            if (draggedTab) {
                 if (afterElement == null) {
                    editorTabButtons.appendChild(draggedTab);
                 } else {
                    editorTabButtons.insertBefore(draggedTab, afterElement);
                 }
            }
        });

        function getDragAfterTab(container, x) {
            const draggableElements = [...container.querySelectorAll('.tab-btn:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        
        editor.addEventListener('mouseup', saveSelection);
        
        blockAdder.addEventListener('click', e => {
            if (blockAdder.classList.contains('disabled')) {
                alert("먼저 '+' 버튼을 눌러 새 단원을 추가해주세요.");
                return;
            }
            const button = e.target.closest('button');
            if (button && button.dataset.type) {
                addBlock(button.dataset.type);
            }
        });
        
        toolbar.addEventListener('mousedown', e => {
            const target = e.target.closest('button');
            if (!target) return;
        
            e.preventDefault();
        
            const command = target.dataset.command;
            const value = target.dataset.value;
        
            // 글꼴 색상 팔레트 토글
            if (command === 'fontColor' || command === 'toggleBgColorDropdown' || command === 'toggleBorderDropdown' || command === 'toggleHighlightDropdown') {
                const dropdownMenu = target.nextElementSibling;
                const isShown = dropdownMenu.classList.contains('show');
                // 모든 드롭다운 메뉴를 닫음
                document.querySelectorAll('.dropdown-menu.show').forEach(menu => menu.classList.remove('show'));
                // 현재 메뉴만 상태를 토글
                if (!isShown) dropdownMenu.classList.add('show');
                return;
            }
        
            // 팔레트 내 색상 선택
            if (target.parentElement.classList.contains('color-palette')) {
                restoreSelection();
                document.execCommand('foreColor', false, value);
                target.closest('.dropdown-menu').classList.remove('show');
                // 선택한 색상을 미리보기 바에 표시
                const indicator = target.closest('.dropdown').querySelector('.color-indicator');
                if (indicator) {
                    indicator.style.backgroundColor = value;
                }
                renderFullPreview();
                saveSelection(); // 작업 후 선택 영역 다시 저장
                return;
            }
        
            // 글꼴 크기 조절
            if (command === 'increaseFontSize' || command === 'decreaseFontSize') {
                changeFontSize(command === 'increaseFontSize' ? 'increase' : 'decrease');
                return; 
            }
        
            // 기존 서식 명령어 처리
            if (command === 'applyTextBorder' || command === 'applyTextHighlight' || command === 'customRemoveFormat') {
                restoreSelection();
                if (command === 'applyTextBorder') wrapSelectionWithSpan(`text-border-${value}`);
                if (command === 'applyTextHighlight') wrapSelectionWithSpan(`text-highlight-${value}`);
                if (command === 'customRemoveFormat') {
                    smartRemoveFormat(); // 새로 만든 스마트 서식 제거 함수만 호출
                }
                renderFullPreview();
                saveSelection(); // 작업 후 선택 영역 다시 저장
            } else if (command) {
                restoreSelection();
                document.execCommand(command, false, value || null);
                renderFullPreview(); // ✅ 미리보기 새로고침 명령 추가
                saveSelection(); // 작업 후 선택 영역 다시 저장
            }
        });
        
        // 다른 곳 클릭 시 글꼴 색상 팔레트 닫기
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });
        

        // ✅ 이 코드를 toolbar 이벤트 리스너 바로 아래에 추가해주세요.

        document.getElementById('add-explanation-btn').addEventListener('click', async () => {
            restoreSelection();
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
                alert('먼저 텍스트를 선택하세요.');
                return;
            }

            let range = selection.getRangeAt(0);

            const parentSpan = range.commonAncestorContainer.parentElement.closest('.explainable-in-editor');
            const selectedText = parentSpan ? parentSpan.textContent : range.toString();
            const existingExplanation = parentSpan ? parentSpan.dataset.explanation : '';

            const explanation = await showExplanationModal(selectedText, existingExplanation);

            if (explanation !== null) { // 취소는 null, 삭제는 '', 확인은 내용
                const startNode = range.startContainer;
                const element = startNode.nodeType === Node.TEXT_NODE ? startNode.parentElement : startNode;
                const editableParent = element.closest('.editable');
                if (editableParent) editableParent.focus({ preventScroll: true }); // <<-- 핵심 수정사항

                selection.removeAllRanges();
                selection.addRange(range);

                let targetNode;

                if (explanation.trim() === '') { // 삭제를 선택한 경우
                    if (parentSpan) {
                        const textNode = document.createTextNode(parentSpan.textContent);
                        parentSpan.parentNode.replaceChild(textNode, parentSpan);
                        targetNode = textNode;
                    }
                } else { // 확인을 선택한 경우
                    if (parentSpan){
                        targetNode = parentSpan;
                        targetNode.dataset.explanation = explanation;
                    } else {
                        const span = document.createElement('span');
                        span.className = 'explainable-in-editor';
                        span.dataset.explanation = explanation;
                        range.surroundContents(span);
                        targetNode = span;
                    }
                }

                if (targetNode) {
                    const finalParent = targetNode.parentNode;
                    if (finalParent) {
                        const zeroWidthSpace = document.createTextNode('\u200B');
                        finalParent.insertBefore(zeroWidthSpace, targetNode.nextSibling);

                        const newRange = document.createRange();
                        newRange.setStartAfter(zeroWidthSpace);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                        savedRange = newRange;
                    }
                }

                // renderFullPreview() 대신 input 이벤트를 직접 발생시켜 업데이트합니다.
                editor.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                isDirty = true;

                // 불필요해진 스크롤 복원 코드를 완전히 제거했습니다.
            }
        });




        emojiPalette.addEventListener('mousedown', e => {
            if (e.target.tagName === 'SPAN') {
                e.preventDefault(); // 이모지가 포커스를 훔치지 못하게 막습니다.
                document.execCommand('insertText', false, e.target.textContent);
            }
        });

        editor.addEventListener('input', e => {
            // ✅ 카테고리 이름 변경 시 드롭다운 실시간 업데이트 기능 복원
            if (e.target.closest('.classification-category-editor-row')) {
                const block = e.target.closest('.block');
                updateAllCategoryDropdowns(block);
            }

            const target = e.target;
            if (target.classList.contains('table-field')) {
                const block = target.closest('.block');
                const numColumns = Math.max(1, Array.from(block.querySelectorAll('.table-field')).filter(f => f.textContent.trim() !== '').length);
                block.querySelectorAll('.table-record-row').forEach(row => {
                    while (row.children.length < numColumns) {
                        const newCell = document.createElement('div');
                        newCell.className = 'editable table-record-cell';
                        newCell.contentEditable = true;
                        row.appendChild(newCell);
                    }
                    while (row.children.length > numColumns) {
                        row.lastElementChild.remove();
                    }
                });
            } else if (target.matches('.youtube-url-input, .link-url-input, .link-title-input, .frame-title-input, .frame-url-input, .frame-source-input')) {
                renderFullPreview();
                isDirty = true;
                return; 
            }
            renderFullPreview();
            isDirty = true;
        });
        
        editor.addEventListener('click', e => {

            const addCategoryBtn = e.target.closest('.add-classification-category');
            const addItemBtn = e.target.closest('.add-classification-item');
            const deleteCategoryBtn = e.target.closest('.delete-classification-category');
            const deleteItemBtn = e.target.closest('.delete-classification-item');

            if (addCategoryBtn) {
                const block = addCategoryBtn.closest('.block');
                const container = block.querySelector('.classification-categories-editor');
                addClassificationCategory(container);
                updateAllCategoryDropdowns(block);
            }
            if (addItemBtn) {
                const block = addItemBtn.closest('.block');
                const container = block.querySelector('.classification-items-editor');
                addClassificationItem(container);
                updateAllCategoryDropdowns(block);
            }
            if (deleteCategoryBtn) {
                const block = deleteCategoryBtn.closest('.block');
                deleteCategoryBtn.parentElement.remove();
                updateAllCategoryDropdowns(block);
            }
            if (deleteItemBtn) {
                deleteItemBtn.parentElement.remove();
            }

            const deleteDragDropItemBtn = e.target.closest('.delete-drag-drop-item');
            if (deleteDragDropItemBtn) {
                if (confirm('이 문항을 정말 삭제하시겠습니까?')) {
                    const itemToRemove = deleteDragDropItemBtn.closest('.drag-drop-item-editor');
                    const container = itemToRemove.parentElement;
                    itemToRemove.remove();
                    renumberDragDropItems(container); // 방금 추가한 번호 재정렬 함수 호출
                    renderFullPreview();
                    isDirty = true;
                }
                return; // 다른 클릭 이벤트와 충돌하지 않도록 여기서 종료
            }

            const deleteLineQuizItemBtn = e.target.closest('.delete-line-quiz-item');
            if (deleteLineQuizItemBtn) {
                if (confirm('이 항목을 정말 삭제하시겠습니까?')) {
                    const itemToRemove = deleteLineQuizItemBtn.closest('.line-quiz-item-editor');
                    const container = itemToRemove.parentElement;
                    itemToRemove.remove();
                    renumberLineQuizItems(container); // 번호 재정렬 함수 호출
                    renderFullPreview();
                    isDirty = true;
                }
                return;
            }    
            
            const deleteFillInItemBtn = e.target.closest('.delete-fill-in-item');
            if (deleteFillInItemBtn) {
                if (confirm('이 문항을 정말 삭제하시겠습니까?')) {
                    const itemToRemove = deleteFillInItemBtn.closest('.fill-in-item-editor');
                    const container = itemToRemove.parentElement;
                    itemToRemove.remove();
                    renumberFillInItems(container); // 번호 재정렬 함수 호출
                    renderFullPreview();
                    isDirty = true;
                }
                return; // 다른 클릭 이벤트와 충돌하지 않도록 여기서 종료
            }

            const deleteOxItemBtn = e.target.closest('.delete-ox-item');
            if (deleteOxItemBtn) {
                if (confirm('이 문항을 정말 삭제하시겠습니까?')) {
                    const itemToRemove = deleteOxItemBtn.closest('.ox-item-editor');
                    const container = itemToRemove.parentElement;
                    itemToRemove.remove();
                    renumberOxItems(container); // 번호 재정렬 함수 호출
                    renderFullPreview();
                    isDirty = true;
                }
                return; // 다른 클릭 이벤트와 충돌하지 않도록 여기서 종료
            }

            // --- 객관식 정답 스텝퍼 버튼 로직 ---
            const stepperBtn = e.target.closest('.mcq-answer-btn');
            if (stepperBtn) {
                const stepper = stepperBtn.closest('.mcq-answer-stepper');
                const display = stepper.querySelector('.mcq-answer-display');
                const hiddenInput = stepper.querySelector('.mcq-answer');
                
                let currentValue = parseInt(hiddenInput.value, 10);
                const step = parseInt(stepperBtn.dataset.step, 10);
                
                let newValue = currentValue + step;
                if (newValue < 1) newValue = 1; // 정답은 1 미만으로 내려갈 수 없음
                
                display.textContent = newValue;
                hiddenInput.value = newValue;
                hiddenInput.setAttribute('value', newValue); // 미리보기 렌더링을 위해 속성도 업데이트
                
                renderFullPreview();
                isDirty = true;
                return;
            }

            const deleteOrderingItemBtn = e.target.closest('.delete-ordering-item');
            if (deleteOrderingItemBtn) {
                if (confirm('이 문항을 정말 삭제하시겠습니까?')) {
                    const itemToRemove = deleteOrderingItemBtn.closest('.ordering-item-editor');
                    const container = itemToRemove.parentElement;
                    itemToRemove.remove();
                    renumberOrderingItems(container);
                    renderFullPreview();
                    isDirty = true;
                }
                return;
            }
            
            // ✅ 순서도 행 포커스 관리 로직
            const clickedRow = e.target.closest('.flowchart-editor-row');
            editor.querySelectorAll('.flowchart-editor-row').forEach(row => {
                if (row === clickedRow) {
                    row.classList.add('focused');
                } else {
                    row.classList.remove('focused');
                }
            });

            const copyBtn = e.target.closest('.copy-block-btn');
            // ...
            if (copyBtn) {
                const blockToCopy = copyBtn.closest('.block');
                if (blockToCopy) {
                    // ... (중간 생략) ...

                    // 👍 해결: 깨끗한 HTML을 먼저 복사하고,
                    blockClipboard = blockToCopy.outerHTML;

                    // 👍 그 다음에 사용자에게 보여줄 시각적 효과를 적용함
                    blockToCopy.classList.add('copied');
                    setTimeout(() => blockToCopy.classList.remove('copied'), 600); 

                    alert('블록이 복사되었습니다.');
                }
                return;
            }

            // ✅ 'if (copyBtn) { ... }' 블록 바로 다음에 추가
            const toggleBtn = e.target.closest('.toggle-default-btn');
            if (toggleBtn) {
                const block = toggleBtn.closest('.block');
                const stateInput = block.querySelector('.toggle-state-input');
                if (stateInput.value === 'open') {
                    stateInput.value = 'closed';
                    toggleBtn.innerHTML = '▶️';
                    toggleBtn.title = '미리보기 토글 기본값 (닫힘)';
                } else {
                    stateInput.value = 'open';
                    toggleBtn.innerHTML = '👁️';
                    toggleBtn.title = '미리보기 토글 기본값 (펼침)';
                }
                renderFullPreview();
                isDirty = true;
            }

            // ...
            if (e.target.classList.contains('add-ox-item')) addOxItem(e.target.closest('.block'));
            if (e.target.classList.contains('add-mcq-option')) addMcqOption(e.target.closest('.block'));
            if (e.target.classList.contains('add-fill-in-item')) addFillInItem(e.target.closest('.block'));
            if (e.target.classList.contains('add-table-row-btn')) addTableRow(e.target.closest('.block'));
            if (e.target.classList.contains('add-line-quiz-item')) addLineQuizItem(e.target.closest('.block'));
            if (e.target.classList.contains('add-drag-drop-item')) addDragDropItem(e.target.closest('.block'));
            if (e.target.classList.contains('add-ordering-item')) addOrderingItem(e.target.closest('.block'));
            if (e.target.classList.contains('add-flowchart-row')) addFlowchartRow(e.target.closest('.block'));
            if (e.target.classList.contains('delete-flowchart-row-btn')) deleteFlowchartRow(e.target.closest('.flowchart-editor-row'));
            if (e.target.classList.contains('change-flowchart-layout')) {
                const row = e.target.closest('.flowchart-editor-row');
                const layout = e.target.dataset.layout;
                changeFlowchartLayout(row, layout);
            }

        // --- 마인드맵 노드 추가/삭제 로직 시작 ---
            const addChildBtn = e.target.closest('.mindmap-add-child');
            if (addChildBtn) {
                const parentLi = addChildBtn.closest('.mindmap-editor-item');
                const childrenUl = parentLi.querySelector('.mindmap-children-list');

                const newLi = document.createElement('li');
                newLi.className = 'mindmap-editor-item';
                // 이제 새로 추가되는 항목에는 삭제(x) 버튼도 포함됩니다.
                newLi.innerHTML = `
                    <div class="mindmap-node-wrapper">
                        <div class="mindmap-node">
                            <span class="editable" contenteditable="true">새 항목</span>
                        </div>
                        <div class="mindmap-node-actions">
                            <button class="mindmap-outdent-node" title="수준 올리기">←</button>
                            <button class="mindmap-indent-node" title="수준 내리기">→</button>
                            <button class="mindmap-add-sibling-node" title="다음 항목 추가">↵</button>
                            <button class="mindmap-add-child" title="하위 항목 추가">+</button>
                            <button class="mindmap-delete-node" title="항목 삭제">×</button>
                        </div>
                    </div>
                    <ul class="mindmap-children-list"></ul>`;
                
                childrenUl.appendChild(newLi);

                // 사용자가 바로 입력할 수 있도록 새로 만든 항목에 자동으로 포커스를 줍니다.
                const newEditable = newLi.querySelector('.editable');
                if (newEditable) {
                    newEditable.focus();
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.selectNodeContents(newEditable);
                    range.collapse(false);
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                renderFullPreview();
                isDirty = true;
            }

            const deleteNodeBtn = e.target.closest('.mindmap-delete-node');
            if (deleteNodeBtn) {
                if (confirm('이 항목과 모든 하위 항목들이 함께 삭제됩니다. 정말 삭제하시겠습니까?')) {
                    const nodeLi = deleteNodeBtn.closest('.mindmap-editor-item');
                    if (nodeLi) {
                        nodeLi.remove();
                        renderFullPreview();
                        isDirty = true;
                    }
                }
            }
            // --- 마인드맵 노드 추가/삭제 로직 끝 ---   
            
            // --- 마인드맵 다음 항목 추가 및 수준 조절 로직 시작 ---
            const addSiblingBtn = e.target.closest('.mindmap-add-sibling-node');
            if (addSiblingBtn) {
                const currentLi = addSiblingBtn.closest('.mindmap-editor-item');
                
                const newLi = document.createElement('li');
                newLi.className = 'mindmap-editor-item';
                newLi.innerHTML = `
                    <div class="mindmap-node-wrapper">
                        <div class="mindmap-node">
                            <span class="editable" contenteditable="true">새 항목</span>
                        </div>
                        <div class="mindmap-node-actions">
                            <button class="mindmap-outdent-node" title="수준 올리기">←</button>
                            <button class="mindmap-indent-node" title="수준 내리기">→</button>
                            <button class="mindmap-add-sibling-node" title="다음 항목 추가">↵</button>
                            <button class="mindmap-add-child" title="하위 항목 추가">+</button>
                            <button class="mindmap-delete-node" title="항목 삭제">×</button>
                        </div>
                    </div>
                    <ul class="mindmap-children-list"></ul>`;
                
                // 현재 항목의 바로 다음에 새 항목 삽입
                currentLi.parentNode.insertBefore(newLi, currentLi.nextSibling);

                // 자동 포커스 기능
                const newEditable = newLi.querySelector('.editable');
                if (newEditable) {
                    newEditable.focus();
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.selectNodeContents(newEditable);
                    range.collapse(false); // 커서를 맨 뒤로
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                renderFullPreview();
                isDirty = true;
            }

            const indentBtn = e.target.closest('.mindmap-indent-node');
            if (indentBtn) {
                const nodeToMove = indentBtn.closest('.mindmap-editor-item');
                const previousLi = nodeToMove.previousElementSibling;

                if (previousLi) { // 바로 위 형제 항목이 있을 때만 들여쓰기 가능
                    const targetUl = previousLi.querySelector('.mindmap-children-list');
                    targetUl.appendChild(nodeToMove);
                    renderFullPreview();
                    isDirty = true;
                }
            }

            const outdentBtn = e.target.closest('.mindmap-outdent-node');
            if (outdentBtn) {
                const nodeToMove = outdentBtn.closest('.mindmap-editor-item');
                const parentUl = nodeToMove.parentNode;
                const grandparentLi = parentUl.closest('.mindmap-editor-item');

                if (grandparentLi) { // 상위 항목이 있을 때만 내어쓰기 가능
                    grandparentLi.parentNode.insertBefore(nodeToMove, grandparentLi.nextSibling);
                    renderFullPreview();
                    isDirty = true;
                }
            }
            // --- 마인드맵 다음 항목 추가 및 수준 조절 로직 끝 ---

            // --- 마인드맵 레이아웃 변경 로직 시작 ---
            const changeLayoutBtn = e.target.closest('.change-mindmap-layout');
            if (changeLayoutBtn) {
                const block = changeLayoutBtn.closest('.block[data-type="mindmap"]');
                if (block) {
                    const currentLayout = block.dataset.layout || 'default';
                    if (currentLayout === 'default') {
                        block.dataset.layout = 'orgchart';
                        changeLayoutBtn.title = "레이아웃 변경 (조직도형)";
                    } else {
                        block.dataset.layout = 'default';
                        changeLayoutBtn.title = "레이아웃 변경 (기본형)";
                    }
                    renderFullPreview();
                    isDirty = true;
                }
            }
            // --- 마인드맵 레이아웃 변경 로직 끝 ---

            
            
            if (e.target.matches('input[name^="link-target"], .frame-expanded-check')) {
                renderFullPreview();
                isDirty = true;
            }

            const deleteBtn = e.target.closest('.delete-block-btn');
            if (deleteBtn) {
                const blockToDelete = deleteBtn.closest('.block');
                if (blockToDelete && confirm('이 블록을 정말 삭제하시겠습니까?')) {
                    blockToDelete.remove();
                    renderFullPreview();
                    isDirty = true;
                }
            }
        });

        // ✅ 이 코드 블록을 통째로 추가해주세요.
        editor.addEventListener('dblclick', async e => {
            const targetSpan = e.target.closest('.explainable-in-editor');

            if (!targetSpan) {
                return;
            }

            e.preventDefault();

            const selectedText = targetSpan.textContent;
            const existingExplanation = targetSpan.dataset.explanation || '';

            const explanation = await showExplanationModal(selectedText, existingExplanation);

            if (explanation !== null) { // 취소는 null, 삭제는 '', 확인은 내용
                if (explanation.trim() === '') { // 삭제를 선택한 경우
                    const textNode = document.createTextNode(targetSpan.textContent);
                    targetSpan.parentNode.replaceChild(textNode, targetSpan);
                } else { // 확인을 선택한 경우
                    targetSpan.dataset.explanation = explanation;
                }

                const savedScrollTop = editor.scrollTop;

                // renderFullPreview() 대신 input 이벤트를 직접 발생시켜 업데이트합니다.
                editor.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                isDirty = true;

                // ✅ 화면 그리기가 끝난 후, 저장된 커서 위치로 화면을 스크롤합니다.
            setTimeout(() => {
                if (savedRange) {
                    const tempMarker = document.createElement('span');
                    try {
                        savedRange.insertNode(tempMarker);
                        tempMarker.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                        tempMarker.parentNode.removeChild(tempMarker);
                    } catch(e) {
                        // 범위를 삽입할 수 없는 경우, 기존 방식으로 복원 시도
                        editor.scrollTop = savedScrollTop;
                    }
                } else {
                    editor.scrollTop = savedScrollTop;
                }
            }, 50); // ✅ 브라우저가 렌더링할 시간을 조금 더 확보합니다.
            }
        });

        editor.addEventListener('change', e => {
            if (e.target.classList.contains('flowchart-arrow-toggle') || e.target.classList.contains('flowchart-first-col-narrow-checkbox')) {
                renderFullPreview();
                isDirty = true;
            }
        });
        
        editor.addEventListener('focusin', e => {
            if (e.target.classList.contains('fill-in-question') && e.target.classList.contains('placeholder-active')) {
                e.target.innerHTML = '';
                e.target.classList.remove('placeholder-active');
            }
        });

        editor.addEventListener('focusout', e => {
            if (e.target.classList.contains('fill-in-question') && e.target.textContent.trim() === '') {
                e.target.innerHTML = FILL_IN_PLACEHOLDER;
                e.target.classList.add('placeholder-active');
            }
        });

        editor.addEventListener('keydown', e => {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const container = (range.startContainer.nodeType === Node.ELEMENT_NODE) ? range.startContainer : range.startContainer.parentNode;

            // --- 마인드맵 단축키 로직 시작 ---
            const mindmapEditable = container.closest('.mindmap-node .editable');
            if (mindmapEditable) {
                const currentLi = mindmapEditable.closest('.mindmap-editor-item');
                if (!currentLi) return;

                // Tab: 한 수준 내리기 (들여쓰기)
                if (e.key === 'Tab' && !e.shiftKey) {
                    e.preventDefault();
                    const indentBtn = currentLi.querySelector('.mindmap-indent-node');
                    if (indentBtn) indentBtn.click();
                    return;
                }

                // Shift + Tab: 한 수준 올리기 (내어쓰기)
                if (e.key === 'Tab' && e.shiftKey) {
                    e.preventDefault();
                    const outdentBtn = currentLi.querySelector('.mindmap-outdent-node');
                    if (outdentBtn) outdentBtn.click();
                    return;
                }
                
                // Ctrl + Enter: 같은 수준에 새 항목 추가
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    const addSiblingBtn = currentLi.querySelector('.mindmap-add-sibling-node');
                    // 최상위 노드에는 sibling 버튼이 없으므로 자식 추가 버튼으로 대체
                    if (addSiblingBtn) {
                        addSiblingBtn.click();
                    } else {
                        const addChildBtn = currentLi.querySelector('.mindmap-add-child');
                        if (addChildBtn) addChildBtn.click();
                    }
                    return;
                }

                // Alt + ArrowUp/ArrowDown: 항목 위/아래로 이동
                if (e.altKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();
                    
                    if (e.key === 'ArrowUp') {
                        const prevLi = currentLi.previousElementSibling;
                        if (prevLi) {
                            prevLi.parentNode.insertBefore(currentLi, prevLi);
                        }
                    } else { // ArrowDown
                        const nextLi = currentLi.nextElementSibling;
                        if (nextLi) {
                            nextLi.parentNode.insertBefore(currentLi, nextLi.nextSibling);
                        }
                    }

                    // 이동 후 포커스 재설정
                    const editable = currentLi.querySelector('.editable');
                    if (editable) {
                        editable.focus();
                        const newRange = document.createRange();
                        const sel = window.getSelection();
                        newRange.selectNodeContents(editable);
                        newRange.collapse(false); // 커서를 끝으로 이동
                        sel.removeAllRanges();
                        sel.addRange(newRange);
                    }
                    renderFullPreview();
                    isDirty = true;
                    return;
                }
            }
            // --- 마인드맵 단축키 로직 끝 ---

            if (e.key !== ' ' && e.key !== 'Enter') {
                return;
            }

            if (!selection.isCollapsed) {
                return;
            }
            
            const formattingSelector = '[class*="text-border-"], [class*="text-highlight-"], .explainable-in-editor';
            const formattedSpan = container.closest(formattingSelector);

            if (formattedSpan) {
                // ✅ [수정] 커서 위치를 더 정확하게 감지하는 새로운 로직
                let isAtEnd = false;
                const lastChild = formattedSpan.lastChild;
                
                // 1. 커서가 있는 곳이 span 내부의 '텍스트'이고,
                if (range.startContainer.nodeType === Node.TEXT_NODE && formattedSpan.contains(range.startContainer)) {
                    // 2. 그 텍스트 노드가 span의 마지막 자식이며,
                    if (lastChild === range.startContainer) {
                        // 3. 커서가 그 텍스트의 맨 끝에 있다면 '탈출 조건'이 성립됩니다.
                        if (range.startOffset === range.startContainer.textContent.length) {
                            isAtEnd = true;
                        }
                    }
                }

                if (isAtEnd) {
                    e.preventDefault();
                    
                    if (e.key === 'Enter') {
                        const br = document.createElement('br');
                        formattedSpan.parentNode.insertBefore(br, formattedSpan.nextSibling);

                        // <br> 뒤에 보이지 않는 공백(ZWS)을 넣어 커서를 위치시킵니다.
                        const zeroWidthSpace = document.createTextNode('\u200B');
                        br.parentNode.insertBefore(zeroWidthSpace, br.nextSibling);
                        selection.collapse(zeroWidthSpace, 0);

                    } else if (e.key === ' ') {
                        // 일반 공백 대신 Non-breaking space를 삽입합니다.
                        const nbsp = document.createTextNode('\u00A0');
                        formattedSpan.parentNode.insertBefore(nbsp, formattedSpan.nextSibling);
                        selection.collapse(nbsp, 1); // 커서를 공백 문자 뒤로 이동시킵니다.
                    }
                }
            }
        });

        // [새로운 기능] 엔터 또는 스페이스 입력 후, 불필요하게 따라온 서식을 자동으로 제거하는 기능
        editor.addEventListener('keyup', e => {
            // 1. 감지할 키에 스페이스바(' ') 추가
            if (e.key !== 'Enter' && e.key !== ' ') {
                return;
            }

            const selection = window.getSelection();
            if (!selection.rangeCount || !selection.isCollapsed) {
                return;
            }

            const range = selection.getRangeAt(0);
            const container = (range.startContainer.nodeType === Node.ELEMENT_NODE) ? range.startContainer : range.startContainer.parentNode;
            const formattingSelector = 'span[class*="text-border-"], span[class*="text-highlight-"], span.explainable-in-editor, span[style*="background-color"]';
            const formattedSpan = container.closest(formattingSelector);
            
            if (!formattedSpan) return;

            // 2. 엔터 키 처리 로직 (기존과 동일)
            if (e.key === 'Enter') {
                if (formattedSpan.textContent.trim() === '' || formattedSpan.innerHTML === '<br>') {
                     const parent = formattedSpan.parentNode;
                     if (parent) {
                        while (formattedSpan.firstChild) {
                            parent.insertBefore(formattedSpan.firstChild, formattedSpan);
                        }
                        parent.removeChild(formattedSpan);
                        parent.normalize();
                     }
                }
            // 3. 스페이스바 처리 로직 (새로 추가)
            } else if (e.key === ' ') {
                // 서식 태그의 내용이 공백 문자(&nbsp;)로 끝나는지 확인
                if (formattedSpan.textContent.endsWith('\u00A0')) {
                    // 서식 태그 내부의 마지막 공백 문자를 제거
                    formattedSpan.textContent = formattedSpan.textContent.slice(0, -1);

                    // 서식 없는 공백 문자를 새로 생성
                    const spaceNode = document.createTextNode('\u00A0');

                    // 서식 태그의 바로 뒤에 삽입
                    if (formattedSpan.nextSibling) {
                        formattedSpan.parentNode.insertBefore(spaceNode, formattedSpan.nextSibling);
                    } else {
                        formattedSpan.parentNode.appendChild(spaceNode);
                    }

                    // 커서를 새로 만든 공백 문자 뒤로 이동
                    const newRange = document.createRange();
                    newRange.setStart(spaceNode, 1);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            }
        });


        // --- 드래그 앤 드롭 리스너 (이벤트 위임 방식) ---
        let currentDraggedItem = null;
        let dropIndicator = null;

        function getDragAfterElementHorizontal(container, x) {
            const draggableElements = [...container.querySelectorAll('.ordering-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        preview.addEventListener('dragstart', e => {
            if (e.target.matches('.classification-item-card')) {
                currentDraggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
            if (e.target.matches('.drag-source, .ordering-item')) {
                currentDraggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);

                if (e.target.matches('.ordering-item')) {
                    dropIndicator = document.createElement('div');
                    dropIndicator.className = 'ordering-drop-indicator';
                }
            }
        });

        preview.addEventListener('dragend', e => {
            const droppedItem = e.target;

            if (droppedItem.matches('.ordering-item')) {
                setTimeout(() => {
                    const targetContainer = droppedItem.closest('.ordering-target-container');
                    
                    if (targetContainer) {
                        const item = targetContainer.closest('.ordering-preview-item');
                        const feedbackIcon = item.querySelector('.ordering-item-feedback');
                        const studentItems = Array.from(targetContainer.querySelectorAll('.ordering-item'));
                        const studentAnswer = studentItems.map(i => i.textContent.trim()).join(' // ');
                        const correctAnswer = decodeURIComponent(atob(item.dataset.answer));
                        const totalItemCount = correctAnswer.split('//').length;

                        // ✅ [수정] 정답, 오답, 미완성 상태를 모두 확인하는 로직으로 변경
                        if (studentAnswer === correctAnswer) {
                            targetContainer.classList.remove('incorrect');
                            targetContainer.classList.add('correct');
                            if (feedbackIcon) feedbackIcon.textContent = '⭕';

                            const quizContainer = item.closest('.ordering-preview-container');
                            const allItems = quizContainer.querySelectorAll('.ordering-preview-item');
                            const allCorrect = Array.from(allItems).every(i => i.querySelector('.ordering-target-container.correct'));

                            if (allCorrect) {
                                const feedbackEl = quizContainer.querySelector('.feedback');
                                feedbackEl.textContent = '모두 정답입니다! 완벽해요! ✨';
                                feedbackEl.className = 'feedback show correct';
                                quizContainer.querySelector('.check-ordering-btn').style.display = 'none';
                                quizContainer.querySelector('.retry-quiz-btn').style.display = 'inline-block';
                            }
                        } else if (studentItems.length === totalItemCount) {
                            targetContainer.classList.remove('correct');
                            targetContainer.classList.add('incorrect');
                            if (feedbackIcon) feedbackIcon.textContent = '❌';
                        } else {
                            targetContainer.classList.remove('correct', 'incorrect');
                            if (feedbackIcon) feedbackIcon.textContent = '';
                        }
                    }
                }, 0);
            }

            if (currentDraggedItem) {
                currentDraggedItem.classList.remove('dragging');
                if (dropIndicator && dropIndicator.parentNode) {
                    dropIndicator.parentNode.removeChild(dropIndicator);
                }
                dropIndicator = null;
                currentDraggedItem = null;
            }
        });

        preview.addEventListener('dragover', e => {
            e.preventDefault();
            const classificationDropZone = e.target.closest('.category-drop-zone, .classification-items-source');
            if (classificationDropZone && currentDraggedItem?.matches('.classification-item-card')) {
                classificationDropZone.classList.add('drag-over');
            }

            const dropTarget = e.target.closest('.drop-target');
            const sourceContainer = e.target.closest('.source-container');
            const orderingContainer = e.target.closest('.ordering-target-container');

            if (dropTarget || (sourceContainer && currentDraggedItem?.parentElement.classList.contains('drop-target'))) {
                e.target.closest('.drop-target, .source-container').classList.add('drag-over');
            } else if (orderingContainer && currentDraggedItem?.matches('.ordering-item')) {
                orderingContainer.classList.add('drag-over');
                const afterElement = getDragAfterElementHorizontal(orderingContainer, e.clientX);
                if (afterElement == null) {
                    if (orderingContainer.lastChild !== dropIndicator) orderingContainer.appendChild(dropIndicator);
                } else {
                    if (afterElement.previousSibling !== dropIndicator) orderingContainer.insertBefore(dropIndicator, afterElement);
                }
            }
        });

        preview.addEventListener('dragleave', e => {
            const classificationDropZone = e.target.closest('.category-drop-zone, .classification-items-source');
            if (classificationDropZone) {
                classificationDropZone.classList.remove('drag-over');
            }
            const relatedTarget = e.relatedTarget;
            const dropZone = e.target.closest('.drop-target, .source-container, .ordering-target-container');
            if (dropZone && !dropZone.contains(relatedTarget)) {
                dropZone.classList.remove('drag-over');
            }
             if(dropZone && dropIndicator && dropIndicator.parentNode) {
                dropIndicator.parentNode.removeChild(dropIndicator);
             }
        });

        preview.addEventListener('drop', e => {
            e.preventDefault();
            if (!currentDraggedItem) return;

            const classificationDropZone = e.target.closest('.category-drop-zone, .classification-items-source');
            if (classificationDropZone && currentDraggedItem?.matches('.classification-item-card')) {
                classificationDropZone.appendChild(currentDraggedItem);
                classificationDropZone.classList.remove('drag-over');

                const quizContainer = classificationDropZone.closest('.classification-preview-container');
                const hasChecked = quizContainer.querySelector('.classification-item-card.correct, .classification-item-card.incorrect');
                
                if (hasChecked) {
                    quizContainer.querySelectorAll('.classification-item-card').forEach(card => {
                        card.classList.remove('correct', 'incorrect');
                    });
                    quizContainer.querySelector('.retry-quiz-btn').style.display = 'none';
                    quizContainer.querySelector('.check-classification-btn').style.display = 'inline-block';
                    const feedbackEl = quizContainer.querySelector('.feedback');
                    feedbackEl.className = 'feedback';
                    feedbackEl.innerHTML = '';
                }
            }

            const dropTarget = e.target.closest('.drop-target');
            const sourceContainer = e.target.closest('.source-container');
            const orderingContainer = e.target.closest('.ordering-source-container, .ordering-target-container');

            // ✅ '드래그 앤 드롭' 퀴즈 로직 시작
            if (dropTarget || (sourceContainer && currentDraggedItem.parentElement.classList.contains('drop-target'))) {
                const quizContainer = (dropTarget || sourceContainer).closest('.drag-drop-preview-container');
                const hasChecked = quizContainer.querySelector('.drop-target.correct, .drop-target.incorrect');

                // 정답 확인 후 상태라면 퀴즈 상태를 리셋
                if (hasChecked) {
                    quizContainer.querySelectorAll('.drop-target').forEach(target => {
                        target.classList.remove('correct', 'incorrect');
                    });
                    const controls = quizContainer.querySelector('.quiz-controls');
                    if (controls) {
                        controls.querySelector('.retry-quiz-btn').style.display = 'none';
                        controls.querySelector('.check-drag-drop-btn').style.display = 'inline-block';
                        const feedbackEl = controls.querySelector('.feedback');
                        feedbackEl.className = 'feedback';
                        feedbackEl.innerHTML = '';
                    }
                }

                if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                    const existingItem = dropTarget.querySelector('.drag-source');
                    const mainSourceContainer = quizContainer.querySelector('.source-container');
                    if (existingItem) {
                        mainSourceContainer.appendChild(existingItem);
                    }
                    dropTarget.appendChild(currentDraggedItem);
                } else { // sourceContainer로 되돌아갈 때
                    sourceContainer.classList.remove('drag-over');
                    sourceContainer.appendChild(currentDraggedItem);
                }
            } 
            // ✅ '드래그 앤 드롭' 퀴즈 로직 끝
            else if (orderingContainer) {
                orderingContainer.classList.remove('drag-over');
                if (dropIndicator && dropIndicator.parentNode) {
                    dropIndicator.parentNode.replaceChild(currentDraggedItem, dropIndicator);
                } else {
                    const afterElement = getDragAfterElementHorizontal(orderingContainer, e.clientX);
                    if (afterElement == null) orderingContainer.appendChild(currentDraggedItem);
                    else orderingContainer.insertBefore(currentDraggedItem, afterElement);
                }
                const quizContainer = orderingContainer.closest('.ordering-preview-container');
                if (quizContainer && orderingContainer.classList.contains('ordering-target-container')) {
                    if (orderingContainer.matches('.correct, .incorrect')) {
                        orderingContainer.classList.remove('correct', 'incorrect');
                        const controls = quizContainer.querySelector('.quiz-controls');
                        if (controls) {
                            controls.querySelector('.retry-quiz-btn').style.display = 'none';
                            controls.querySelector('.check-ordering-btn').style.display = 'inline-block';
                            controls.querySelector('.feedback').className = 'feedback';
                        }
                    }
                }
            }
        });
       






        editor.addEventListener('mousedown', e => {
            if (!e.target.classList.contains('resize-handle')) return;
            
            const handle = e.target;
            const block = handle.closest('.block');
            if (!block) return;

            e.preventDefault();

            const startY = e.clientY;
            const startHeight = parseInt(block.style.height, 10);
            document.body.classList.add('resizing');

            const handleMouseMove = (moveEvent) => {
                const dy = moveEvent.clientY - startY;
                let newHeight = startHeight + dy;
                if (newHeight < 30) newHeight = 30;
                block.style.height = newHeight + 'px';
            };

            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                document.body.classList.remove('resizing');
                renderFullPreview();
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        preview.addEventListener('click', e => {
            // ✨ [개선] 즉시 확인형 빈칸 퀴즈 로직 (오답 재시도, 정답 클릭 시 초기화)
            const clozeChoice = e.target.closest('.cloze-choice');
            if (clozeChoice) {
                const container = clozeChoice.closest('.interactive-cloze-container');
                if (container.classList.contains('answered') || clozeChoice.classList.contains('used')) return;

                const blank = container.querySelector('.cloze-blank');
                const studentAnswer = clozeChoice.textContent.trim();
                const correctAnswer = decodeURIComponent(atob(container.dataset.answer));

                blank.textContent = studentAnswer;
                blank.classList.add('filled');
                blank.classList.remove('incorrect');

                if (studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                    blank.classList.add('correct');
                    container.classList.add('answered');
                    container.querySelectorAll('.cloze-choice').forEach(choice => {
                        choice.classList.add('used');
                    });
                } else {
                    blank.classList.add('incorrect');
                    clozeChoice.classList.add('used');
                }
                return;
            }

            const filledBlank = e.target.closest('.cloze-blank.filled');
            if (filledBlank && filledBlank.classList.contains('correct')) {
                // ✨ 정답이 표시된 빈칸을 클릭하면 퀴즈가 초기화됩니다.
                const container = filledBlank.closest('.interactive-cloze-container');
                container.classList.remove('answered');
                filledBlank.innerHTML = '&nbsp;';
                filledBlank.className = 'cloze-blank'; // 모든 상태 클래스 제거
                container.querySelectorAll('.cloze-choice').forEach(choice => {
                    choice.classList.remove('used');
                });
                return;
            }

            const cloze = e.target.closest('.revealable-cloze');
            const revealed = e.target.closest('.revealed-answer');

            if (cloze) {
                const answer = decodeURIComponent(atob(cloze.dataset.answer));
                cloze.textContent = answer;
                cloze.className = 'revealed-answer';
                return;
            }
            if (revealed) {
                const hint = decodeURIComponent(atob(revealed.dataset.hint));
                revealed.textContent = hint;
                revealed.className = 'revealable-cloze';
                return;
            }

            const dragSource = e.target.closest('.drag-source');
            if (dragSource) {
                if (dragSource.classList.contains('selected')) {
                    dragSource.classList.remove('selected');
                } else {
                    const allSources = dragSource.closest('.drag-drop-preview-container').querySelectorAll('.drag-source');
                    allSources.forEach(item => item.classList.remove('selected'));
                    dragSource.classList.add('selected');
                }
                return;
            }

            const orderingItem = e.target.closest('.ordering-item');
            if (orderingItem) {
                if (orderingItem.classList.contains('selected')) {
                    orderingItem.classList.remove('selected');
                } else {
                    const allItems = orderingItem.closest('.ordering-preview-container').querySelectorAll('.ordering-item');
                    allItems.forEach(item => item.classList.remove('selected'));
                    orderingItem.classList.add('selected');
                }
                return;
            }
            const summary = e.target.closest('.frame-preview-summary, .summary-preview-summary, .text-preview-summary');
            if (summary) {
                e.preventDefault();
                const details = summary.parentElement;
                details.open = !details.open;
                return;
            }
            const retryBtn = e.target.closest('.retry-quiz-btn');
            const checkAnswerBtn = e.target.closest('.check-answer-btn');
            const checkFillInBtn = e.target.closest('.check-fill-in-btn');
            const checkLineQuizBtn = e.target.closest('.check-line-quiz-btn');
            const checkDragDropBtn = e.target.closest('.check-drag-drop-btn');
            const checkOrderingBtn = e.target.closest('.check-ordering-btn');
            const checkClassificationBtn = e.target.closest('.check-classification-btn');
            const youtubePlaceholder = e.target.closest('.youtube-placeholder');

            if (retryBtn) {
                const quizContainer = retryBtn.closest('.quiz-container, .mcq-preview-item, .descriptive-preview-item, .fill-in-container, .table-preview-container, .drag-drop-preview-container, .ordering-preview-container, .classification-preview-container, .text-content-container, .text-preview-container, .block[data-type="flowchart"]');

                if (quizContainer) {
                    quizContainer.dataset.attempts = "0";
                    const controls = quizContainer.querySelector('.quiz-controls');
                    if (controls && controls.querySelector('.feedback')) {
                        controls.querySelector('.feedback').className = 'feedback';
                        controls.querySelector('.feedback').innerHTML = '';
                    }
                    quizContainer.querySelectorAll('.explanation').forEach(el => { el.className = 'explanation' });

                    if (quizContainer.querySelector('.ox-preview-item')) {
                        quizContainer.querySelectorAll('.ox-preview-item .feedback').forEach(fb => {
                            fb.className = 'feedback';
                            fb.innerHTML = '';
                        });
                        quizContainer.querySelectorAll('.ox-choices button').forEach(btn => {
                            btn.classList.remove('selected');
                        });
                    }

                    if (quizContainer.classList.contains('mcq-preview-item')) {
                        quizContainer.dataset.attempts = "0";
                        quizContainer.querySelectorAll('.mcq-preview-option').forEach(opt => {
                            opt.classList.remove('selected', 'correct', 'incorrect');
                        });
                        retryBtn.style.display = 'none';
                        if (controls) controls.style.display = 'none';
                        const explanation = quizContainer.querySelector('.explanation');
                        if (explanation) explanation.classList.remove('show');
                    }

                    if (quizContainer.classList.contains('descriptive-preview-item')) {
                        const studentAnswerEl = quizContainer.querySelector('.descriptive-student-answer');
                        studentAnswerEl.value = '';
                        studentAnswerEl.disabled = false;
                        quizContainer.querySelector('.check-answer-btn').style.display = 'inline-block';
                        retryBtn.style.display = 'none';
                    }

                    quizContainer.querySelectorAll('.blank-input-preview').forEach(input => {
                        input.value = '';
                        input.disabled = false;
                        input.className = 'blank-input-preview';
                    });

                    quizContainer.querySelectorAll('.interactive-cloze-container').forEach(cloze => {
                        cloze.classList.remove('answered');
                        const blank = cloze.querySelector('.cloze-blank');
                        blank.innerHTML = '&nbsp;';
                        blank.className = 'cloze-blank';
                        cloze.querySelectorAll('.cloze-choice').forEach(choice => {
                            choice.classList.remove('used');
                        });
                    });

                    const checkBtn = quizContainer.querySelector('.check-fill-in-btn');
                    if(checkBtn) checkBtn.style.display = 'inline-block';
                    retryBtn.style.display = 'none';

                    const lineQuizPreview = quizContainer.querySelector('.line-quiz-preview');
                    if (lineQuizPreview && lineQuizPreview.lineQuizInstance) {
                        lineQuizPreview.lineQuizInstance.reset();
                        retryBtn.style.display = 'none';
                        quizContainer.querySelector('.check-line-quiz-btn').style.display = 'inline-block';
                    }

                    if (quizContainer.classList.contains('drag-drop-preview-container')) {
                        const sourceContainer = quizContainer.querySelector('.source-container');
                        const allWords = [];
                        quizContainer.querySelectorAll('.drop-target').forEach(target => {
                            if (target.textContent.trim()) { allWords.push(target.textContent.trim()); }
                            target.textContent = '';
                            target.className = 'drop-target';
                        });
                        sourceContainer.querySelectorAll('.drag-source').forEach(source => { allWords.push(source.textContent.trim()); });
                        const originalAnswers = Array.from(quizContainer.querySelectorAll('.drop-target')).map(t => t.dataset.answer);
                        while(allWords.length < originalAnswers.length) {
                            const wordCount = allWords.reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
                            const originalWordCount = originalAnswers.reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
                            let missingWordFound = false;
                            for(const word in originalWordCount) {
                                if((wordCount[word] || 0) < originalWordCount[word]) {
                                    allWords.push(word); missingWordFound = true; break;
                                }
                            }
                            if (!missingWordFound) break;
                        }
                        sourceContainer.innerHTML = '';
                        const shuffledWords = shuffle(allWords);
                        shuffledWords.forEach(word => {
                            const newSource = document.createElement('span');
                            newSource.className = 'drag-source'; newSource.draggable = true; newSource.textContent = word;
                            sourceContainer.appendChild(newSource);
                        });
                        retryBtn.style.display = 'none';
                        quizContainer.querySelector('.check-drag-drop-btn').style.display = 'inline-block';
                    }

                    // ✅ [수정] 순서 배열 퀴즈 초기화 로직 전체 수정
                    if (quizContainer.classList.contains('ordering-preview-container')) {
                        quizContainer.querySelectorAll('.ordering-preview-item').forEach(item => {
                            const sourceContainer = item.querySelector('.ordering-source-container');
                            const targetContainer = item.querySelector('.ordering-target-container');
                            
                            // ✅ [개선] 해당 문항의 모든 선택지(정답칸, 선택지칸 모두)를 수집
                            const allItemsForThisQuestion = Array.from(item.querySelectorAll('.ordering-item'));

                            // ✅ [개선] 수집된 모든 선택지를 섞어서 해당 문항의 선택지 칸으로 이동
                            shuffle(allItemsForThisQuestion).forEach(card => sourceContainer.appendChild(card));
                            
                            // ✅ [개선] 정답칸의 클래스와 피드백 아이콘을 확실하게 초기화
                            targetContainer.className = 'ordering-target-container';
                            const feedbackIcon = item.querySelector('.ordering-item-feedback');
                            if(feedbackIcon) feedbackIcon.textContent = '';
                        });
                        
                        retryBtn.style.display = 'none';
                        quizContainer.querySelector('.check-ordering-btn').style.display = 'inline-block';
                    }

                    if (quizContainer.classList.contains('classification-preview-container')) {
                        const sourceContainer = quizContainer.querySelector('.classification-items-source');
                        const allCards = Array.from(quizContainer.querySelectorAll('.classification-item-card'));

                        allCards.forEach(card => {
                            card.classList.remove('correct', 'incorrect');
                        });

                        shuffle(allCards).forEach(card => {
                            sourceContainer.appendChild(card);
                        });

                        retryBtn.style.display = 'none';
                        quizContainer.querySelector('.check-classification-btn').style.display = 'inline-block';
                    }

                }
            } else if (checkAnswerBtn) {
                const item = checkAnswerBtn.closest('.descriptive-preview-item');
                const studentAnswerEl = item.querySelector('.descriptive-student-answer');
                const studentAnswer = studentAnswerEl.value.trim();
                const feedbackEl = item.querySelector('.feedback');
                const retryBtnItem = item.querySelector('.retry-quiz-btn');
                const encodedAnswers = item.dataset.answers;
                const correctAnswers = JSON.parse(decodeURIComponent(atob(encodedAnswers)));

                const isCorrect = studentAnswer && correctAnswers.some(ans => ans.toLowerCase() === studentAnswer.toLowerCase());

                if (isCorrect) {
                    feedbackEl.className = 'feedback show correct';
                    feedbackEl.innerHTML = `<span class="correct-highlight">정답!</span> 훌륭해요! 👍`;
                } else {
                    feedbackEl.className = 'feedback show correct';
                    feedbackEl.innerHTML = `<strong>모범 정답:</strong> ${correctAnswers.join(', ')}`;
                }

                studentAnswerEl.disabled = true;
                checkAnswerBtn.style.display = 'none';
                retryBtnItem.style.display = 'inline-block';
            } else if (checkFillInBtn) {
                const container = checkFillInBtn.closest('.fill-in-container, .table-preview-container, .text-content-container, .text-preview-container, .block[data-type="flowchart"]');
                if (!container) return;

                const feedbackEl = container.querySelector('.feedback');
                let allCorrect = true;

                let attempts = parseInt(container.dataset.attempts || "0", 10);
                attempts++;
                container.dataset.attempts = attempts;

                container.querySelectorAll('.blank-input-preview').forEach(inputEl => {
                    const studentAnswer = inputEl.value.trim();
                    const correctAnswer = decodeURIComponent(atob(inputEl.dataset.answer));
                    if (studentAnswer && studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                        inputEl.className = 'blank-input-preview correct';
                    } else {
                        inputEl.className = 'blank-input-preview incorrect';
                        allCorrect = false;
                    }
                });

                if (allCorrect) {
                    feedbackEl.textContent = '모두 정답입니다!';
                    feedbackEl.className = 'feedback show correct';
                } else {
                    if (attempts < 2) {
                        feedbackEl.textContent = '아쉬워요. 틀린 문제를 다시 풀어보세요!';
                        feedbackEl.className = 'feedback show incorrect';

                        container.querySelectorAll('.blank-input-preview.incorrect').forEach(input => input.value = '');
                        return;
                    } else {
                        feedbackEl.textContent = '정답을 확인하세요.';
                        feedbackEl.className = 'feedback show incorrect';

                        container.querySelectorAll('.blank-input-preview.incorrect').forEach(input => {
                            input.value = decodeURIComponent(atob(input.dataset.answer));
                            input.disabled = true;
                        });
                    }
                }

                checkFillInBtn.style.display = 'none';
                container.querySelector('.retry-quiz-btn').style.display = 'inline-block';

            } else if (checkLineQuizBtn) {
                const quizEl = checkLineQuizBtn.closest('.quiz-container').querySelector('.line-quiz-preview');
                if (quizEl && quizEl.lineQuizInstance) {
                    quizEl.lineQuizInstance.checkAnswers();
                    checkLineQuizBtn.style.display = 'none';
                    checkLineQuizBtn.nextElementSibling.style.display = 'inline-block';
                }
            } else if (checkDragDropBtn) {
                const container = checkDragDropBtn.closest('.drag-drop-preview-container');
                const feedbackEl = container.querySelector('.feedback');
                let allCorrect = true;

                container.querySelectorAll('.drop-target').forEach(target => {
                    const studentAnswer = target.textContent.trim();
                    const correctAnswer = target.dataset.answer;
                    if (studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                        target.className = 'drop-target correct';
                    } else {
                        target.className = 'drop-target incorrect';
                        allCorrect = false;
                    }
                });

                if (allCorrect) {
                    feedbackEl.textContent = '모두 정답입니다!';
                    feedbackEl.className = 'feedback show correct';
                } else {
                    feedbackEl.textContent = '아쉬워요. 틀린 문제가 있는지 확인해보세요.';
                    feedbackEl.className = 'feedback show incorrect';
                }
                checkDragDropBtn.style.display = 'none';
                container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
            } else if (checkOrderingBtn) {
                const container = checkOrderingBtn.closest('.ordering-preview-container');
                const feedbackEl = container.querySelector('.feedback');
                let allCorrect = true;

                container.querySelectorAll('.ordering-preview-item').forEach(item => {
                    const targetContainer = item.querySelector('.ordering-target-container');
                    const feedbackIcon = item.querySelector('.ordering-item-feedback');
                    const studentItems = Array.from(targetContainer.querySelectorAll('.ordering-item')).map(i => i.textContent.trim());
                    const studentAnswer = studentItems.join(' // ');
                    const correctAnswer = decodeURIComponent(atob(item.dataset.answer));

                    if (studentAnswer === correctAnswer) {
                        targetContainer.classList.remove('incorrect');
                        targetContainer.classList.add('correct');
                        feedbackIcon.textContent = '⭕';
                    } else {
                        targetContainer.classList.remove('correct');
                        targetContainer.classList.add('incorrect');
                        feedbackIcon.textContent = '❌';
                        allCorrect = false;
                    }
                });

                if (allCorrect) {
                    feedbackEl.textContent = '모두 정답입니다! 완벽해요! ✨';
                    feedbackEl.className = 'feedback show correct';
                } else {
                    feedbackEl.textContent = '아쉬워요. ❌ 표시된 문제를 다시 확인해보세요.';
                    feedbackEl.className = 'feedback show incorrect';
                }

                checkOrderingBtn.style.display = 'none';
                container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
            } else if (checkClassificationBtn) {
                const container = checkClassificationBtn.closest('.classification-preview-container');
                const feedbackEl = container.querySelector('.feedback');
                let allCorrect = true; 

                const sourceContainer = container.querySelector('.classification-items-source');
                if (sourceContainer.querySelector('.classification-item-card')) {
                    allCorrect = false; 
                }

                container.querySelectorAll('.classification-category-bin').forEach(bin => {
                    const categoryName = bin.querySelector('.category-drop-zone').dataset.categoryName;
                    bin.querySelectorAll('.classification-item-card').forEach(card => {
                        if (card.dataset.correctCategory.trim() === categoryName.trim()) {
                            card.classList.add('correct');
                            card.classList.remove('incorrect');
                        } else {
                            card.classList.add('incorrect');
                            card.classList.remove('correct');
                            allCorrect = false; 
                        }
                    });
                });

                if (allCorrect) {
                    feedbackEl.textContent = '모두 정확하게 분류했습니다! 완벽해요! ✨';
                    feedbackEl.className = 'feedback show correct';
                } else {
                    feedbackEl.textContent = '아쉬워요. 잘못 분류되었거나, 분류하지 않은 항목이 있습니다.';
                    feedbackEl.className = 'feedback show incorrect';
                }
                checkClassificationBtn.style.display = 'none';
                container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
            } else if (youtubePlaceholder) {
                const videoId = youtubePlaceholder.dataset.videoId;
                if(videoId) {
                    const iframeWrapper = document.createElement('div');
                    iframeWrapper.className = 'youtube-iframe-wrapper';
                    iframeWrapper.dataset.videoId = videoId;
                    iframeWrapper.innerHTML = `<button class="youtube-close-btn" title="영상 닫기">&times;</button>
                                            <iframe src="https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1" 
                                                    frameborder="0" 
                                                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                                                    allowfullscreen></iframe>`;
                    youtubePlaceholder.replaceWith(iframeWrapper);
                }
            } else {
                
                // --- 오늘의 퀴즈 - 다른 문제 풀어보기 버튼 로직 ---
                const newProverbBtn = e.target.closest('.new-proverb-btn');
                if (newProverbBtn) {
                    const quizItem = newProverbBtn.closest('.mcq-preview-item');
                    const quizBlock = newProverbBtn.closest('.block');
                    const proverbs = quizBlock._proverbData;
                    const currentProverb = decodeURIComponent(atob(quizItem.dataset.currentProverb));

                    if (proverbs && proverbs.length > 1) {
                        let newIndex;
                        let newQuizData;
                        // 현재와 다른 퀴즈가 나올 때까지 반복
                        do {
                            newIndex = Math.floor(Math.random() * proverbs.length);
                            newQuizData = proverbs[newIndex];
                        } while (newQuizData.proverb === currentProverb);

                        // 미리보기 렌더링 함수 로직을 문자열로 추출하여 재실행 (안정적인 방법)
                        const renderFnBody = updatePreviewBlock.toString().match(/const renderQuizContent = \([\s\S]*?return `[\s\S]*?`;/)[0];
                        const renderFn = new Function('quizData', 'items', 'shuffle', renderFnBody + '}; return renderQuizContent(quizData, items)');
                        quizBlock.innerHTML = renderFn(newQuizData, proverbs, shuffle);
                    }
                    return;
                }

                const youtubeCloseBtn = e.target.closest('.youtube-close-btn');
                if (youtubeCloseBtn) {
                    const iframeWrapper = youtubeCloseBtn.parentElement;
                    const videoId = iframeWrapper.dataset.videoId;
                    if(videoId) {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'youtube-placeholder';
                        placeholder.dataset.videoId = videoId;
                        placeholder.innerHTML = `🎬
                                        <div class="youtube-placeholder-text">클릭하여 영상 보기</div>`;
                        iframeWrapper.replaceWith(placeholder);
                    }
                } else {
                    const oxChoiceBtn = e.target.closest('.ox-choices button');
                    const mcqOptionDiv = e.target.closest('.mcq-preview-option');
                    const explainable = e.target.closest('.explainable');
                    if (oxChoiceBtn) {
                        const allChoiceBtns = oxChoiceBtn.parentElement.querySelectorAll('button');
                        allChoiceBtns.forEach(btn => btn.classList.remove('selected'));
                        oxChoiceBtn.classList.add('selected');

                        const item = oxChoiceBtn.closest('.ox-preview-item');
                        const choicesDiv = item.querySelector('.ox-choices');
                        const choice = oxChoiceBtn.dataset.choice;
                        const answer = choicesDiv.dataset.answer;
                        const feedbackEl = item.querySelector('.feedback');
                        feedbackEl.className = 'feedback show ' + (choice === answer ? 'correct' : 'incorrect');
                        feedbackEl.innerHTML = choice === answer ? `<span class="correct-highlight">정답!</span> 참 잘했어요! ✨` : `<span class="incorrect-highlight">아쉬워요.</span> 다시 생각해 볼까요? 🤔`;
                    } else if (mcqOptionDiv) {
                        const item = mcqOptionDiv.closest('.mcq-preview-item');
                        
                        let attempts = parseInt(item.dataset.attempts, 10);
                        if (attempts >= 2) return;

                        const controls = item.querySelector('.quiz-controls');
                        if (controls) controls.style.display = 'flex';

                        item.querySelectorAll('.mcq-preview-option').forEach(opt => {
                            opt.classList.remove('selected', 'correct', 'incorrect');
                        });

                        attempts++;
                        item.dataset.attempts = attempts;
                        
                        const choice = mcqOptionDiv.dataset.choice;
                        const answer = item.dataset.answer;
                        const feedbackEl = item.querySelector('.feedback');
                        const explanationEl = item.querySelector('.explanation');
                        const isCorrect = (choice === answer);

                        mcqOptionDiv.classList.add('selected');

                        if (isCorrect) {
                            mcqOptionDiv.classList.add('correct');
                            feedbackEl.className = 'feedback show correct';
                            feedbackEl.innerHTML = `<span class="correct-highlight">정답!</span> 훌륭해요, 💯`;
                            item.dataset.attempts = 2;
                            if(explanationEl) explanationEl.className = 'explanation show';
                        } else {
                            mcqOptionDiv.classList.add('incorrect');
                            feedbackEl.className = 'feedback show incorrect';
                            if (attempts < 2) {
                                feedbackEl.innerHTML = `<span class="incorrect-highlight">아쉬워요.</span> 한 번 더 신중하게 풀어보세요!`;
                            } else {
                                feedbackEl.innerHTML = `<span class="incorrect-highlight">오답!</span> 정답은 ${answer}번 💪`;
                                if(explanationEl) explanationEl.className = 'explanation show';
                            }
                        }
                        if(explanationEl && explanationEl.classList.contains('show')) {
                            try {
                                const decodedExplanation = decodeURIComponent(atob(item.dataset.explanation));
                                if (decodedExplanation.trim()) explanationEl.innerHTML = `<strong>해설:</strong> ${decodedExplanation}`;
                            } catch(err) {}
                        }

                        if (isCorrect || attempts >= 2) {
                            const retryButton = item.querySelector('.retry-quiz-btn');
                            if (retryButton) retryButton.style.display = 'inline-block';
                            
                            // ✅ [추가] 오늘의 퀴즈인 경우 '다른 속담' 버튼도 함께 표시
                            if(item.closest('.daily-quiz-preview')){
                                const newProverbButton = item.querySelector('.new-proverb-btn');
                                if(newProverbButton) newProverbButton.style.display = 'inline-block';
                            }
                        }
                    } else if (explainable) {
                        explanationPopup.innerHTML = `${explainable.dataset.explanation}<button class="popup-close-btn" title="닫기">&times;</button>`;
                        const rect = explainable.getBoundingClientRect();
                        explanationPopup.style.top = `${rect.bottom + window.scrollY + 12}px`;
                        explanationPopup.style.left = `${rect.left + window.scrollX}px`;
                        explanationPopup.classList.add('show');
                        e.stopPropagation();
                    }
                }
            }
        });

        document.addEventListener('click', e => { 
            if (!e.target.closest('.explainable') && !e.target.closest('.explanation-popup')) {
                explanationPopup.classList.remove('show');
            }
        });

        explanationPopup.addEventListener('click', e => {
            if (e.target.classList.contains('popup-close-btn')) {
                explanationPopup.classList.remove('show');
            }
        });
        let draggedBlock = null;
        let draggedFlowchartRow = null;
        
        editor.addEventListener('dragstart', e => {
            const handle = e.target;
            if (handle.classList.contains('drag-handle')) {
                const flowchartRow = handle.closest('.flowchart-editor-row');
                const block = handle.closest('.block');

                if (flowchartRow) { // 순서도 행을 먼저 확인
                    draggedFlowchartRow = flowchartRow;
                    setTimeout(() => draggedFlowchartRow.classList.add('dragging'), 0);
                } else if (block) { // 그 다음 전체 블록 확인
                    draggedBlock = block;
                    setTimeout(() => draggedBlock.classList.add('dragging'), 0);
                }
            }
        });

        editor.addEventListener('dragend', () => {
            if (draggedBlock) {
                draggedBlock.classList.remove('dragging');
                draggedBlock = null;
                renderFullPreview();
            }
            if (draggedFlowchartRow) {
                draggedFlowchartRow.classList.remove('dragging');
                draggedFlowchartRow = null;
                renderFullPreview();
            }
        });

        editor.addEventListener('dragover', e => {
            e.preventDefault();
            if (draggedBlock) {
                const afterElement = getDragAfterElement(editor, e.clientY, '.block');
                if (afterElement == null) {
                    editor.appendChild(draggedBlock);
                } else {
                    editor.insertBefore(draggedBlock, afterElement);
                }
            } else if (draggedFlowchartRow) {
                const container = e.target.closest('.flowchart-items-container');
                if (container) {
                    const afterElement = getDragAfterElement(container, e.clientY, '.flowchart-editor-row');
                    if (afterElement == null) {
                        container.appendChild(draggedFlowchartRow);
                    } else {
                        container.insertBefore(draggedFlowchartRow, afterElement);
                    }
                }
            }
        });

        function getDragAfterElement(container, y, draggableSelector) {
            const draggableElements = [...container.querySelectorAll(`${draggableSelector}:not(.dragging)`)];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        document.getElementById('paste-block-btn').addEventListener('click', () => {
            if (!blockClipboard) {
                alert('복사된 블록이 없습니다.');
                return;
            }
            if (!activeTabId) {
                alert('붙여넣을 단원을 먼저 선택해주세요.');
                return;
            }

            blockIdCounter++;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = blockClipboard;
            const newBlock = tempDiv.firstElementChild;
            
            // 고유 ID를 새로 부여하여 충돌 방지
            newBlock.dataset.id = `block-${blockIdCounter}`;
            
            // MathQuill 같은 라이브러리가 필요한 블록은 다시 초기화
            if (newBlock.dataset.type === 'math') {
                const mathFieldEl = newBlock.querySelector('.math-editor-field');
                if (mathFieldEl) {
                    const latexOutput = newBlock.querySelector('.latex-output');
                    const initialLatex = latexOutput ? latexOutput.value : '';
                    const MQ = MathQuill.getInterface(2);
                    const mqInstance = MQ.MathField(mathFieldEl, {
                        handlers: {
                            edit: () => {
                                latexOutput.value = mqInstance.latex();
                                renderFullPreview();
                                isDirty = true;
                            }
                        }
                    });
                    mqInstance.latex(initialLatex);
                }
            }

            editor.appendChild(newBlock);
            renderFullPreview();
            isDirty = true;
        });



        function adjustBlankInputWidths(container) {
            const measureSpan = document.createElement('span');
            measureSpan.style.visibility = 'hidden';
            measureSpan.style.position = 'absolute';
            measureSpan.style.fontFamily = 'inherit';
            measureSpan.style.fontSize = '1em';
            document.body.appendChild(measureSpan);

            container.querySelectorAll('.blank-input-preview').forEach(input => {
                const encodedAnswer = input.dataset.answer;
                if (encodedAnswer) {
                    try {
                        const answer = decodeURIComponent(atob(encodedAnswer));
                        measureSpan.textContent = answer || '____'; // 정답이 없으면 기본 너비
                        const textWidth = measureSpan.offsetWidth;
                        input.style.width = `${textWidth + 10}px`; // 글자 너비에 약간의 여유분 추가
                    } catch (e) {
                        // console.error("Failed to adjust input width", e);
                    }
                }
            });

            document.body.removeChild(measureSpan);
        }

        function getExportableInteractiveScript() {
            return `
            document.addEventListener('DOMContentLoaded', () => {
                const explanationPopup = document.getElementById('explanationPopup');
                const previewContainer = document.getElementById('exported-container');
                let proverbDataCache = {}; // 퀴즈 데이터 캐시

                const scrollToTopBtn = document.getElementById('scrollToTopBtn');
                if (scrollToTopBtn) {
                    window.addEventListener('scroll', () => {
                        if (window.scrollY > 200) {
                            scrollToTopBtn.classList.add('show');
                        } else {
                            scrollToTopBtn.classList.remove('show');
                        }
                    });
                    scrollToTopBtn.addEventListener('click', () => {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    });
                }

                const tabButtonsContainer = document.querySelector('#preview-tab-buttons');
                if (tabButtonsContainer) {
                    tabButtonsContainer.addEventListener('click', e => {
                        const tabButton = e.target.closest('.tab-btn');
                        if (!tabButton) return;

                        const tabId = tabButton.dataset.tabId;

                        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

                        tabButton.classList.add('active');
                        const activeContent = document.querySelector('.tab-content[data-tab-content-id="' + tabId + '"]');
                        if (activeContent) {
                            activeContent.classList.add('active');
                            adjustBlankInputWidths(activeContent);
                            if (window.MathJax && window.MathJax.typesetPromise) {
                                window.MathJax.typesetPromise([activeContent]);
                            }
                        }

                        if (previewContainer) {
                            previewContainer.scrollIntoView({ behavior: 'smooth' });
                        }
                    });
                }
                
                function renderQuizContent(quizData, items, quizBlock) {
                    const correctAnswer = quizData.proverb;
                    const currentQuizIndex = items.findIndex(item => item.proverb === correctAnswer);
                    
                    let wrongAnswers = [];
                    while(wrongAnswers.length < 3) {
                        const randomIndex = Math.floor(Math.random() * items.length);
                        if (randomIndex !== currentQuizIndex && !wrongAnswers.includes(items[randomIndex].proverb)) {
                            wrongAnswers.push(items[randomIndex].proverb);
                        }
                    }

                    const choices = shuffle([correctAnswer, ...wrongAnswers]);
                    const answerIndex = choices.indexOf(correctAnswer) + 1;
                    
                    let choicesHtml = '';
                    const numberChars = ['①', '②', '③', '④'];
                    choices.forEach((choice, index) => {
                        choicesHtml += \`<div class="mcq-preview-option" data-choice="\${index + 1}">\${numberChars[index]} \${choice}</div>\`;
                    });

                    const quizHtml = \`
                        <div class="daily-quiz-preview">
                            <div class="mcq-preview-item" data-attempts="0" data-answer="\${answerIndex}" data-explanation="\${btoa(encodeURIComponent(quizData.example || ''))}" data-current-proverb="\${btoa(encodeURIComponent(correctAnswer))}">
                                <div class="quiz-title-preview"><strong>[오늘의 퀴즈]</strong> 다음 설명에 해당하는 것은 무엇일까요?</div>
                                <div class="mcq-passage-preview">\${quizData.explanation.replace(/\\n/g, '<br>')}</div>
                                <div class="mcq-options-preview">\${choicesHtml}</div>
                                <div class="quiz-controls" style="display: none;">
                                    <span class="feedback"></span>
                                    <button class="retry-quiz-btn" style="display:none;">다시 풀기</button>
                                    <button class="new-proverb-btn" style="display:none;">다른 속담 더 풀어보기</button>
                                </div>
                                <div class="explanation"></div>
                            </div>
                        </div>
                    \`;
                    quizBlock.innerHTML = quizHtml;
                }

                async function renderDailyQuiz(quizBlock) {
                    try {
                        const quizType = quizBlock.dataset.quizType;
                        if (!quizType) throw new Error('퀴즈 종류가 지정되지 않았습니다.');
                        
                        const fileName = \`quiz_data_\${quizType}.json\`;
                        
                        // 데이터 캐시 확인
                        if (!proverbDataCache[quizType]) {
                            const response = await fetch(fileName); 
                            if (!response.ok) throw new Error(\`데이터 파일(\${fileName})을 불러올 수 없습니다.\`);
                            proverbDataCache[quizType] = await response.json();
                        }
                        const items = proverbDataCache[quizType];

                        const now = new Date();
                        const start = new Date(now.getFullYear(), 0, 0);
                        const diff = now - start;
                        const oneDay = 1000 * 60 * 60 * 24;
                        const dayOfYear = Math.floor(diff / oneDay);

                        const todaysItemIndex = dayOfYear % items.length;
                        const quizData = items[todaysItemIndex];
                        
                        renderQuizContent(quizData, items, quizBlock);

                    } catch (error) {
                        quizBlock.innerHTML = \`<div class="daily-quiz-preview" style="color: var(--incorrect-color); text-align: center;">\${error.message}</div>\`;
                    }
                }

                function adjustBlankInputWidths(container) {
                    const measureSpan = document.createElement('span');
                    measureSpan.style.visibility = 'hidden';
                    measureSpan.style.position = 'absolute';
                    measureSpan.style.fontFamily = 'inherit';
                    measureSpan.style.fontSize = '1em';
                    document.body.appendChild(measureSpan);

                    container.querySelectorAll('.blank-input-preview').forEach(input => {
                        const encodedAnswer = input.dataset.answer;
                        if (encodedAnswer) {
                            try {
                                const answer = decodeURIComponent(atob(encodedAnswer));
                                measureSpan.textContent = answer || '____';
                                const textWidth = measureSpan.offsetWidth;
                                input.style.width = (textWidth + 10) + 'px';
                            } catch (e) {}
                        }
                    });
                    document.body.removeChild(measureSpan);
                }

                function initializeAllInteractiveBlocks() {
                    document.querySelectorAll('.line-quiz-preview').forEach(quizEl => {
                        initializeLineQuiz(quizEl);
                    });
                    
                    document.querySelectorAll('.block[data-type="daily-quiz"]').forEach(renderDailyQuiz);
                }

                function shuffle(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                }

                function initializeLineQuiz(quizEl) {
                    if (quizEl.lineQuizInstance) {
                        quizEl.lineQuizInstance.reset();
                        return;
                    }
                    const canvas = quizEl.querySelector('.line-quiz-canvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    const allDots = quizEl.querySelectorAll('.dot');
                    let selectedDot = null;
                    let connections = [];

                    const matchItemHeights = () => {
                        const leftItems = Array.from(quizEl.querySelectorAll('.line-quiz-column:first-child .line-quiz-item'));
                        const rightItems = Array.from(quizEl.querySelectorAll('.line-quiz-column:last-child .line-quiz-item'));
                        const numItems = Math.min(leftItems.length, rightItems.length);
                        for (let i = 0; i < numItems; i++) {
                            leftItems[i].style.height = '';
                            rightItems[i].style.height = '';
                            const leftHeight = leftItems[i].offsetHeight;
                            const rightHeight = rightItems[i].offsetHeight;
                            const maxHeight = Math.max(leftHeight, rightHeight);
                            if (maxHeight > 36) {
                                leftItems[i].style.height = maxHeight + 'px';
                                rightItems[i].style.height = maxHeight + 'px';
                            }
                        }
                    };

                    const resizeCanvas = () => {
                        if (!quizEl.isConnected) return;
                        canvas.width = quizEl.clientWidth;
                        canvas.height = quizEl.clientHeight;
                        matchItemHeights();
                        redrawLines();
                    };

                    const getDotPosition = (dot) => {
                        const dotRect = dot.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        return {
                            x: dotRect.left - canvasRect.left + dotRect.width / 2,
                            y: dotRect.top - canvasRect.top + dotRect.height / 2
                        };
                    };
                    const redrawLines = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        connections.forEach(conn => {
                            const startDot = quizEl.querySelector('.line-quiz-column:first-child .dot[data-id="' + conn.leftId + '"]');
                            const endDot = quizEl.querySelector('.line-quiz-column:last-child .dot[data-id="' + conn.rightId + '"]');
                            if (!startDot || !endDot) return;
                            const startPos = getDotPosition(startDot);
                            const endPos = getDotPosition(endDot);
                            ctx.beginPath();
                            ctx.moveTo(startPos.x, startPos.y);
                            ctx.lineTo(endPos.x, endPos.y);
                            ctx.strokeStyle = conn.color || '#007bff';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        });
                    };
                    const handleDotClick = (e) => {
                        const dot = e.target;
                        if (!dot.classList.contains('dot') || dot.classList.contains('disabled')) return;
                        if (!selectedDot) {
                            selectedDot = dot;
                            dot.classList.add('selected');
                        } else {
                            if (selectedDot.closest('.line-quiz-column') === dot.closest('.line-quiz-column')) {
                                selectedDot.classList.remove('selected');
                                selectedDot = dot;
                                dot.classList.add('selected');
                                return;
                            }
                            const leftDot = selectedDot.closest('.line-quiz-column:first-child') ? selectedDot : dot;
                            const rightDot = selectedDot.closest('.line-quiz-column:last-child') ? selectedDot : dot;
                            const leftId = leftDot.dataset.id;
                            const rightId = rightDot.dataset.id;
                            connections = connections.filter(c => c.leftId !== leftId);
                            connections.push({ leftId, rightId });
                            redrawLines();
                            selectedDot.classList.remove('selected');
                            selectedDot = null;
                        }
                    };

                    const instance = {
                        checkAnswers: () => {
                            connections.forEach(conn => {
                                conn.color = conn.leftId === conn.rightId ? '#28a745' : '#dc3545';
                            });
                            redrawLines();
                            allDots.forEach(d => d.classList.add('disabled'));
                        },
                        reset: () => {
                            connections = [];
                            selectedDot = null;
                            allDots.forEach(dot => dot.classList.remove('selected', 'disabled'));
                            const rightColumnEl = quizEl.querySelector('.line-quiz-column:last-child');
                            const rightItems = Array.from(rightColumnEl.querySelectorAll('.line-quiz-item'));
                            shuffle(rightItems);
                            rightColumnEl.innerHTML = '';
                            rightItems.forEach(item => rightColumnEl.appendChild(item));
                            redrawLines();
                            setTimeout(resizeCanvas, 0);
                        }
                    };
                    quizEl.lineQuizInstance = instance;
                    quizEl.addEventListener('click', handleDotClick);
                    const resizeObserver = new ResizeObserver(resizeCanvas);
                    resizeObserver.observe(quizEl);
                    instance.reset();
                }

                let currentDraggedItem = null;
                let dropIndicator = null; 

                function getDragAfterElementHorizontal(container, x) {
                    const draggableElements = [...container.querySelectorAll('.ordering-item:not(.dragging)')];
                    return draggableElements.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = x - box.left - box.width / 2;
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;
                }

                previewContainer.addEventListener('dragstart', e => {
                    if (e.target.matches('.classification-item-card')) {
                        currentDraggedItem = e.target;
                        setTimeout(() => e.target.classList.add('dragging'), 0);
                    }
                    if (e.target.matches('.drag-source, .ordering-item')) {
                        currentDraggedItem = e.target;
                        setTimeout(() => e.target.classList.add('dragging'), 0);
                        e.dataTransfer.setData('text/plain', e.target.textContent);
                        if (e.target.matches('.ordering-item')) {
                            dropIndicator = document.createElement('div');
                            dropIndicator.className = 'ordering-drop-indicator';
                        }
                    }
                });

                previewContainer.addEventListener('dragend', e => {
                    const droppedItem = e.target;

                    if (droppedItem.matches('.ordering-item')) {
                        setTimeout(() => {
                            const targetContainer = droppedItem.closest('.ordering-target-container');
                            
                            if (targetContainer) {
                                const item = targetContainer.closest('.ordering-preview-item');
                                const feedbackIcon = item.querySelector('.ordering-item-feedback');
                                const studentItems = Array.from(targetContainer.querySelectorAll('.ordering-item'));
                                const studentAnswer = studentItems.map(i => i.textContent.trim()).join(' // ');
                                const correctAnswer = decodeURIComponent(atob(item.dataset.answer));
                                const totalItemCount = correctAnswer.split('//').length;

                                if (studentAnswer === correctAnswer) {
                                    targetContainer.classList.remove('incorrect');
                                    targetContainer.classList.add('correct');
                                    if (feedbackIcon) feedbackIcon.textContent = '⭕';

                                    const quizContainer = item.closest('.ordering-preview-container');
                                    const allItems = quizContainer.querySelectorAll('.ordering-preview-item');
                                    const allCorrect = Array.from(allItems).every(i => i.querySelector('.ordering-target-container.correct'));

                                    if (allCorrect) {
                                        const feedbackEl = quizContainer.querySelector('.feedback');
                                        feedbackEl.textContent = '모두 정답입니다! 완벽해요! ✨';
                                        feedbackEl.className = 'feedback show correct';
                                        quizContainer.querySelector('.check-ordering-btn').style.display = 'none';
                                        quizContainer.querySelector('.retry-quiz-btn').style.display = 'inline-block';
                                    }
                                } else if (studentItems.length === totalItemCount) {
                                    targetContainer.classList.remove('correct');
                                    targetContainer.classList.add('incorrect');
                                    if (feedbackIcon) feedbackIcon.textContent = '❌';
                                } else {
                                    targetContainer.classList.remove('correct', 'incorrect');
                                    if (feedbackIcon) feedbackIcon.textContent = '';
                                }
                            }
                        }, 0);
                    }

                    if (currentDraggedItem) {
                        currentDraggedItem.classList.remove('dragging');
                        if (dropIndicator && dropIndicator.parentNode) {
                            dropIndicator.parentNode.removeChild(dropIndicator);
                        }
                        dropIndicator = null;
                        currentDraggedItem = null;
                    }
                });

                previewContainer.addEventListener('dragover', e => {
                    e.preventDefault();
                    const classificationDropZone = e.target.closest('.category-drop-zone, .classification-items-source');
                    if (classificationDropZone && currentDraggedItem?.matches('.classification-item-card')) {
                        classificationDropZone.classList.add('drag-over');
                    }
                    const dropTarget = e.target.closest('.drop-target');
                    const sourceContainer = e.target.closest('.source-container');
                    const orderingContainer = e.target.closest('.ordering-target-container');

                    if (dropTarget || (sourceContainer && currentDraggedItem?.parentElement.classList.contains('drop-target'))) {
                        e.target.closest('.drop-target, .source-container').classList.add('drag-over');
                    } else if (orderingContainer && currentDraggedItem?.matches('.ordering-item')) {
                        orderingContainer.classList.add('drag-over');
                        const afterElement = getDragAfterElementHorizontal(orderingContainer, e.clientX);
                        if (afterElement == null) {
                            if (orderingContainer.lastChild !== dropIndicator) orderingContainer.appendChild(dropIndicator);
                        } else {
                            if (afterElement.previousSibling !== dropIndicator) orderingContainer.insertBefore(dropIndicator, afterElement);
                        }
                    }
                });

                previewContainer.addEventListener('dragleave', e => {
                    const classificationDropZone = e.target.closest('.category-drop-zone, .classification-items-source');
                    if (classificationDropZone) {
                        classificationDropZone.classList.remove('drag-over');
                    }
                    const relatedTarget = e.relatedTarget;
                    const dropZone = e.target.closest('.drop-target, .source-container, .ordering-target-container');
                    if (dropZone && !dropZone.contains(relatedTarget)) {
                        dropZone.classList.remove('drag-over');
                    }
                    if(dropZone && dropIndicator && dropIndicator.parentNode) {
                        dropIndicator.parentNode.removeChild(dropIndicator);
                    }
                });

                previewContainer.addEventListener('drop', e => {
                    e.preventDefault();
                    if (!currentDraggedItem) return;

                    const classificationDropZone = e.target.closest('.category-drop-zone, .classification-items-source');
                    if (classificationDropZone && currentDraggedItem?.matches('.classification-item-card')) {
                        classificationDropZone.appendChild(currentDraggedItem);
                        classificationDropZone.classList.remove('drag-over');

                        const quizContainer = classificationDropZone.closest('.classification-preview-container');
                        const hasChecked = quizContainer.querySelector('.classification-item-card.correct, .classification-item-card.incorrect');
                        
                        if (hasChecked) {
                            quizContainer.querySelectorAll('.classification-item-card').forEach(card => {
                                card.classList.remove('correct', 'incorrect');
                            });
                            quizContainer.querySelector('.retry-quiz-btn').style.display = 'none';
                            quizContainer.querySelector('.check-classification-btn').style.display = 'inline-block';
                            const feedbackEl = quizContainer.querySelector('.feedback');
                            feedbackEl.className = 'feedback';
                            feedbackEl.innerHTML = '';
                        }
                    }

                    const dropTarget = e.target.closest('.drop-target');
                    const sourceContainer = e.target.closest('.source-container');
                    const orderingContainer = e.target.closest('.ordering-source-container, .ordering-target-container');

                    if (dropTarget || (sourceContainer && currentDraggedItem.parentElement.classList.contains('drop-target'))) {
                        const quizContainer = (dropTarget || sourceContainer).closest('.drag-drop-preview-container');
                        const hasChecked = quizContainer.querySelector('.drop-target.correct, .drop-target.incorrect');

                        if (hasChecked) {
                            quizContainer.querySelectorAll('.drop-target').forEach(target => {
                                target.classList.remove('correct', 'incorrect');
                            });
                            const controls = quizContainer.querySelector('.quiz-controls');
                            if (controls) {
                                controls.querySelector('.retry-quiz-btn').style.display = 'none';
                                controls.querySelector('.check-drag-drop-btn').style.display = 'inline-block';
                                const feedbackEl = controls.querySelector('.feedback');
                                feedbackEl.className = 'feedback';
                                feedbackEl.innerHTML = '';
                            }
                        }

                        if (dropTarget) {
                            dropTarget.classList.remove('drag-over');
                            const existingItem = dropTarget.querySelector('.drag-source');
                            const mainSourceContainer = quizContainer.querySelector('.source-container');
                            if (existingItem) {
                                mainSourceContainer.appendChild(existingItem);
                            }
                            dropTarget.appendChild(currentDraggedItem);
                        } else {
                            sourceContainer.classList.remove('drag-over');
                            sourceContainer.appendChild(currentDraggedItem);
                        }
                    } 
                    else if (orderingContainer) {
                        orderingContainer.classList.remove('drag-over');
                        if (dropIndicator && dropIndicator.parentNode) {
                            dropIndicator.parentNode.replaceChild(currentDraggedItem, dropIndicator);
                        } else {
                            const afterElement = getDragAfterElementHorizontal(orderingContainer, e.clientX);
                            if (afterElement == null) orderingContainer.appendChild(currentDraggedItem);
                            else orderingContainer.insertBefore(currentDraggedItem, afterElement);
                        }
                        const quizContainer = orderingContainer.closest('.ordering-preview-container');
                        if (quizContainer && orderingContainer.classList.contains('ordering-target-container')) {
                            if (orderingContainer.matches('.correct, .incorrect')) {
                                orderingContainer.classList.remove('correct', 'incorrect');
                                const controls = quizContainer.querySelector('.quiz-controls');
                                if (controls) {
                                    controls.querySelector('.retry-quiz-btn').style.display = 'none';
                                    controls.querySelector('.check-ordering-btn').style.display = 'inline-block';
                                    controls.querySelector('.feedback').className = 'feedback';
                                }
                            }
                        }
                    }
                });

                previewContainer.addEventListener('click', e => {
                    const newProverbBtn = e.target.closest('.new-proverb-btn');
                    if (newProverbBtn) {
                        const quizItem = newProverbBtn.closest('.mcq-preview-item');
                        const quizBlock = newProverbBtn.closest('.block');
                        const quizType = quizBlock.dataset.quizType;
                        const items = proverbDataCache[quizType];
                        const currentProverb = decodeURIComponent(atob(quizItem.dataset.currentProverb));

                        if (items && items.length > 1) {
                            let newIndex;
                            let newQuizData;
                            do {
                                newIndex = Math.floor(Math.random() * items.length);
                                newQuizData = items[newIndex];
                            } while (newQuizData.proverb === currentProverb);
                            
                            renderQuizContent(newQuizData, items, quizBlock);
                        }
                        return;
                    }

                    const clozeChoice = e.target.closest('.cloze-choice');
                    if (clozeChoice) {
                        const container = clozeChoice.closest('.interactive-cloze-container');
                        if (container.classList.contains('answered') || clozeChoice.classList.contains('used')) return;

                        const blank = container.querySelector('.cloze-blank');
                        const studentAnswer = clozeChoice.textContent.trim();
                        const correctAnswer = decodeURIComponent(atob(container.dataset.answer));

                        blank.textContent = studentAnswer;
                        blank.classList.add('filled');
                        blank.classList.remove('incorrect');

                        if (studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                            blank.classList.add('correct');
                            container.classList.add('answered');
                            container.querySelectorAll('.cloze-choice').forEach(choice => {
                                choice.classList.add('used');
                            });
                        } else {
                            blank.classList.add('incorrect');
                            clozeChoice.classList.add('used');
                        }
                        return;
                    }

                    const filledBlank = e.target.closest('.cloze-blank.filled');
                    if (filledBlank && filledBlank.classList.contains('correct')) {
                        const container = filledBlank.closest('.interactive-cloze-container');
                        container.classList.remove('answered');
                        filledBlank.innerHTML = '&nbsp;';
                        filledBlank.className = 'cloze-blank';
                        container.querySelectorAll('.cloze-choice').forEach(choice => {
                            choice.classList.remove('used');
                        });
                        return;
                    }

                    const cloze = e.target.closest('.revealable-cloze');
                    const revealed = e.target.closest('.revealed-answer');
                    if (cloze) {
                        const answer = decodeURIComponent(atob(cloze.dataset.answer));
                        cloze.textContent = answer;
                        cloze.className = 'revealed-answer';
                        return;
                    }
                    if (revealed) {
                        const hint = decodeURIComponent(atob(revealed.dataset.hint));
                        revealed.textContent = hint;
                        revealed.className = 'revealable-cloze';
                        return;
                    }
                    const summary = e.target.closest('.frame-preview-summary, .summary-preview-summary, .text-preview-summary');
                    if (summary) {
                        e.preventDefault();
                        const details = summary.parentElement;
                        details.open = !details.open;
                        return;
                    }
                    const retryBtn = e.target.closest('.retry-quiz-btn');
                    const checkAnswerBtn = e.target.closest('.check-answer-btn');
                    const checkFillInBtn = e.target.closest('.check-fill-in-btn');
                    const checkLineQuizBtn = e.target.closest('.check-line-quiz-btn');
                    const checkDragDropBtn = e.target.closest('.check-drag-drop-btn');
                    const checkOrderingBtn = e.target.closest('.check-ordering-btn');
                    const checkClassificationBtn = e.target.closest('.check-classification-btn');
                    const youtubePlaceholder = e.target.closest('.youtube-placeholder');

                    if (retryBtn) {
                        const quizContainer = retryBtn.closest('.quiz-container, .mcq-preview-item, .descriptive-preview-item, .fill-in-container, .table-preview-container, .drag-drop-preview-container, .ordering-preview-container, .classification-preview-container, .text-content-container, .text-preview-container, .block[data-type="flowchart"]');
                        if (quizContainer) {
                            quizContainer.dataset.attempts = "0";
                            const controls = quizContainer.querySelector('.quiz-controls');
                            if (controls && controls.querySelector('.feedback')) {
                                controls.querySelector('.feedback').className = 'feedback';
                                controls.querySelector('.feedback').innerHTML = '';
                            }
                            quizContainer.querySelectorAll('.explanation').forEach(el => { el.className = 'explanation'});
                            
                            if (quizContainer.querySelector('.ox-preview-item')) {
                                quizContainer.querySelectorAll('.ox-preview-item .feedback').forEach(fb => {
                                    fb.className = 'feedback';
                                    fb.innerHTML = '';
                                });
                                quizContainer.querySelectorAll('.ox-choices button').forEach(btn => btn.classList.remove('selected'));
                            }
                            
                            if(quizContainer.classList.contains('mcq-preview-item')) { 
                                quizContainer.dataset.attempts = "0";
                                quizContainer.querySelectorAll('.mcq-preview-option').forEach(opt => {
                                    opt.classList.remove('selected', 'correct', 'incorrect');
                                });
                                retryBtn.style.display = 'none';
                                if (controls) controls.style.display = 'none';
                                const explanation = quizContainer.querySelector('.explanation');
                                if (explanation) explanation.classList.remove('show');
                            }
                            if(quizContainer.classList.contains('descriptive-preview-item')) {
                                const studentAnswerEl = quizContainer.querySelector('.descriptive-student-answer');
                                studentAnswerEl.value = '';
                                studentAnswerEl.disabled = false;
                                quizContainer.querySelector('.check-answer-btn').style.display = 'inline-block';
                                retryBtn.style.display = 'none';
                            }
                            
                            const blankInputs = quizContainer.querySelectorAll('.blank-input-preview');
                            if (blankInputs.length > 0) {
                                blankInputs.forEach(input => {
                                    input.value = '';
                                    input.disabled = false;
                                    input.className = 'blank-input-preview';
                                });
                                const checkBtn = quizContainer.querySelector('.check-fill-in-btn');
                                if (checkBtn) checkBtn.style.display = 'inline-block';
                                retryBtn.style.display = 'none';
                            }

                            const lineQuizPreview = quizContainer.querySelector('.line-quiz-preview');
                            if(lineQuizPreview && lineQuizPreview.lineQuizInstance){
                                lineQuizPreview.lineQuizInstance.reset();
                                retryBtn.style.display = 'none';
                                quizContainer.querySelector('.check-line-quiz-btn').style.display = 'inline-block';
                            }
                            if (quizContainer.classList.contains('drag-drop-preview-container')) {
                                const sourceContainer = quizContainer.querySelector('.source-container');
                                const allWords = [];
                                quizContainer.querySelectorAll('.drop-target').forEach(target => {
                                    if (target.textContent.trim()) { allWords.push(target.textContent.trim()); }
                                    target.textContent = '';
                                    target.className = 'drop-target';
                                });
                                sourceContainer.querySelectorAll('.drag-source').forEach(source => { allWords.push(source.textContent.trim()); });
                                const originalAnswers = Array.from(quizContainer.querySelectorAll('.drop-target')).map(t => t.dataset.answer);
                                while(allWords.length < originalAnswers.length) {
                                    const wordCount = allWords.reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
                                    const originalWordCount = originalAnswers.reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
                                    let missingWordFound = false;
                                    for(const word in originalWordCount) {
                                        if((wordCount[word] || 0) < originalWordCount[word]) {
                                            allWords.push(word); missingWordFound = true; break;
                                        }
                                    }
                                    if (!missingWordFound) break;
                                }
                                sourceContainer.innerHTML = '';
                                shuffle(allWords).forEach(word => {
                                    const newSource = document.createElement('span');
                                    newSource.className = 'drag-source'; newSource.draggable = true; newSource.textContent = word;
                                    sourceContainer.appendChild(newSource);
                                });
                                retryBtn.style.display = 'none';
                                quizContainer.querySelector('.check-drag-drop-btn').style.display = 'inline-block';
                            }
                            if (quizContainer.classList.contains('ordering-preview-container')) {
                                quizContainer.querySelectorAll('.ordering-preview-item').forEach(item => {
                                    const sourceContainer = item.querySelector('.ordering-source-container');
                                    const targetContainer = item.querySelector('.ordering-target-container');
                                    const allItemsForThisQuestion = Array.from(item.querySelectorAll('.ordering-item'));
                                    shuffle(allItemsForThisQuestion).forEach(card => sourceContainer.appendChild(card));
                                    targetContainer.className = 'ordering-target-container';
                                    const feedbackIcon = item.querySelector('.ordering-item-feedback');
                                    if(feedbackIcon) feedbackIcon.textContent = '';
                                });
                                retryBtn.style.display = 'none';
                                quizContainer.querySelector('.check-ordering-btn').style.display = 'inline-block';
                            }
                            if (quizContainer.classList.contains('classification-preview-container')) {
                                const sourceContainer = quizContainer.querySelector('.classification-items-source');
                                const allCards = Array.from(quizContainer.querySelectorAll('.classification-item-card'));
                                allCards.forEach(card => {
                                    card.classList.remove('correct', 'incorrect');
                                });
                                shuffle(allCards).forEach(card => {
                                    sourceContainer.appendChild(card);
                                });
                                retryBtn.style.display = 'none';
                                quizContainer.querySelector('.check-classification-btn').style.display = 'inline-block';
                            }
                        }
                    } else if (checkAnswerBtn) {
                        const item = checkAnswerBtn.closest('.descriptive-preview-item');
                        const studentAnswerEl = item.querySelector('.descriptive-student-answer');
                        const studentAnswer = studentAnswerEl.value.trim();
                        const feedbackEl = item.querySelector('.feedback');
                        const retryBtnItem = item.querySelector('.retry-quiz-btn');
                        const encodedAnswers = item.dataset.answers;
                        const correctAnswers = JSON.parse(decodeURIComponent(atob(encodedAnswers)));
                        if (!studentAnswer) { alert('답을 입력해주세요!'); return; }
                        const isCorrect = correctAnswers.some(ans => ans.toLowerCase() === studentAnswer.toLowerCase());
                        feedbackEl.className = 'feedback show ' + (isCorrect ? 'correct' : 'incorrect');
                        feedbackEl.innerHTML = isCorrect ? '<span class="correct-highlight">정답!</span> 훌륭해요! 👍' : '<strong>모범 정답:</strong> ' + correctAnswers.join(', ');
                        studentAnswerEl.disabled = true;
                        checkAnswerBtn.style.display = 'none';
                        retryBtnItem.style.display = 'inline-block';
                    } else if (checkFillInBtn) {
                        const container = checkFillInBtn.closest('.fill-in-container, .table-preview-container, .text-content-container, .text-preview-container, .block[data-type="flowchart"]');
                        const feedbackEl = container.querySelector('.feedback');
                        let attempts = parseInt(container.dataset.attempts || "0", 10);
                        attempts++;
                        container.dataset.attempts = attempts;
                        let allCorrect = true;
                        
                        container.querySelectorAll('.blank-input-preview').forEach(inputEl => {
                            const studentAnswer = inputEl.value.trim();
                            const correctAnswer = decodeURIComponent(atob(inputEl.dataset.answer));
                            if (studentAnswer && studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                                inputEl.className = 'blank-input-preview correct';
                            } else {
                                inputEl.className = 'blank-input-preview incorrect';
                                allCorrect = false;
                            }
                        });
                        
                        if (allCorrect) {
                            feedbackEl.textContent = '모두 정답입니다!';
                            feedbackEl.className = 'feedback show correct';
                        } else {
                            if (attempts < 2) {
                                feedbackEl.textContent = '아쉬워요. 틀린 문제를 다시 풀어보세요!';
                                feedbackEl.className = 'feedback show incorrect';
                                container.querySelectorAll('.blank-input-preview.incorrect').forEach(input => input.value = '');
                                return; 
                            } else {
                                feedbackEl.textContent = '정답을 확인하세요.';
                                feedbackEl.className = 'feedback show incorrect';
                                container.querySelectorAll('.blank-input-preview.incorrect').forEach(input => {
                                    input.value = decodeURIComponent(atob(input.dataset.answer));
                                    input.disabled = true;
                                });
                            }
                        }
                        checkFillInBtn.style.display = 'none';
                        container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
                    } else if (checkLineQuizBtn) {
                        const quizEl = checkLineQuizBtn.closest('.quiz-container').querySelector('.line-quiz-preview');
                        if (quizEl && quizEl.lineQuizInstance) {
                            quizEl.lineQuizInstance.checkAnswers();
                            checkLineQuizBtn.style.display = 'none';
                            checkLineQuizBtn.nextElementSibling.style.display = 'inline-block';
                        }
                    } else if (checkOrderingBtn) {
                        const container = checkOrderingBtn.closest('.ordering-preview-container');
                        const feedbackEl = container.querySelector('.feedback');
                        let allCorrect = true;

                        container.querySelectorAll('.ordering-preview-item').forEach(item => {
                            const targetContainer = item.querySelector('.ordering-target-container');
                            const feedbackIcon = item.querySelector('.ordering-item-feedback');
                            const studentItems = Array.from(targetContainer.querySelectorAll('.ordering-item')).map(i => i.textContent.trim());
                            const studentAnswer = studentItems.join(' // ');
                            const correctAnswer = decodeURIComponent(atob(item.dataset.answer));

                            if (studentAnswer === correctAnswer) {
                                targetContainer.classList.remove('incorrect');
                                targetContainer.classList.add('correct');
                                if(feedbackIcon) feedbackIcon.textContent = '⭕';
                            } else {
                                targetContainer.classList.remove('correct');
                                targetContainer.classList.add('incorrect');
                                if(feedbackIcon) feedbackIcon.textContent = '❌';
                                allCorrect = false;
                            }
                        });

                        if (allCorrect) {
                            feedbackEl.textContent = '모두 정답입니다! 완벽해요! ✨';
                            feedbackEl.className = 'feedback show correct';
                        } else {
                            feedbackEl.textContent = '아쉬워요. ❌ 표시된 문제를 다시 확인해보세요.';
                            feedbackEl.className = 'feedback show incorrect';
                        }

                        checkOrderingBtn.style.display = 'none';
                        container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
                    } else if (checkDragDropBtn) {
                        const container = checkDragDropBtn.closest('.drag-drop-preview-container');
                        const feedbackEl = container.querySelector('.feedback');
                        let allCorrect = true;
                        container.querySelectorAll('.drop-target').forEach(target => {
                            const studentAnswer = target.textContent.trim();
                            const correctAnswer = target.dataset.answer;
                            if (studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                                target.className = 'drop-target correct';
                            } else {
                                target.className = 'drop-target incorrect';
                                allCorrect = false;
                            }
                        });
                        if (allCorrect) {
                            feedbackEl.textContent = '모두 정답입니다!';
                            feedbackEl.className = 'feedback show correct';
                        } else {
                            feedbackEl.textContent = '아쉬워요. 틀린 문제가 있는지 확인해보세요.';
                            feedbackEl.className = 'feedback show incorrect';
                        }
                        checkDragDropBtn.style.display = 'none';
                        container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
                    } else if (checkClassificationBtn) {
                        const container = checkClassificationBtn.closest('.classification-preview-container');
                        const feedbackEl = container.querySelector('.feedback');
                        let allCorrect = true; 

                        const sourceContainer = container.querySelector('.classification-items-source');
                        if (sourceContainer.querySelector('.classification-item-card')) {
                            allCorrect = false; 
                        }

                        container.querySelectorAll('.classification-category-bin').forEach(bin => {
                            const categoryName = bin.querySelector('.category-drop-zone').dataset.categoryName;
                            bin.querySelectorAll('.classification-item-card').forEach(card => {
                                if (card.dataset.correctCategory.trim() === categoryName.trim()) {
                                    card.classList.add('correct');
                                    card.classList.remove('incorrect');
                                } else {
                                    card.classList.add('incorrect');
                                    card.classList.remove('correct');
                                    allCorrect = false; 
                                }
                            });
                        });

                        if (allCorrect) {
                            feedbackEl.textContent = '모두 정확하게 분류했습니다! 완벽해요! ✨';
                            feedbackEl.className = 'feedback show correct';
                        } else {
                            feedbackEl.textContent = '아쉬워요. 잘못 분류되었거나, 분류하지 않은 항목이 있습니다.';
                            feedbackEl.className = 'feedback show incorrect';
                        }
                        checkClassificationBtn.style.display = 'none';
                        container.querySelector('.retry-quiz-btn').style.display = 'inline-block';
                    } else if (youtubePlaceholder) {
                        const videoId = youtubePlaceholder.dataset.videoId;
                        if(videoId) {
                            const iframeWrapper = document.createElement('div');
                            iframeWrapper.className = 'youtube-iframe-wrapper';
                            iframeWrapper.dataset.videoId = videoId;
                            iframeWrapper.innerHTML = '<button class="youtube-close-btn" title="영상 닫기">&times;</button><iframe src="https://www.youtube.com/embed/' + videoId + '?autoplay=1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>';
                            youtubePlaceholder.replaceWith(iframeWrapper);
                        }
                    } else {
                        const youtubeCloseBtn = e.target.closest('.youtube-close-btn');
                        if (youtubeCloseBtn) {
                            const iframeWrapper = youtubeCloseBtn.parentElement;
                            const videoId = iframeWrapper.dataset.videoId;
                            if(videoId) {
                                const placeholder = document.createElement('div');
                                placeholder.className = 'youtube-placeholder';
                                placeholder.dataset.videoId = videoId;
                                placeholder.innerHTML = '🎬<div class="youtube-placeholder-text">클릭하여 영상 보기</div>';
                                iframeWrapper.replaceWith(placeholder);
                            }
                        } else {
                            const oxChoiceBtn = e.target.closest('.ox-choices button');
                            const mcqOptionDiv = e.target.closest('.mcq-preview-option');
                            const explainable = e.target.closest('.explainable');
                            if (oxChoiceBtn) {
                                const item = oxChoiceBtn.closest('.ox-preview-item');
                                const choicesDiv = item.querySelector('.ox-choices');
                                const choice = oxChoiceBtn.dataset.choice;
                                const answer = choicesDiv.dataset.answer;
                                const feedbackEl = item.querySelector('.feedback');
                                feedbackEl.className = 'feedback show ' + (choice === answer ? 'correct' : 'incorrect');
                                feedbackEl.innerHTML = choice === answer ? '<span class="correct-highlight">정답!</span> 참 잘했어요! ✨' : '<span class="incorrect-highlight">아쉬워요.</span> 다시 생각해 볼까요? 🤔';
                            } else if (mcqOptionDiv) {
                                const item = mcqOptionDiv.closest('.mcq-preview-item');
                                const controls = item.querySelector('.quiz-controls');
                                if (controls) controls.style.display = 'flex';
                                
                                let attempts = parseInt(item.dataset.attempts, 10);
                                if (item.querySelector('.feedback').classList.contains('correct') || attempts >= 2) return;
                                attempts++;
                                item.dataset.attempts = attempts;
                                const choice = mcqOptionDiv.dataset.choice;
                                const answer = item.dataset.answer;
                                const feedbackEl = item.querySelector('.feedback');
                                const explanationEl = item.querySelector('.explanation');
                                const isCorrect = (choice === answer);

                                if (isCorrect) {
                                    feedbackEl.className = 'feedback show correct';
                                    feedbackEl.innerHTML = '<span class="correct-highlight">정답!</span> 훌륭해요, 💯';
                                    item.dataset.attempts = 2;
                                    if(explanationEl) explanationEl.className = 'explanation show';
                                } else {
                                    feedbackEl.className = 'feedback show incorrect';
                                    if (attempts < 2) {
                                        feedbackEl.innerHTML = '<span class="incorrect-highlight">아쉬워요.</span> 한 번 더 신중하게 풀어보세요!';
                                    } else {
                                        feedbackEl.innerHTML = '<span class="incorrect-highlight">오답!</span> 정답은 ' + answer + '번 💪';
                                        if(explanationEl) explanationEl.className = 'explanation show';
                                    }
                                }
                                if(explanationEl.classList.contains('show')) {
                                    try {
                                        const decodedExplanation = decodeURIComponent(atob(item.dataset.explanation));
                                        if (decodedExplanation.trim()) explanationEl.innerHTML = '<strong>해설:</strong> ' + decodedExplanation;
                                    } catch(err) {}
                                }

                                if (isCorrect || attempts >= 2) {
                                    const retryButton = item.querySelector('.retry-quiz-btn');
                                    if (retryButton) retryButton.style.display = 'inline-block';
                                }
                            } else if (explainable) {
                                explanationPopup.innerHTML = explainable.dataset.explanation + '<button class="popup-close-btn" title="닫기">&times;</button>';
                                const rect = explainable.getBoundingClientRect();
                                explanationPopup.style.top = (rect.bottom + window.scrollY + 12) + 'px';
                                explanationPopup.style.left = (rect.left + window.scrollX) + 'px';
                                explanationPopup.classList.add('show');
                                e.stopPropagation();
                            }
                        }
                    }
                });
                document.addEventListener('click', e => { 
                    if (!e.target.closest('.explainable') && !e.target.closest('.explanation-popup')) {
                        explanationPopup.classList.remove('show');
                    }
                });
                explanationPopup.addEventListener('click', e => {
                    if (e.target.classList.contains('popup-close-btn')) {
                        explanationPopup.classList.remove('show');
                    }
                });
                
                initializeAllInteractiveBlocks();
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise();
                }
                document.querySelectorAll('.tab-content').forEach(adjustBlankInputWidths);
            });
            `;
        }


                    // ✅ 이 코드를 initialize(); 바로 위에 추가해주세요.
                    function showExplanationModal(selectedText, existingExplanation = '') {
                    const modalHtml = `
                        <div id="explanation-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 2000;">
                            <div style="background: white; padding: 0; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 600px;"> 
                                <div class="explanation-modal-header">
                                    <b>구절풀이 입력</b>: <span class="selected-text-display">${selectedText}</span>
                                </div>
                                <div style="padding: 15px 25px;">
                                    <div id="explanation-emoji-palette">
                                        <span class="modal-emoji" title="책">📒</span>
                                        <span class="modal-emoji" title="설명">💬</span>
                                        <span class="modal-emoji" title="중요">✨</span>
                                        <span class="modal-emoji" title="아이디어">💡</span>
                        <span class="modal-emoji" title="핀">📍</span>
                                        <span class="modal-emoji" title="중요">📌</span>
                                        <span class="modal-emoji" title="마름모파">💠</span>
                                        <span class="modal-emoji" title="마름모주">🔸</span>
                                        <span class="modal-emoji" title="네모흑">▪️</span>
                                        <span class="modal-emoji" title="괄호">『』</span>
                                        <span class="modal-emoji" title="질문">❓</span>
                                        <span class="modal-emoji" title="느낌">❗</span>
                                        <span class="modal-emoji" title="확인">✅</span>
                                        <span class="modal-emoji" title="참고">➡️</span>
                                    </div>
                                    <div class="mini-toolbar">
                                        <button data-command="removeFormat" title="서식 지우기"><s>A</s></button>
                                        <button data-command="bold" title="굵게"><b>B</b></button>
                                        <button class="color-swatch" data-command="backColor" data-value="#FFFACD" style="background-color:#FFFACD;" title="연노랑"></button>
                                        <button class="color-swatch" data-command="backColor" data-value="#D2EAFF" style="background-color:#D2EAFF;" title="연파랑"></button>
                                        <button class="color-swatch" data-command="backColor" data-value="#FFD6D6" style="background-color:#FFD6D6;" title="연빨강"></button>
                                    </div>
                                    <div id="explanation-modal-input" contenteditable="true" style="width: 100%; height: 100px; border: 1px solid #ccc; border-radius: 4px; padding: 8px; box-sizing: border-box; font-family: 'Malgun Gothic', sans-serif; font-size: 1em; overflow-y: auto;">${existingExplanation}</div>

                                    <small style="display: block; margin-top: 8px; color: #888; font-size: 0.8em;">내용을 입력하시거나 링크 주소를 입력하세요.</small>
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px 25px; border-top: 1px solid #eee;">
                                    <button id="explanation-modal-delete" style="padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #f0f0f0; color: var(--incorrect-color);">삭제</button>
                                    <div>
                                        <button id="explanation-modal-cancel" style="padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; margin-right: 10px; background: #f0f0f0;">취소</button>
                                        <button id="explanation-modal-ok" style="padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; background: var(--primary-color); color: white;">확인</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    document.body.insertAdjacentHTML('beforeend', modalHtml);
                    const inputDiv = document.getElementById('explanation-modal-input');
                    inputDiv.focus();

                    let modalSelectionRange = null;

                    const saveSelectionInModal = () => {
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0 && selection.anchorNode && inputDiv.contains(selection.anchorNode)) {
                            modalSelectionRange = selection.getRangeAt(0);
                        }
                    };

                    inputDiv.addEventListener('keyup', saveSelectionInModal);
                    inputDiv.addEventListener('mouseup', saveSelectionInModal);
                    inputDiv.addEventListener('focus', saveSelectionInModal);

                    document.querySelector('.mini-toolbar').addEventListener('mousedown', e => {
                        const button = e.target.closest('button');
                        if (!button) return;

                        e.preventDefault();
                        inputDiv.focus();
                        if (modalSelectionRange) {
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(modalSelectionRange);
                        }

                        const command = button.dataset.command;
                        const value = button.dataset.value || null;
                        document.execCommand(command, false, value);
                    });

                    document.getElementById('explanation-emoji-palette').addEventListener('mousedown', e => {
                        if (e.target.classList.contains('modal-emoji')) {
                            e.preventDefault();
                            const emoji = e.target.textContent;
                            document.execCommand('insertText', false, emoji);
                        }
                    });

                    return new Promise((resolve) => {
                        const modal = document.getElementById('explanation-modal');
                        const okBtn = document.getElementById('explanation-modal-ok');
                        const cancelBtn = document.getElementById('explanation-modal-cancel');
                        const deleteBtn = document.getElementById('explanation-modal-delete');

                        const closeModal = (result) => {
                            modal.remove();
                            resolve(result);
                        };

                        okBtn.onclick = () => closeModal(inputDiv.innerHTML);
                        cancelBtn.onclick = () => closeModal(null);
                        deleteBtn.onclick = () => closeModal(''); // 삭제 시 빈 문자열을 반환
                    });
                }

                // --- 맨 위로 가기 버튼 기능 ---
                const scrollToTopBtn = document.getElementById('scrollToTopBtn');
                if (scrollToTopBtn) {
                    // ✅ 스크롤 감지 대상을 'window'로 변경
                    window.addEventListener('scroll', () => {
                        // ✅ document.documentElement.scrollTop으로 변경하여 페이지 전체 스크롤 감지
                        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
                            scrollToTopBtn.classList.add('show');
                        } else {
                            scrollToTopBtn.classList.remove('show');
                        }
                    });
                    // ✅ 클릭 시 스크롤 대상을 'window'로 변경
                    scrollToTopBtn.addEventListener('click', () => {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    });
                }

                // --- 분류하기 퀴즈 헬퍼 함수 ---
        function addClassificationCategory(container, name = '') {
            const newCategory = document.createElement('div');
            newCategory.className = 'classification-category-editor-row';
            newCategory.innerHTML = `
                <input type="text" placeholder="카테고리 이름" value="${name}">
                <button class="delete-classification-category" title="카테고리 삭제">&times;</button>
            `;
            container.appendChild(newCategory);
        }

        function addClassificationItem(container, text = '') {
            const newItem = document.createElement('div');
            newItem.className = 'classification-item-editor-row';
            newItem.innerHTML = `
                <input type="text" class="item-text-input" placeholder="항목(카드) 내용" value="${text}">
                <select class="item-category-select"></select>
                <button class="delete-classification-item" title="항목 삭제">&times;</button>
            `;
            container.appendChild(newItem);
        }

        function updateAllCategoryDropdowns(block) {
            // 1. 에디터에서 현재 카테고리 이름들을 모두 가져옵니다.
            const categoryInputs = block.querySelectorAll('.classification-category-editor-row input');
            const categories = Array.from(categoryInputs).map(input => input.value.trim()).filter(Boolean);

            // 2. 모든 항목의 드롭다운 메뉴를 가져옵니다.
            const itemDropdowns = block.querySelectorAll('.classification-item-editor-row .item-category-select');

            itemDropdowns.forEach(dropdown => {
                // 3. 중요: 목록을 업데이트하기 전, 현재 선택된 값을 정확히 저장합니다.
                const previouslySelectedValue = dropdown.value;

                // 4. 드롭다운의 모든 옵션을 깨끗하게 비웁니다.
                dropdown.innerHTML = '';

                // 5. 카테고리가 없으면 안내 문구를 표시합니다.
                if (categories.length === 0) {
                    dropdown.innerHTML = `<option>카테고리를 먼저 만드세요</option>`;
                    return; // 다음 드롭다운으로 넘어갑니다.
                }

                let selectionFound = false;
                // 6. 새로운 카테고리 목록으로 옵션을 다시 만듭니다.
                categories.forEach(catName => {
                    const option = document.createElement('option');
                    option.value = catName;
                    option.textContent = catName;
                    dropdown.appendChild(option);

                    // 7. 새로 만든 옵션이 이전에 선택했던 값과 일치하는지 확인합니다.
                    if (catName === previouslySelectedValue) {
                        option.selected = true; // 일치하면 '선택됨' 상태로 만듭니다.
                        selectionFound = true;
                    }
                });

                // 8. 만약 이전에 선택했던 카테고리가 삭제되거나 이름이 바뀌어서
                //    일치하는 것을 찾지 못했다면, 안전하게 첫 번째 옵션을 선택합니다.
                if (!selectionFound && dropdown.options.length > 0) {
                    dropdown.selectedIndex = 0;
                }
            });
            }

            // --- 앱 시작 ---

            initialize();
        });
        </script>
</body>
</html>


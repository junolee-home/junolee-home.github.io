<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>공통국어2 봄봄</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 20px; font-family: 'Inter', sans-serif; line-height: 1.8; background-color: #f3f4f6; color: #374151; font-size: 12pt; }
        .container { max-width: 800px; margin: 20px auto; padding: 30px; background-color: #ffffff; border-radius: 12px; border: 1px solid #e5e7eb; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); }
        .header-section { background-color: #f9fafb; padding: 20px 30px; margin: -30px -30px 20px -30px; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom: 1px solid #e5e7eb; text-align: center; }
        .header-section h1 { font-size: 1.875rem; font-weight: 700; color: #1f2937; }
        .header-section .author-text { font-size: 1.125rem; color: #4b5563; }
        blockquote { margin: 1em 0; padding: 1rem; border-left-width: 4px; border-color: #d1d5db; font-style: normal; color: #4b5563; background-color: #f3f4f6; border-radius: 8px; white-space: pre-wrap; }
        p { margin-bottom: 1em; }
        p:last-child { margin-bottom: 0; }
        mark { padding: 0.2em 0.4em; border-radius: 4px; }
        .footer-text { text-align: right; color: #6b7280; margin-top: 30px; font-size: 0.9em; }
        .interactive-abbr { text-decoration: underline dotted; cursor: pointer; color: #1e40af; font-weight: 600; transition: color 0.2s; }
        .interactive-abbr:hover { color: #F97316; }
        .ox-choice { display: inline-flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color .2s; }
        .problem-wrapper{margin:16px 0;padding:20px;border:2px solid;border-radius:12px}.problem-header{font-size:1.1em;font-weight:700;color:#1e3a8a;margin:-20px -20px 16px;padding:12px 20px;background-color:#fff;border-bottom:2px solid;border-top-left-radius:10px;border-top-right-radius:10px}.problem-example-box{margin:12px 0;padding:12px;border:1px solid #e5e7eb;border-radius:6px;background-color:#fff;font-size:.95em;color:#4b5563}.problem-choices .choice-item{display:flex;align-items:center;margin:1px 0;padding:5px 8px;border-radius:4px;cursor:pointer;transition:background-color .2s,transform .2s}.problem-choices .choice-item:hover{background-color:#eef2ff;transform:translateX(2px)}.problem-choices .choice-item.correct{background-color:#dcfce7!important;color:#166534;font-weight:700}.problem-choices .choice-item.incorrect{background-color:#fee2e2;color:#991b1b}.problem-choices .choice-item .choice-text{text-decoration:none}.problem-choices .choice-item.incorrect .choice-text{text-decoration:line-through}.problem-answer-section{margin-top:16px;padding-top:12px;border-top:1px dashed #d1d5db;font-size:.95em;color:#4b5563}.feedback-message-box{margin-top:12px;padding:10px;border-radius:6px;font-weight:700;text-align:center}.essay-answer-input{width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;min-height:80px;margin-top:8px;font-family:inherit;font-size:inherit;color:inherit;line-height:inherit}.check-problem-btn{background-color:#60a5fa;color:#fff;padding:8px 12px;border:none;border-radius:6px;cursor:pointer;transition:background-color .2s;white-space:nowrap}.check-problem-btn:hover{background-color:#3b82f6}.check-problem-btn:disabled{background-color:#a5b4fc;cursor:not-allowed}.blank-input{border:1px solid #9ca3af;border-radius:4px;padding:2px 4px;text-align:center;width:100px;margin:0 4px}.blank-input.correct{background-color:#dcfce7;border-color:#16a34a}.blank-input.incorrect{background-color:#fee2e2;border-color:#dc2626}.toggle-wrapper{margin:16px 0;border:2px solid;border-radius:12px;transition:background-color .2s;overflow:hidden}.toggle-title{cursor:pointer;padding:12px 20px;font-weight:600;color:#374151;display:flex;justify-content:space-between;align-items:center;list-style:none;background-color:#fff}.toggle-wrapper[open]>.toggle-title{border-bottom:2px solid}.toggle-title::-webkit-details-marker{display:none}.toggle-title::after{content:"▶";font-size:.8em;transition:transform .2s}.toggle-wrapper[open]>.toggle-title::after{transform:rotate(90deg)}.toggle-content{padding:20px;color:#4b5563}.custom-table{width:100%;border-collapse:collapse}.custom-table th,.custom-table td{border:1px solid #93c5fd;padding:8px 12px;text-align:left;vertical-align:top}.custom-table th{background-color:#dbeafe;font-weight:700}.ox-choice.correct{background-color:#dcfce7!important;border-color:#16a34a!important;color:#166534!important}.ox-choice.incorrect{background-color:#fee2e2!important;border-color:#dc2626!important;color:#991b1b!important}.problem-wrapper[data-type=ox-quiz] ol{list-style:none;padding-left:0}.ox-quiz-item{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid #e5e7eb}.ox-quiz-item:last-child{border-bottom:none}.ox-quiz-item .flex-grow{flex-grow:1}.ox-choices{display:flex;align-items:center;gap:8px;margin-left:16px;flex-shrink:0}.ox-choice{width:48px;height:48px;font-size:1.5rem;border-radius:9999px;display:inline-flex;align-items:center;justify-content:center;font-weight:700;background-color:#e5e7eb;color:#4b5563;cursor:pointer;transition:background-color .2s,transform .2s;border:none}.ox-choice:hover{transform:scale(1.05)}.problem-header.flex-header{display:flex;justify-content:space-between;align-items:center}.retry-btn{font-size:1.2rem;background-color:#e5e7eb;color:#374151;border-radius:9999px;padding:8px;line-height:1;border:none;cursor:pointer}.retry-btn:hover{background-color:#d1d5db}.media-wrapper{width:80%;margin:24px auto}.youtube-container{position:relative;overflow:hidden;width:100%;padding-top:56.25%}.youtube-container iframe{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%;border:none;border-radius:12px}.line-drawing-container{position:relative;display:flex;justify-content:space-between;align-items:flex-start;padding:20px 0;touch-action:none}.line-drawing-canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0}.line-drawing-list{display:flex;flex-direction:column;gap:16px;z-index:1;width:45%}.line-drawing-item{display:flex;align-items:center;padding:12px 0;border:none;background-color:transparent;font-size:1em}.line-drawing-list.left .line-drawing-item{flex-direction:row;justify-content:space-between}.line-drawing-list.right .line-drawing-item{flex-direction:row;justify-content:flex-start;gap:12px}.line-drawing-item-text{flex-grow:1}.line-drawing-list.left .line-drawing-item-text{text-align:right;margin-right:12px}.line-drawing-list.right .line-drawing-item-text{text-align:left}.connection-point{width:14px;height:14px;background-color:#cbd5e1;border-radius:50%;cursor:pointer;transition:background-color .2s;flex-shrink:0}.connection-point:hover,.connection-point.selected{background-color:#3b82f6}.line-drawing-controls{text-align:right;margin-top:16px}
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section"><h1><i class="fas fa-language mr-2"></i> 공통국어2 봄봄</h1><div class="author-text">지은이: 김유정정</div></div>
        <div class="main-content-body">[학습 전에]<br><hr style="height:3px; border:none; background-color:#a7f3d0;"><br><br><!-- [유튜브] --><br><div class="media-wrapper"><div class="youtube-container"><iframe src="https://www.youtube.com/embed/mNF0dadHVLM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></div><br><br><!-- [더보기] 제목 〈봄봄〉의 의미 --><br><details class="toggle-wrapper" data-type="toggle-content" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">📖 제목 〈봄봄〉의 의미</span></summary><div class="toggle-content">소설의 '<mark style="background-color: #fecaca;">계절적 배경</mark> + <mark style="background-color: #fecaca;">봄날에 피어나는 사춘기 남녀의 사랑</mark>'을 인생의 봄으로 나타냄</div></details><br><br><div style="text-align: center;">●<br>●<br>●</div><br><br><br><!-------------------- 본문 ---------------------><br>  “<span class="interactive-abbr" data-title="😡장인과 '나'의 갈등의 근본적 원인." data-original-text="부려만 먹구 왜 성례 안 하지유!">부려만 먹구 왜 성례 안 하지유!</span>”<br>  <span class="interactive-abbr" data-title="데릴사위, 순진하고 어리숙함." data-original-text="나"><span style="font-weight: bold; border: 1px solid red; padding: 1px 3px; border-radius: 4px;">나</span></span>는 이렇게 호령했다. 하지만 <span class="interactive-abbr" data-title="'나'가 바라는 상황" data-original-text="장인님이 선뜻 오냐 낼이라두 성례시켜 주마">장인님이 선뜻 오냐 낼이라두 성례시켜 주마</span>, 했으면 나도 성가신 걸 그만두었을지 모른다. 나야 이러면 때린 건 아니니까 나중에 <span class="interactive-abbr" data-title="마름. (지주와 소작인 사이의 중간 관리자). 교활한 성격임." data-original-text="장인"><span style="font-weight: bold; border: 1px solid red; padding: 1px 3px; border-radius: 4px;">장인</span></span> 쳤다는 누명도 안 들을 터이고 얼마든지 해도 좋다. <br><!-- [더보기] '나'와 '장인'의 갈등 양상 --><br><details class="toggle-wrapper" data-type="toggle-content" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">📖 '나'와 '장인'의 갈등 양상</span></summary><div class="toggle-content"><mark style="background-color: #e5e7eb;"><b>나</b>(순진하고어리숙함) </mark> ↔️  <mark style="background-color: #e5e7eb;"><b>장인</b>(교활함)</mark></div></details><br><br>  한번은 <span class="interactive-abbr" data-title="성례를 시켜주지 않자 '나'가 장인을 논두렁 아래로 밀어 버렸기에." data-original-text="장인님이 헐떡헐떡 기어서 올라오더니"><span style="font-weight: bold; border: 2px solid #3b82f6; padding: 1px 4px; border-radius: 4px;">장인님</span>이 헐떡헐떡 기어서 올라오더니</span> <span style="font-weight: bold; border: 1px solid red; padding: 1px 3px; border-radius: 4px;">내 바짓가랑이를 요렇게 노리고서 단박 움켜잡고</span> 내달렸다. 악, 소리를 치고 나는 그만 세상이 다 팽그르 도는 것이<br>  “<span class="interactive-abbr" data-title="장인을 굴리며 호령하다가 역습을 당해 애원하는 모습. 상황이 역전됨. 해학적" data-original-text="빙장님! 빙장님! 빙장님!"><span style="font-weight: bold; border: 2px solid #3b82f6; padding: 1px 4px; border-radius: 4px;">빙장님</span>! 빙장님! 빙장님!</span>”<br>  “이 자식! 잡아먹어라, 잡아먹어!”<br>  “아! 아! <span class="interactive-abbr" data-title="장인에 대한 호칭 변화 → 웃음 유발, 해학성 고조" data-original-text="할아버지! 살려 줍쇼, 할아버지!"><span style="font-weight: bold; border: 2px solid #3b82f6; padding: 1px 4px; border-radius: 4px;">할아버지</span>! 살려 줍쇼, 할아버지!</span>”<br>하고 두 팔을 허둥지둥 내저을 적에는 이마에 진땀이 쭉 내솟고 인젠 참으로 죽나 보다 했다. 그래도 장인님은 놓질 않더니 내가 기어이 땅바닥에 쓰러져서 거의 까무러치게 되니까 놓는다. <span class="interactive-abbr" data-title="장인에 대한 적대감이 나타남." data-original-text="더럽다 더럽다.">더럽다 더럽다.</span> 이게 장인님인가.<br><br>  나는 한참을 못 일어나고 쩔쩔맸다. 그렇게 얼굴을 드니(눈에 참 아무것도 보이지 않았다.) 사지가 부르르 떨리면서 <b style="color: #ef4444; font-size: 1.125em;">나도 엉금엉금 기어가 장인님의 바짓가랑이를꽉 움키고 잡아낚았다.</b><br><br><!-- [인용블럭] --><br><details class="toggle-wrapper" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">🗣️ 구절풀이</span></summary><div class="toggle-content"><ul style="list-style-type: none; margin-left: 0; padding-left: 0; margin-top: 10px;"><li><b>부려만 먹구 왜 성례 안 하지유!</b>: 😡장인과 '나'의 갈등의 근본적 원인.</li><li><b>나</b>: 데릴사위, 순진하고 어리숙함.</li><li><b>장인님이 선뜻 오냐 낼이라두 성례시켜 주마</b>: '나'가 바라는 상황</li><li><b>장인</b>: 마름. (지주와 소작인 사이의 중간 관리자). 교활한 성격임.</li><li><b>장인님이 헐떡헐떡 기어서 올라오더니</b>: 성례를 시켜주지 않자 '나'가 장인을 논두렁 아래로 밀어 버렸기에.</li><li><b>빙장님! 빙장님! 빙장님!</b>: 장인을 굴리며 호령하다가 역습을 당해 애원하는 모습. 상황이 역전됨. 해학적</li><li><b>할아버지! 살려 줍쇼, 할아버지!</b>: 장인에 대한 호칭 변화 → 웃음 유발, 해학성 고조</li><li><b>더럽다 더럽다.</b>: 장인에 대한 적대감이 나타남.</li></ul></div></details><blockquote style="background-color: #f3f4f6; border-left: 4px solid #d1d5db; padding: 1rem; border-radius: 8px;">📝 <b style="color: #000000; font-size: 1.125em;">서로의 급소를 공격하며 싸우는 장인과 '나'</b></blockquote><br><!-- [빈칸넣기] 장인에 대한 '나'의 호칭 변화 이유 --><br><div class="problem-wrapper" data-type="fill-blank" style="background-color: #eff6ff; border-color: #93c5fd;"><div class="problem-header flex-header" style="border-color: #93c5fd;"><span>🔲 [빈칸넣기] 장인에 대한 '나'의 호칭 변화 이유</span><button class="retry-btn" title="다시 풀기">🔄</button></div><div class="space-y-2 px-5"><div class="fill-blank-item flex items-start gap-4 py-2" data-answers='["장인님","할아버지"]'><span class="fill-blank-content flex-grow" style="padding-top: 6px; text-align: left;">'나'가 장인을 부르는 호칭이 '<input type="text" class="blank-input" data-blank-index="0" /> → 빙장님 → <input type="text" class="blank-input" data-blank-index="1" />'와 같이 바뀐 이유 : 위가 상황에서 벗어나고 싶었기 때문에</blockquote></span><div class="problem-controls" style="display: flex; flex-direction: column; align-items: flex-end; min-width: 120px; flex-shrink: 0;"><button class="check-problem-btn">정답 확인</button></div></div></div></div><!-- end-problem-wrapper --><br><br><div style="text-align: center;">●<br>●<br>●</div><br><br><br>  내가 머리가 터지도록 매를 얻어맞은 것이 <span class="interactive-abbr" data-title="'나'가 장인의 바짓가랑이를 움켜잡았기 때문에" data-original-text="이 때문">이 때문</span>이다. <span class="interactive-abbr" data-title="장인의 의도를 파악하지 못하는 어수룩하고 순진한 '나'" data-original-text="그러나 여기가 또한 우리 장인님이 유달리 착한 곳이다.">그러나 여기가 또한 우리 장인님이 유달리 착한 곳이다.</span> <span class="interactive-abbr" data-title="장인이 '나'에게 이와 같이 행동한 이유를 짐작할 수 있는 부분: 뒷골의 콩밭이나 얼른 갈아라. 💬 불솜: 상처를 소독하기 위해 그을린 솜  💬 히연: 시대적 배경을 나타내는 소재(일제 강점기 때의 담배 이름)" data-original-text="여느 사람이면 사경을 주어서라도 당장 내쫓았지 터진 머리를 불솜으로 손수 지져 주고, 호주머니에 히연 한 봉을 넣어 주고 그리고">여느 사람이면 사경을 주어서라도 당장 내쫓았지 터진 머리를 불솜으로 손수 지져 주고, 호주머니에 히연 한 봉을 넣어 주고 그리고</span><br>  “<span class="interactive-abbr" data-title="장인의 회유. 감언이설" data-original-text="올 갈엔 꼭 성례를 시켜 주마. 암말 말구 가서 뒷골의 콩밭이나 얼른 갈아라.">올 갈엔 꼭 성례를 시켜 주마. 암말 말구 가서 뒷골의 콩밭이나 얼른 갈아라.</span>”하고 등을 <span class="interactive-abbr" data-title="두드려" data-original-text="뚜덕여">뚜덕여</span> 줄 사람이 누구냐.<br>  <span class="interactive-abbr" data-title="'나'의 순박함." data-original-text="나는 장인님이 너무나 고마워서 어느덧 눈물까지 났다.">나는 장인님이 너무나 고마워서 어느덧 눈물까지 났다.</span><br><br><!-- [인용블럭] --><br><details class="toggle-wrapper" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">🗣️ 구절풀이</span></summary><div class="toggle-content"><ul style="list-style-type: none; margin-left: 0; padding-left: 0; margin-top: 10px;"><li><b>이 때문</b>: '나'가 장인의 바짓가랑이를 움켜잡았기 때문에</li><li><b>그러나 여기가 또한 우리 장인님이 유달리 착한 곳이다.</b>: 장인의 의도를 파악하지 못하는 어수룩하고 순진한 '나'</li><li><b>여느 사람이면 사경을 주어서라도 당장 내쫓았지 터진 머리를 불솜으로 손수 지져 주고, 호주머니에 히연 한 봉을 넣어 주고 그리고</b>: 장인이 '나'에게 이와 같이 행동한 이유를 짐작할 수 있는 부분: 뒷골의 콩밭이나 얼른 갈아라. 💬 불솜: 상처를 소독하기 위해 그을린 솜  💬 히연: 시대적 배경을 나타내는 소재(일제 강점기 때의 담배 이름)</li><li><b>올 갈엔 꼭 성례를 시켜 주마. 암말 말구 가서 뒷골의 콩밭이나 얼른 갈아라.</b>: 장인의 회유. 감언이설</li><li><b>뚜덕여</b>: 두드려</li><li><b>나는 장인님이 너무나 고마워서 어느덧 눈물까지 났다.</b>: '나'의 순박함.</li></ul></div></details><blockquote style="background-color: #f3f4f6; border-left: 4px solid #d1d5db; padding: 1rem; border-radius: 8px;">📝 장인의 말을 믿고 고마워하는 '나'</blockquote><br><br><div style="text-align: center;">●<br>●<br>●</div><br><br><!-- [테이블 삽입] 핵심 정리 --><br><div class="problem-wrapper" data-type="table-fill-blank" data-answers='["주인공","갈등","갈등","역순행"]' style="background-color: #eff6ff; border-color: #93c5fd;"><div class="problem-header flex-header" style="border-color: #93c5fd;"><span>田 핵심 정리</span><button class="retry-btn" title="다시 풀기">🔄</button></div><table class="custom-table" style="margin-top: 0.5rem;"><thead><tr><th style="width: 25%;">구분</th><th>내용</th></tr></thead><tbody><tr><td><b>갈래</b></td><td>단편 소설, 농촌 소설</td></tr><tr><td><b>성격</b></td><td>향토적, 해학적</td></tr><tr><td><b>시점</b></td><td>1인칭 <input type="text" class="blank-input" data-blank-index="0" /> 시점</td></tr><tr><td><b>배경</b></td><td>☑️ 시간적 배경-1930년대 봄,<br>☑️ 공간적 배경: 강원도 농촌</td></tr><tr><td><b>주제</b></td><td>우직하고 순박한 데릴사위와 그를 이용하는 교활한 장인 간의 해학적 <input type="text" class="blank-input" data-blank-index="1" /></td></tr><tr><td><b>특징</b></td><td>① 상황을 과장되게 설정하여 웃음을 유발함.<br>② 장인(마름)과 '나'(데릴사위로 들어온 머슴)가 혼인 문제로 <input type="text" class="blank-input" data-blank-index="2" />하는 모습을 해학적으로 그림.<br>③ 사건의 시간과 서술의 순서가 뒤바뀐 <input type="text" class="blank-input" data-blank-index="3" />적 구성임.</td></tr><tr><td><b>'나'의 성격</b></td><td>성례를 시켜준다는 장인의 말을 믿고 장인에게 매번 이용당하는 것으로 보아 '나'는 어리숙하고 순진한 인물임.</td></tr><tr><td><b>'장인'의 성격</b></td><td>'데릴사위'를 구실로 나를 머슴처럼 부리는 교활한 인물.</td></tr></tbody><tfoot><tr><td colspan="2" style="text-align: right; border: none; padding-top: 1rem;" class="problem-controls"><button class="check-problem-btn">정답 확인</button></td></tr></tfoot></table></div><!-- end-problem-wrapper --><br><br><!-- [테이블 삽입] 골계(滑稽), 해학(諧謔), 풍자(諷刺) --><br><div class="problem-wrapper" data-type="table-fill-blank" data-answers='[]' style="background-color: #eff6ff; border-color: #93c5fd;"><div class="problem-header flex-header" style="border-color: #93c5fd;"><span>田 골계(滑稽), 해학(諧謔), 풍자(諷刺)</span><button class="retry-btn" title="다시 풀기">🔄</button></div><p style="margin-bottom: 1rem; color: #4b5563;">✅ 골계: 해학과 풍자의 상위 개념: 웃음을 통한 미적 범주. 대상을 과장하거나 왜곡하여 웃음을 불러일으키는 문학적 장치.<br>✅ 해학과 풍자는 골계의 하위 유형으로 설명되기도 함<br>✅ 해학 ↔ 풍자: 한 작품 안에 공존 가능<br>     (예)  부드러운 해학 속에 날카로운 풍자가 섞인 경우<br><br>🎯 핵심 정리<br>  - 골계: 웃음의 큰 틀, 교훈과 재치를 포함<br>  - 해학: 따뜻하고 여유 있는 웃음<br>  - 풍자: 비판과 조롱의 웃음<br><br>☑️ <b>풍자</b><br>  - 비판적 웃음<br>  - 대상에 대한 부정적 인식을 바탕으로 함.<br>  - 작품 속에서 권력과 권위를 가진 주인공을 부정적으로 제시하고,<br>    그의 모습을 과장하거나 왜곡하여 우스꽝스럽게 나타냄.</p><table class="custom-table" style="margin-top: 0;"><thead><tr><th style="width: 25%;">구분</th><th>뜻</th><th>웃음의 성격</th></tr></thead><tbody><tr><td><b>골계(滑稽)</b></td><td>교훈이나 의미를 담은 익살. 미학에서 ‘골계미’라 부름</td><td>상황·언어·행동에서 오는 재치 있는 웃음</td></tr><tr><td><b>해학(諧謔)</b></td><td>힘든 상황이나 강자의 공격을 부드럽게 받아넘기는 웃음.</td><td>☑️ 따뜻하고 여유 있는 웃음, 인간미 강조<br>☑️ 동정적 웃음<br>☑️ 대상에 대한 연민과 애정을 바탕으로 함.<br>☑️ 작품 속에서 평범하거나 그 이하인 인물의 행위를 통해 희극적인 상황을 만들어 냄.</td></tr><tr><td><b>풍자(諷刺)</b></td><td>부조리·악습·권력층을 비판·조롱하는 웃음</td><td>날카롭고 공격적인 웃음, 사회 비판 목적<br>☑️ 비판적 웃음<br>☑️  대상에 대한 부정적 인식을 바탕으로 함.<br>☑️ 작품 속에서 권력과 권위를 가진 주인공을 부정적으로 제시하고, 그의 모습을 과장하거나 왜곡하여 우스꽝스럽게 나타냄.</td></tr></tbody></table></div><!-- end-problem-wrapper --><br></div>
        <div class="footer-text">juno v2.41</div>
    </div>
    <script>
        (
                (function() {
                    function setupAll() {
                        function setupInteractiveAbbr() {
                            const abbrElements = document.querySelectorAll('.interactive-abbr');
                            let currentPopup = null;
                            function closePopup() {
                                if (currentPopup) { currentPopup.remove(); currentPopup = null; }
                            }
                            document.body.addEventListener('click', function(event) {
                                const span = event.target.closest('.interactive-abbr');
                                if (span) {
                                    event.stopPropagation();
                                    closePopup();
                                    const title = span.dataset.title;
                                    const originalText = span.dataset.originalText;
                                    const popupDiv = document.createElement('div');
                                    popupDiv.style.cssText = "position: absolute; background-color: #f8fafc; border: 1px solid #cbd5e1; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); padding: 16px; width: 300px; z-index: 1000; font-family: 'Inter', sans-serif; font-size: 14px; line-height: 1.5; color: #334155; word-wrap: break-word;";
                                    popupDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 8px; color: #1e40af;">' + originalText + '</div><div>' + title + '</div><button class="close-popup-btn" style="position: absolute; top: 8px; right: 8px; background: none; border: none; font-size: 18px; cursor: pointer; color: #64748b;">&times;</button>';
                                    const rect = span.getBoundingClientRect();
                                    let top = rect.bottom + window.scrollY + 5;
                                    let left = rect.left + window.scrollX;
                                    document.body.appendChild(popupDiv);
                                    currentPopup = popupDiv;
                                    if (left + popupDiv.offsetWidth > window.innerWidth) { left = window.innerWidth - popupDiv.offsetWidth - 20; }
                                    if (top + popupDiv.offsetHeight > window.innerHeight + window.scrollY) { top = rect.top + window.scrollY - popupDiv.offsetHeight - 5; }
                                    popupDiv.style.top = top + 'px';
                                    popupDiv.style.left = left + 'px';
                                    popupDiv.querySelector('.close-popup-btn').addEventListener('click', closePopup);
                                } else if (currentPopup && !currentPopup.contains(event.target)) {
                                    closePopup();
                                }
                            });
                            document.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closePopup(); } });
                        }
                        
                        function setupInteractiveProblems() {
                            document.body.addEventListener('click', function(event) {
                                const target = event.target;
                                const showFeedback = (message, color, bgColor, context) => {
                                    const controlContainer = context.querySelector('.problem-controls');
                                    if (controlContainer) {
                                        const checkBtn = controlContainer.querySelector('.check-problem-btn');
                                        let feedbackBox = controlContainer.querySelector('.feedback-message-box');
                                        if (!feedbackBox) {
                                            feedbackBox = document.createElement('div');
                                            feedbackBox.className = 'feedback-message-box';
                                            controlContainer.appendChild(feedbackBox);
                                        }
                                        feedbackBox.textContent = message;
                                        feedbackBox.style.color = color;
                                        feedbackBox.style.backgroundColor = bgColor;
                                        feedbackBox.style.marginTop = '8px';
                                        feedbackBox.style.marginBottom = '0';
                                        feedbackBox.style.padding = '8px';
                                        feedbackBox.style.textAlign = 'center';
                                        feedbackBox.style.borderRadius = '6px';
                                        feedbackBox.style.fontSize = '0.9em';
                                        feedbackBox.style.lineHeight = '1.4';
                                        if (checkBtn) {
                                            feedbackBox.style.width = checkBtn.offsetWidth + 'px';
                                        }
                                    } else {
                                        let feedbackBox = context.querySelector('.feedback-message-box');
                                        if (!feedbackBox) {
                                            feedbackBox = document.createElement('div');
                                            feedbackBox.className = 'feedback-message-box';
                                            context.appendChild(feedbackBox);
                                        }
                                        feedbackBox.textContent = message;
                                        feedbackBox.style.color = color;
                                        feedbackBox.style.backgroundColor = bgColor;
                                    }
                                };

                                // Check and Retry Buttons
                                const checkBtn = target.closest('.check-problem-btn');
                                const retryBtn = target.closest('.retry-btn');
                                
                                if (checkBtn) {
                                    const wrapper = checkBtn.closest('.problem-wrapper');
                                    if (!wrapper) return;
                                    const type = wrapper.dataset.type;

                                    if (type === 'essay') {
                                        const answerSection = wrapper.querySelector('.problem-answer-section');
                                        const textarea = wrapper.querySelector('.essay-answer-input');
                                        answerSection.style.display = 'block';
                                        checkBtn.style.display = 'none';
                                        textarea.disabled = true;
                                    } else if (type === 'fill-blank') {
                                        const item = checkBtn.closest('.fill-blank-item');
                                        let attempts = parseInt(item.dataset.attempts || '3', 10);
                                        if (attempts <= 0) return;
                                        let allCorrect = true;
                                        const inputs = item.querySelectorAll('.blank-input');
                                        const answers = JSON.parse(item.dataset.answers.replace(/&#39;/g, "'") || '[]');
                                        inputs.forEach((input, index) => {
                                            const isCorrect = input.value.trim() === answers[index];
                                            input.classList.toggle('correct', isCorrect);
                                            input.classList.toggle('incorrect', !isCorrect);
                                            if (!isCorrect) allCorrect = false;
                                        });
                                        if (allCorrect) {
                                            showFeedback('정답입니다! 🎉', '#166534', '#dcfce7', item);
                                            inputs.forEach(input => { input.disabled = true; });
                                            checkBtn.style.display = 'none';
                                        } else {
                                            attempts--;
                                            item.dataset.attempts = attempts;
                                            if (attempts > 0) {
                                                showFeedback('오답이 있습니다. (' + attempts + '번 남음)', '#991b1b', '#fee2e2', item);
                                            } else {
                                                showFeedback('아쉬워요. 정답을 확인해보세요! 💪', '#991b1b', '#fee2e2', item);
                                                inputs.forEach((input, i) => {
                                                    if (!input.classList.contains('correct')) {
                                                        input.value = answers[i] || '';
                                                    }
                                                    input.disabled = true;
                                                });
                                                checkBtn.style.display = 'none';
                                            }
                                        }
                                    } else if (type === 'table-fill-blank') {
                                        let attempts = parseInt(wrapper.dataset.attempts || '3', 10);
                                        if (attempts <= 0) return;
                                        let allCorrect = true;
                                        const inputs = wrapper.querySelectorAll('.blank-input');
                                        const answers = JSON.parse(wrapper.dataset.answers.replace(/&#39;/g, "'") || '[]');
                                        inputs.forEach((input, index) => {
                                            const isCorrect = input.value.trim() === answers[index];
                                            input.classList.toggle('correct', isCorrect);
                                            input.classList.toggle('incorrect', !isCorrect);
                                            if (!isCorrect) allCorrect = false;
                                        });

                                        if (allCorrect) {
                                            showFeedback('정답입니다! 🎉', '#166534', '#dcfce7', wrapper.querySelector('.problem-controls'));
                                            inputs.forEach(input => { input.disabled = true; });
                                            checkBtn.style.display = 'none';
                                        } else {
                                            attempts--;
                                            wrapper.dataset.attempts = attempts;
                                            if (attempts > 0) {
                                                showFeedback('오답이 있습니다. (' + attempts + '번 남음)', '#991b1b', '#fee2e2', wrapper.querySelector('.problem-controls'));
                                            } else {
                                                showFeedback('아쉬워요. 정답을 확인해보세요! 💪', '#991b1b', '#fee2e2', wrapper.querySelector('.problem-controls'));
                                                inputs.forEach((input, i) => {
                                                    if (!input.classList.contains('correct')) {
                                                        input.value = answers[i] || '';
                                                    }
                                                    input.disabled = true;
                                                });
                                                checkBtn.style.display = 'none';
                                            }
                                        }
                                    }
                                }

                                if (retryBtn) {
                                    const wrapper = retryBtn.closest('.problem-wrapper');
                                    if (!wrapper) return;
                                    const type = wrapper.dataset.type;

                                    if (type === 'essay') {
                                        wrapper.querySelector('.essay-answer-input').value = '';
                                        wrapper.querySelector('.essay-answer-input').disabled = false;
                                        wrapper.querySelector('.problem-answer-section').style.display = 'none';
                                        wrapper.querySelector('.check-problem-btn').style.display = 'block';
                                    } else if (type === 'fill-blank') {
                                        wrapper.querySelectorAll('.fill-blank-item').forEach(item => {
                                            item.dataset.attempts = '3';
                                            item.querySelectorAll('.blank-input').forEach(input => {
                                                input.value = '';
                                                input.classList.remove('correct', 'incorrect');
                                                input.disabled = false;
                                            });
                                            const btn = item.querySelector('.check-problem-btn');
                                            if (btn) btn.style.display = 'block';
                                            item.querySelector('.feedback-message-box')?.remove();
                                        });
                                    } else if (type === 'table-fill-blank') {
                                        wrapper.dataset.attempts = '3';
                                        wrapper.querySelectorAll('.blank-input').forEach(input => {
                                            input.value = '';
                                            input.classList.remove('correct', 'incorrect');
                                            input.disabled = false;
                                        });
                                        const btn = wrapper.querySelector('.check-problem-btn');
                                        if(btn) btn.style.display = 'block';
                                        wrapper.querySelector('.feedback-message-box')?.remove();
                                    } else if (type === 'ox-quiz') {
                                        wrapper.querySelectorAll('.ox-quiz-item').forEach(item => {
                                            item.querySelectorAll('.ox-choice').forEach(choice => {
                                                choice.classList.remove('correct', 'incorrect');
                                                choice.disabled = false;
                                                choice.innerHTML = choice.classList.contains('o-btn') ? 'O' : 'X';
                                            });
                                        });
                                    } else if (type === 'multiple-choice') {
                                        wrapper.dataset.attempts = '2';
                                        wrapper.dataset.solved = 'false';
                                        wrapper.querySelectorAll('.choice-item').forEach(c => {
                                            c.classList.remove('correct', 'incorrect');
                                            c.style.pointerEvents = 'auto';
                                        });
                                        wrapper.querySelector('.problem-answer-section').style.display = 'none';
                                        wrapper.querySelector('.mc-feedback-container').innerHTML = '';
                                    }
                                }

                                // OX Quiz Choices
                                const oxChoice = target.closest('.ox-choice');
                                if (oxChoice) {
                                    const item = oxChoice.closest('.ox-quiz-item');
                                    if (item.querySelector('.ox-choice[disabled]')) return;
                                    
                                    const correctAnswer = item.dataset.correctAnswer;
                                    const selectedAnswer = oxChoice.textContent;
                                    const isCorrect = selectedAnswer === correctAnswer;
                                    
                                    item.querySelectorAll('.ox-choice').forEach(btn => {
                                        btn.disabled = true;
                                        if (btn.textContent === correctAnswer) {
                                            btn.classList.add('correct');
                                            btn.innerHTML = '✅';
                                        }
                                    });

                                    if (!isCorrect) {
                                        oxChoice.classList.add('incorrect');
                                        oxChoice.innerHTML = '❌';
                                    }
                                }

                                // Multiple Choice
                                const mcChoice = target.closest('.choice-item');
                                if (mcChoice) {
                                    const wrapper = mcChoice.closest('.problem-wrapper');
                                    let solved = wrapper.dataset.solved === 'true';
                                    if (solved || mcChoice.classList.contains('incorrect')) return;

                                    let attempts = parseInt(wrapper.dataset.attempts || '2', 10);
                                    const isCorrect = mcChoice.dataset.correct === 'true';
                                    const answerSection = wrapper.querySelector('.problem-answer-section');
                                    const feedbackContainer = wrapper.querySelector('.mc-feedback-container');

                                    if (isCorrect) {
                                        showFeedback('정답입니다! 🎉', '#166534', '#dcfce7', feedbackContainer);
                                        mcChoice.classList.add('correct');
                                        wrapper.dataset.solved = 'true';
                                        wrapper.querySelectorAll('.choice-item').forEach(c => c.style.pointerEvents = 'none');
                                        if(answerSection) answerSection.style.display = 'block';
                                    } else {
                                        attempts--;
                                        wrapper.dataset.attempts = attempts;
                                        mcChoice.classList.add('incorrect');
                                        mcChoice.style.pointerEvents = 'none';

                                        if (attempts > 0) {
                                            showFeedback('아쉽네요. 1번의 기회가 남았어요.', '#991b1b', '#fee2e2', feedbackContainer);
                                        } else {
                                            showFeedback('오답입니다. 정답을 확인해보세요.', '#991b1b', '#fee2e2', feedbackContainer);
                                            const correctChoice = wrapper.querySelector('.choice-item[data-correct="true"]');
                                            if(correctChoice) correctChoice.classList.add('correct');
                                            wrapper.dataset.solved = 'true';
                                            wrapper.querySelectorAll('.choice-item').forEach(c => c.style.pointerEvents = 'none');
                                            if(answerSection) answerSection.style.display = 'block';
                                        }
                                    }
                                }
                            });
                        }

                        function setupLineDrawingQuizzes() {
                            document.querySelectorAll('.problem-wrapper[data-type="line-drawing-quiz"]').forEach(wrapper => {
                                const container = wrapper.querySelector('.line-drawing-container');
                                const canvas = wrapper.querySelector('.line-drawing-canvas');
                                const ctx = canvas.getContext('2d');
                                const rightList = wrapper.querySelector('.line-drawing-list.right');
                                const checkBtn = wrapper.querySelector('.check-problem-btn');
                                const retryBtn = wrapper.querySelector('.retry-btn');
                                
                                let isDrawing = false;
                                let lineStartPoint = null;
                                let drawnLines = [];
                                let isSolved = false;

                                const alignHeights = () => {
                                    const leftItems = Array.from(wrapper.querySelectorAll('.line-drawing-list.left .line-drawing-item'));
                                    const rightItems = Array.from(wrapper.querySelectorAll('.line-drawing-list.right .line-drawing-item'));

                                    leftItems.forEach(item => item.style.minHeight = '');
                                    rightItems.forEach(item => item.style.minHeight = '');

                                    requestAnimationFrame(() => {
                                        const rightItemsById = new Map();
                                        rightItems.forEach(item => rightItemsById.set(item.dataset.id, item));

                                        leftItems.forEach(leftItem => {
                                            const rightItem = rightItemsById.get(leftItem.dataset.id);
                                            if (rightItem) {
                                                const leftHeight = leftItem.offsetHeight;
                                                const rightHeight = rightItem.offsetHeight;
                                                const maxHeight = Math.max(leftHeight, rightHeight);
                                                leftItem.style.minHeight = `${maxHeight}px`;
                                                rightItem.style.minHeight = `${maxHeight}px`;
                                            }
                                        });
                                    });
                                };
                                
                                const getPointCoords = (pointEl) => {
                                    const rect = pointEl.getBoundingClientRect();
                                    const containerRect = container.getBoundingClientRect();
                                    return {
                                        x: rect.left - containerRect.left + rect.width / 2,
                                        y: rect.top - containerRect.top + rect.height / 2,
                                    };
                                };

                                const drawLine = (startCoords, endCoords, color = '#60a5fa', width = 4) => {
                                    ctx.beginPath();
                                    ctx.moveTo(startCoords.x, startCoords.y);
                                    ctx.lineTo(endCoords.x, endCoords.y);
                                    ctx.strokeStyle = color;
                                    ctx.lineWidth = width;
                                    ctx.lineCap = 'round';
                                    ctx.stroke();
                                };

                                const redrawAllLines = (showResult = false) => {
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    drawnLines.forEach(line => {
                                        const startEl = container.querySelector(`.connection-point[data-side="left"][data-id="${line.leftId}"]`);
                                        const endEl = container.querySelector(`.connection-point[data-side="right"][data-id="${line.rightId}"]`);
                                        if (startEl && endEl) {
                                            const startCoords = getPointCoords(startEl);
                                            const endCoords = getPointCoords(endEl);
                                            let color = '#60a5fa';
                                            if (showResult) {
                                                color = line.leftId === line.rightId ? '#22c55e' : '#ef4444';
                                            }
                                            drawLine(startCoords, endCoords, color, showResult ? 6 : 4);
                                        }
                                    });
                                };

                                const resizeCanvas = () => {
                                    canvas.width = container.clientWidth;
                                    canvas.height = container.clientHeight;
                                    alignHeights();
                                    redrawAllLines(isSolved);
                                };

                                const getEventCoords = (e) => {
                                    const rect = container.getBoundingClientRect();
                                    const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                                    const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                                    return { x: clientX - rect.left, y: clientY - rect.top };
                                }
                                
                                const getEndEventCoords = (e) => {
                                    const rect = container.getBoundingClientRect();
                                    const clientX = e.clientX || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0);
                                    const clientY = e.clientY || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0);
                                    return { clientX, clientY, x: clientX - rect.left, y: clientY - rect.top };
                                }

                                const handleMove = (e) => {
                                    if (!isDrawing || !lineStartPoint) return;
                                    e.preventDefault();
                                    const coords = getEventCoords(e);
                                    redrawAllLines();
                                    const startCoords = getPointCoords(lineStartPoint);
                                    drawLine(startCoords, coords);
                                };

                                const handleEnd = (e) => {
                                    if (!isDrawing || !lineStartPoint) return;
                                    e.preventDefault();
                                    
                                    const endCoords = getEndEventCoords(e);
                                    const endPointEl = document.elementFromPoint(endCoords.clientX, endCoords.clientY);
                                    const endPoint = endPointEl ? endPointEl.closest('.connection-point') : null;

                                    if (endPoint && endPoint !== lineStartPoint && endPoint.dataset.side !== lineStartPoint.dataset.side) {
                                        const leftId = lineStartPoint.dataset.side === 'left' ? lineStartPoint.dataset.id : endPoint.dataset.id;
                                        const rightId = lineStartPoint.dataset.side === 'right' ? lineStartPoint.dataset.id : endPoint.dataset.id;
                                        
                                        // Remove any existing lines connected to the start or end points
                                        drawnLines = drawnLines.filter(line => line.leftId !== leftId && line.rightId !== rightId);

                                        drawnLines.push({ leftId, rightId });
                                    }
                                    
                                    lineStartPoint.classList.remove('selected');
                                    lineStartPoint = null;
                                    isDrawing = false;
                                    
                                    window.removeEventListener('mousemove', handleMove);
                                    window.removeEventListener('mouseup', handleEnd);
                                    window.removeEventListener('touchmove', handleMove);
                                    window.removeEventListener('touchend', handleEnd);

                                    redrawAllLines();
                                };

                                const handleStart = (e) => {
                                    if (isSolved) return;
                                    const point = e.target.closest('.connection-point');
                                    if (!point) return;
                                    e.preventDefault();
                                    
                                    isDrawing = true;
                                    lineStartPoint = point;
                                    point.classList.add('selected');

                                    // Remove existing line from this point
                                    drawnLines = drawnLines.filter(line => {
                                        if (point.dataset.side === 'left') return line.leftId !== point.dataset.id;
                                        return line.rightId !== point.dataset.id;
                                    });
                                    redrawAllLines();
                                    
                                    window.addEventListener('mousemove', handleMove);
                                    window.addEventListener('mouseup', handleEnd);
                                    window.addEventListener('touchmove', handleMove, { passive: false });
                                    window.addEventListener('touchend', handleEnd, { passive: false });
                                };
                                
                                const initQuiz = () => {
                                    const rightItems = Array.from(rightList.children);
                                    for (let i = rightItems.length - 1; i > 0; i--) {
                                        const j = Math.floor(Math.random() * (i + 1));
                                        [rightItems[i], rightItems[j]] = [rightItems[j], rightItems[i]];
                                    }
                                    rightItems.forEach(item => rightList.appendChild(item));
                                    
                                    isSolved = false;
                                    drawnLines = [];
                                    checkBtn.disabled = false;
                                    container.querySelectorAll('.connection-point').forEach(p => p.classList.remove('selected'));
                                    
                                    setTimeout(resizeCanvas, 200);
                                };
                                
                                checkBtn.addEventListener('click', () => {
                                    if (isSolved) return;
                                    isSolved = true;
                                    redrawAllLines(true);
                                    checkBtn.disabled = true;
                                });

                                retryBtn.addEventListener('click', initQuiz);

                                // Init
                                initQuiz();
				setTimeout(initQuiz, 100);
                                window.addEventListener('resize', resizeCanvas);
                                container.addEventListener('mousedown', handleStart);
                                container.addEventListener('touchstart', handleStart, { passive: false });
                            });
                        }

                        setupInteractiveAbbr(); 
                        setupInteractiveProblems(); 
                        setupLineDrawingQuizzes();
                    }

                    window.addEventListener('load', setupAll);
                })()
            )()
    </script>
</body></html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>용비어천가</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 20px; font-family: 'Inter', sans-serif; line-height: 2.0; background-color: #f3f4f6; color: #374151; font-size: 12pt; }
        .container { max-width: 800px; margin: 20px auto; padding: 30px; background-color: #ffffff; border-radius: 12px; border: 1px solid #e5e7eb; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); }
        .header-section { background-color: #f9fafb; padding: 20px 30px; margin: -30px -30px 20px -30px; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom: 1px solid #e5e7eb; text-align: center; }
        .header-section h1 { font-size: 1.875rem; font-weight: 700; color: #1f2937; }
        .header-section .author-text { font-size: 1.125rem; color: #4b5563; }
        blockquote { margin: 1em 0; padding: 1rem; border-left-width: 4px; border-color: #93c5fd; font-style: normal; color: #4b5563; background-color: #eef2ff; border-radius: 8px; white-space: pre-wrap; }
        p { margin-bottom: 1em; }
        p:last-child { margin-bottom: 0; }
        mark { padding: 0.2em 0.4em; border-radius: 4px; }
        .footer-text { text-align: right; color: #6b7280; margin-top: 30px; font-size: 0.9em; }
        .interactive-abbr { text-decoration: underline dotted; cursor: pointer; color: #1e40af; font-weight: 600; transition: color 0.2s; }
        .interactive-abbr:hover { color: #F97316; }
        .problem-wrapper{margin:16px 0;padding:20px;border:2px solid;border-radius:12px}.problem-header{font-size:1.1em;font-weight:700;color:#1e3a8a;margin:-20px -20px 16px;padding:12px 20px;background-color:#fff;border-bottom:2px solid;border-top-left-radius:10px;border-top-right-radius:10px}.problem-example-box{margin:12px 0;padding:12px;border:1px solid #e5e7eb;border-radius:6px;background-color:#fff;font-size:.95em;color:#4b5563}.problem-choices .choice-item{display:flex;align-items:center;margin:1px 0;padding:5px 8px;border-radius:4px;cursor:pointer;transition:background-color .2s,transform .2s}.problem-choices .choice-item:hover{background-color:#eef2ff;transform:translateX(2px)}.problem-choices .choice-item.correct{background-color:#dcfce7!important;color:#166534;font-weight:700}.problem-choices .choice-item.incorrect{background-color:#fee2e2;color:#991b1b}.problem-choices .choice-item .choice-text{text-decoration:none}.problem-choices .choice-item.incorrect .choice-text{text-decoration:line-through}.problem-answer-section{margin-top:16px;padding-top:12px;border-top:1px dashed #d1d5db;font-size:.95em;color:#4b5563}.feedback-message-box{margin-top:12px;padding:10px;border-radius:6px;font-weight:700;text-align:center}.essay-answer-input{width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;min-height:80px;margin-top:8px;font-family:inherit;font-size:inherit;color:inherit;line-height:inherit}.check-problem-btn{background-color:#60a5fa;color:#fff;padding:8px 12px;border:none;border-radius:6px;cursor:pointer;transition:background-color .2s;white-space:nowrap}.check-problem-btn:hover{background-color:#3b82f6}.check-problem-btn:disabled{background-color:#a5b4fc;cursor:not-allowed}.blank-input{border:1px solid #9ca3af;border-radius:4px;padding:2px 4px;text-align:center;width:100px;margin:0 4px}.blank-input.correct{background-color:#dcfce7;border-color:#16a34a}.blank-input.incorrect{background-color:#fee2e2;border-color:#dc2626}.toggle-wrapper{margin:16px 0;border:2px solid;border-radius:12px;transition:background-color .2s;overflow:hidden}.toggle-title{cursor:pointer;padding:12px 20px;font-weight:600;color:#374151;display:flex;justify-content:space-between;align-items:center;list-style:none;background-color:#fff}.toggle-wrapper[open]>.toggle-title{border-bottom:2px solid}.toggle-title::-webkit-details-marker{display:none}.toggle-title::after{content:"▶";font-size:.8em;transition:transform .2s}.toggle-wrapper[open]>.toggle-title::after{transform:rotate(90deg)}.toggle-content{padding:20px;color:#4b5563}.custom-table{width:100%;border-collapse:collapse}.custom-table th,.custom-table td{border:1px solid #93c5fd;padding:8px 12px;text-align:left;vertical-align:top}.custom-table th{background-color:#dbeafe;font-weight:700}.ox-choice.correct{background-color:#dcfce7!important;border-color:#16a34a!important;color:#166534!important}.ox-choice.incorrect{background-color:#fee2e2!important;border-color:#dc2626!important;color:#991b1b!important}.problem-wrapper[data-type=ox-quiz] ol,.problem-wrapper[data-type=fill-blank] ol{list-style:none;padding-left:0}.ox-quiz-item{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid #e5e7eb}.ox-quiz-item:last-child{border-bottom:none}.ox-quiz-item .flex-grow{flex-grow:1}.ox-choices{display:flex;align-items:center;gap:8px;margin-left:16px;flex-shrink:0}.ox-choice{width:48px;height:48px;font-size:1.5rem;border-radius:9999px;display:inline-flex;align-items:center;justify-content:center;font-weight:700;background-color:#e5e7eb;color:#4b5563;cursor:pointer;transition:background-color .2s,transform .2s;border:none}.ox-choice:hover{transform:scale(1.05)}.problem-header.flex-header{display:flex;justify-content:space-between;align-items:center}.retry-btn{font-size:1.2rem;background-color:#e5e7eb;color:#374151;border-radius:9999px;padding:8px;line-height:1;border:none;cursor:pointer}.retry-btn:hover{background-color:#d1d5db}.media-wrapper{width:80%;margin:24px auto}.youtube-container{position:relative;overflow:hidden;width:100%;padding-top:56.25%}.youtube-container iframe{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%;border:none;border-radius:12px}.line-drawing-container{position:relative;display:flex;justify-content:space-between;align-items:flex-start;padding:20px 0;touch-action:none}.line-drawing-canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0}.line-drawing-list{display:flex;flex-direction:column;gap:16px;z-index:1;width:45%}.line-drawing-item{display:flex;align-items:center;padding:12px 0;border:none;background-color:transparent;font-size:1em}.line-drawing-list.left .line-drawing-item{flex-direction:row;justify-content:space-between}.line-drawing-list.right .line-drawing-item{flex-direction:row;justify-content:flex-start;gap:12px}.line-drawing-item-text{flex-grow:1}.line-drawing-list.left .line-drawing-item-text{text-align:right;margin-right:12px}.line-drawing-list.right .line-drawing-item-text{text-align:left}.connection-point{width:14px;height:14px;background-color:#cbd5e1;border-radius:50%;cursor:pointer;transition:background-color .2s;flex-shrink:0}.connection-point:hover,.connection-point.selected{background-color:#3b82f6}.line-drawing-controls{text-align:right;margin-top:16px}
	.custom-link {
   		display: inline-block;
 		padding: 2px 8px;
		border: 1px solid #dbeafe;
     	   border-radius: 8px;
      	  background-color: #eff6ff;
     	   color: #3b82f6;
    	    text-decoration: none;
    	    font-weight: 500;
   	     transition: all 0.2s;
        }
        .custom-link:hover {
  	      background-color: #dbeafe;
	        border-color: #93c5fd;
 	       transform: translateY(-1px);
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header-section"><h1><i class="fas fa-language mr-2"></i> 용비어천가</h1><div class="author-text">지은이: 정인지,권제,안지</div></div>
        <div class="main-content-body"><span style="font-size:13pt;font-weight: bold; border: 2px solid #34D399; padding: 1px 4px; border-radius: 4px; background-color:#A7F3D0;">조선의 건국을 노래한 장엄한 서사시, 악장(樂章)</span> <br><br>💡 악장은 쉽게 말해 <mark style="background-color: #fef08a;">조선이라는 새로운 나라의 건국을 축하하고, 그 정당성을 널리 알리기 위해</mark> 만들어진 '<mark style="background-color: #fef08a;">국가 공식 찬가</mark>'입니다. 주로 국가의 중요한 제사나 큰 연회에서 음악에 맞추어 불렸습니다.<br>💡 꼭 알아야 할 대표 작품: 용비어천가, 월인천강지곡<br><br><br><div style="text-align: center;">●●●</div><br><br><!-- [더보기] 용비어천가 교과서 지문 --><details class="toggle-wrapper" data-type="toggle-content" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">📖 용비어천가 교과서 지문</span></summary><div class="toggle-content"><b>용비어천가(龍飛御天歌)</b><br><br>海東(해동) 六龍(육룡)•이 ᄂᆞᄅᆞ•샤 ：일：마다 天福(천복) •이시•니 古聖(고성)•이 同符(동부)•ᄒᆞ시•니   [제1장]<br><br><br>불•휘  기•픈  남•ᄀᆞᆫ  ᄇᆞᄅᆞ•매 아•니  ：뮐•ᄊᆡ  곶  ：됴•코  여•름 •하ᄂᆞ•니<br>：ᄉᆡ•미 기•픈 •므•른 •ᄀᆞᄆᆞ•래 아•니 그•츨•ᄊᆡ  ：내•히 이•러 바•ᄅᆞ•래 •가ᄂᆞ•니     [제2장]<br><br><br><b>현대어 풀이</b><br><br><mark style="background-color: #fef08a;">[제1장]<br></mark>해동의 여섯 용이 나시어, 일마다 하늘의 복이시니 옛날의 성인과 서로 꼭 들어맞으시니.       <br><br><mark style="background-color: #fef08a;">[제2장]<br></mark>뿌리가 깊은 나무는 바람에 아니 움직이므로, 꽃 좋고 열매 많으니.<br>샘이 깊은 물은 가뭄에 아니 그치므로, 내가 이루어져 바다에 가느니. </div></details><br><!-- [더보기] 용비어천가에 대하여 --><details class="toggle-wrapper" data-type="toggle-content" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">📖 용비어천가에 대하여</span></summary><div class="toggle-content">*️⃣ <b>제재 해설</b><br>왕명에 따라 <mark style="background-color: #e5e7eb;">정인지, 권제, 안지 등</mark>이 지은 것으로 세종 27년(1445년)에 편찬되어 세종 29년(1447)에 간행된 <mark style="background-color: #e5e7eb;">악장</mark> 문학 작품이다. 조선을 세우기까지의 <mark style="background-color: #fef08a;">선조들의 공덕</mark>을 기라고 <mark style="background-color: #fef08a;">조선 개국의 정당성</mark>을 밝히고 있다.<br><br>*️⃣ <b>창작 동기</b><br>  ▪️ 새 왕조의 정당성 부각<br>  ▪️훈민정음의 실용성 시험<br>  ▪️후대 왕에 대한 권계<br><br><!-- [유튜브] --><br><div class="media-wrapper"><div class="youtube-container"><iframe src="https://www.youtube.com/embed/aeFu6-a8H3w" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></div></div></div></details><br><br><br><div style="text-align: center;">●●●<br></div><br><br><!-- 제목 용비어천가 --><br><span class="interactive-abbr" data-title="💬 용이 날아올라 하늘을 다스림을 노래한다는 뜻.  💡용비어천가의 '용'?  조선을 건국한 태조 이성계를 비롯한 여섯 선조를 상징. 목조-익조-도조-환조-태조 이성계-태종 이방원" data-original-text="용비어천가(龍飛御天歌)"><b style="color: black; font-size: 1.3em;">용비어천가(龍飛御天歌)</b></span><br><br><br>1️⃣ <span class="interactive-abbr" data-title="발해의 동쪽이라는 뜻으로, 예전에 우리나라를 이르던 말" data-original-text="海東(해동)">海東(해동)</span>   <span class="interactive-abbr" data-title="💬 당시 임금인 세종의 여섯 조상을 가리켜 한 말.   💡 목조>익조>도조>환조>(태조 이성계)>태종(이방원)" data-original-text="六龍(육룡)">六龍(육룡)</span>•이   <span class="interactive-abbr" data-title="ᄂᆞᆯ-+-ᄋᆞ-+-샤" data-original-text="ᄂᆞᄅᆞ•샤">ᄂᆞᄅᆞ•샤</span>   ：일：마다    <span class="interactive-abbr" data-title="💬 하늘의 복  💡조선 왕조의 창업이 하늘의 뜻에 의한 역사적 순리라는 점을 주장하여 사대부들의 충성심을 자극하고 민심의 이반을 막고자 함. ➡️ 새 왕조의 정당성 부각" data-original-text="天福(천복)">天福(천복)</span>   •이시•니   <span class="interactive-abbr" data-title="💬 중국의 옛 성인(제왕)  💡육조의 위대함을 중국 제왕들의 사적과 일치시켜 조선 건국의 정당성을 강조함. ➡️ 중국 고사 활용" data-original-text="古聖(고성)">古聖(고성)</span> <span class="interactive-abbr" data-title="비교 부사격 조사(와/과)" data-original-text="•이">•이</span>    <span class="interactive-abbr" data-title="💬부신(符信)이 꼭 들어맞듯 사물이나 현상이 서로 꼭 들어맞다.  💡중국의 고성(古聖)의 사적 = 육조(六祖)의 사적" data-original-text="同符(동부)">同符(동부)</span>•ᄒᆞ시•니   [제1장]<br><br><br><span style="font-weight: bold; border: 2px solid #34D399; padding: 1px 4px; border-radius: 4px; background-color:#A7F3D0;">현대어 풀이</span><br>해동의 여섯 용이 나시어, 일마다 하늘의 복이시니 옛날의 성인과 서로 꼭 들어맞으시니.<br><br><details class="toggle-wrapper" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">🗣️ 구절풀이</span></summary><div class="toggle-content"><ul style="list-style-type: none; margin-left: 0; padding-left: 0; margin-top: 10px;"><li><b>용비어천가(龍飛御天歌)</b>: 💬 용이 날아올라 하늘을 다스림을 노래한다는 뜻.  💡용비어천가의 '용'?  조선을 건국한 태조 이성계를 비롯한 여섯 선조를 상징. 목조-익조-도조-환조-태조 이성계-태종 이방원</li><li><b>海東(해동)</b>: 발해의 동쪽이라는 뜻으로, 예전에 우리나라를 이르던 말</li><li><b>六龍(육룡)</b>: 💬 당시 임금인 세종의 여섯 조상을 가리켜 한 말.   💡 목조&gt;익조&gt;도조&gt;환조&gt;(태조 이성계)&gt;태종(이방원)</li><li><b>ᄂᆞᄅᆞ•샤</b>: ᄂᆞᆯ-+-ᄋᆞ-+-샤</li><li><b>天福(천복)</b>: 💬 하늘의 복  💡조선 왕조의 창업이 하늘의 뜻에 의한 역사적 순리라는 점을 주장하여 사대부들의 충성심을 자극하고 민심의 이반을 막고자 함. ➡️ 새 왕조의 정당성 부각</li><li><b>古聖(고성)</b>: 💬 중국의 옛 성인(제왕)  💡육조의 위대함을 중국 제왕들의 사적과 일치시켜 조선 건국의 정당성을 강조함. ➡️ 중국 고사 활용</li><li><b>•이</b>: 비교 부사격 조사(와/과)</li><li><b>同符(동부)</b>: 💬부신(符信)이 꼭 들어맞듯 사물이나 현상이 서로 꼭 들어맞다.  💡중국의 고성(古聖)의 사적 = 육조(六祖)의 사적</li></ul></div></details><blockquote style="background-color: #eef2ff; border-left: 4px solid #93c5fd; padding: 1rem; border-radius: 8px;">📒 <b>[정리 (1장)]</b>: <mark style="background-color: #fecaca;">조선 건국의 정당성</mark><br><p style="margin-left: 30px;">💡 세종의 여섯 조상(육조)이 모두 하늘의 명을 따랐던 중국의 제왕들과 비슷함을 강조하여 여섯 선조도 이와 같이 하늘의 명을 받은 것임을 주장함.</p><br><br>📍<b>1장의 특징</b><br>   ▪️ 중국 고사 활용: <br>        - 육조의 위대함 = 중국 제왕들의 사적. ➡️ 건국의 정당성 강조.<br>   ▪️은유: 육룡 = 조선 창업의 주역인 육조(六祖)<br>   ▪️비교 부사격 조사 '이' : 현대어의 '과/와'<br>   ▪️방점 사용됨.<br>   ▪️주체 높임 선어말 어미 사용: '-샤-', '-시-'<br><!-- [더보기] 부신(符信) --><br><details class="toggle-wrapper" data-type="toggle-content" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">📖 부신(符信)</span></summary><div class="toggle-content">*️⃣ 조선시대 병조 등에서 발행한 여러 가지 신표(信標).<br><br>대개 나뭇조각이나 두꺼운 종잇조각에 글자를 쓰고 증인(證印)을 찍은 뒤에 이것을 두 조각으로 쪼개어 한 조각은 상대자에게 주고 다른 조각은 발행한 쪽에서 보관하였다가 뒷날 사용할 때 서로 맞추어 증거로 삼았다.<br><br><!-- [이미지] --><br><div style="text-align: center; margin: 16px 0;"><img src="https://junolee-home.github.io/images/부신_Gemini_Generated_Image.png" style="max-width: 100%; height: auto; border-radius: 12px; display: inline-block;" alt="삽입된 이미지" /></div> ▪️이미지 설명: 부신(Gemini로 생성한 이미지임)<br></div></details><br></blockquote><br><br><br><div style="text-align: center;">●●●</div><br><br><br>2️⃣ <br><span class="interactive-abbr" data-title="💬 뿌리가   ✨ 불휘+∅(주격조사)" data-original-text="불•휘">불•휘</span>   기•픈   <span class="interactive-abbr" data-title="💬 나무는   💡남ㄱ(나모)+ᄋᆞᆫ" data-original-text="남•ᄀᆞᆫ">남•ᄀᆞᆫ</span>    ᄇᆞᄅᆞ•매   아•니    <span class="interactive-abbr" data-title="💬 움직이므로   💡뮈다: 움직이다   💡뮈-+-ㄹᄊᆡ(이유)" data-original-text="：뮐•ᄊᆡ">：뮐•ᄊᆡ</span>    <span class="interactive-abbr" data-title="꽃" data-original-text="곶">곶</span>   <span class="interactive-abbr" data-title="💬 좋고   💡 (중세 국어에서) ① 둏다: 좋다(好), ② 좋다: 깨끗하다(淨)" data-original-text="：됴•코">：됴•코</span>     <span class="interactive-abbr" data-title="열매" data-original-text="여•름">여•름</span>     <span class="interactive-abbr" data-title="💬 많으니.   💡(중세 국어에서) 하다: 많다(多), ᄒᆞ다: ~을 하다(爲)" data-original-text="•하ᄂᆞ•니">•하ᄂᆞ•니</span><br><span class="interactive-abbr" data-title="💬 ᄉᆡᆷ+이(주격 조사)" data-original-text="：ᄉᆡ•미">：ᄉᆡ•미</span>   기•픈   <span class="interactive-abbr" data-title="💬믈+은  💡믈 > 물 (원순모음화)" data-original-text="•므•른">•므•른</span>   <span class="interactive-abbr" data-title="ᄀᆞᄆᆞᆯ+애(부사격 조사)" data-original-text="•ᄀᆞᄆᆞ•래">•ᄀᆞᄆᆞ•래</span>   아•니   그•츨•ᄊᆡ   <span class="interactive-abbr" data-title="💬 내가   💡내ㅎ+이(주격 조사) " data-original-text="：내•히">：내•히</span>    <span class="interactive-abbr" data-title="이루어져" data-original-text="이•러">이•러</span>    <span class="interactive-abbr" data-title="💬 바다에   💡바ᄅᆞᆯ+애(부사격 조사)" data-original-text="바•ᄅᆞ•래">바•ᄅᆞ•래</span>    •가ᄂᆞ•니      [제2장]<br><br><span style="font-weight: bold; border: 2px solid #34D399; padding: 1px 4px; border-radius: 4px; background-color:#A7F3D0;">현대어 풀이</span><br>뿌리가 깊은 나무는 바람에 아니 움직이므로, 꽃 좋고 열매 많으니.<br>샘이 깊은 물은 가뭄에 아니 그치므로, 내가 이루어져 바다에 가느니.<br><br><details class="toggle-wrapper" style="background-color: #eff6ff; border-color: #93c5fd;"><summary class="toggle-title" style="border-color: #93c5fd;"><span style="margin-right: auto;">🗣️ 구절풀이</span></summary><div class="toggle-content"><ul style="list-style-type: none; margin-left: 0; padding-left: 0; margin-top: 10px;"><li><b>불•휘</b>: 💬 뿌리가   ✨ 불휘+∅(주격조사)</li><li><b>남•ᄀᆞᆫ</b>: 💬 나무는   💡남ㄱ(나모)+ᄋᆞᆫ</li><li><b>：뮐•ᄊᆡ</b>: 💬 움직이므로   💡뮈다: 움직이다   💡뮈-+-ㄹᄊᆡ(이유)</li><li><b>곶</b>: 꽃</li><li><b>：됴•코</b>: 💬 좋고   💡 (중세 국어에서) ① 둏다: 좋다(好), ② 좋다: 깨끗하다(淨)</li><li><b>여•름</b>: 열매</li><li><b>•하ᄂᆞ•니</b>: 💬 많으니.   💡(중세 국어에서) 하다: 많다(多), ᄒᆞ다: ~을 하다(爲)</li><li><b>：ᄉᆡ•미</b>: 💬 ᄉᆡᆷ+이(주격 조사)</li><li><b>•므•른</b>: 💬믈+은  💡믈 &gt; 물 (원순모음화)</li><li><b>•ᄀᆞᄆᆞ•래</b>: ᄀᆞᄆᆞᆯ+애(부사격 조사)</li><li><b>：내•히</b>: 💬 내가   💡내ㅎ+이(주격 조사) </li><li><b>이•러</b>: 이루어져</li><li><b>바•ᄅᆞ•래</b>: 💬 바다에   💡바ᄅᆞᆯ+애(부사격 조사)</li></ul></div></details><blockquote style="background-color: #eef2ff; border-left: 4px solid #93c5fd; padding: 1rem; border-radius: 8px;">📒 <b>[정리 (2장)]</b>: <mark style="background-color: #fecaca;">조선의 영원을 기원함.</mark><br><p style="margin-left: 30px;">💡 자연물에 상징성을 부여하여 조선의 무궁한 발전을 전망하고 있음.</p><br><!-- [테이블 삽입] 2장에 표현된 구절의 은유적, 상징적 의미 --><br><div class="problem-wrapper" data-type="table-fill-blank" data-answers='["뿌리","바람","열매","샘","바다"]' style="background-color: #eff6ff; border-color: #93c5fd;"><div class="problem-header flex-header" style="border-color: #93c5fd;"><span>田 2장에 표현된 구절의 은유적, 상징적 의미</span><button class="retry-btn" title="다시 풀기">🔄</button></div><table class="custom-table" style="margin-top: 0.5rem;"><thead><tr><th style="width: 25%;">구절</th><th>의미</th></tr></thead><tbody><tr><td><b><input type="text" class="blank-input" data-blank-index="0" />가 깊은 나무</b></td><td>기초가 튼튼한 나라(조선)</td></tr><tr><td><b><input type="text" class="blank-input" data-blank-index="1" />에 아니 움직이므로</b></td><td>시련에 흔들리지 않고 안정적으로 유지됨</td></tr><tr><td><b>꽃 좋고 <input type="text" class="blank-input" data-blank-index="2" />가 많으니</b></td><td>문화가 발전하고 자손이 번성함</td></tr><tr><td><b><input type="text" class="blank-input" data-blank-index="3" />이 깊은 물</b></td><td>유서가 깊은 나라(조선)</td></tr><tr><td><b>가뭄</b></td><td>시련, 국가의 존립이 위협받는 일</td></tr><tr><td><b>내가 이루어져 <input type="text" class="blank-input" data-blank-index="4" />에 가느니</b></td><td>나라가 영원히 이어짐</td></tr></tbody><tfoot><tr><td colspan="2" style="border: none; padding-top: 1rem; text-align: right;"><div style="display: inline-flex; align-items: center; gap: 10px;" class="problem-controls-wrapper"><div class="table-problem-feedback-area" style="color: #991b1b; font-weight: bold;"></div><button class="check-problem-btn">정답 확인</button></div></td></tr></tfoot></table></div><!-- end-problem-wrapper --><br></blockquote></div>
        <div class="footer-text">juno v2.52</div>
    </div>
    <script>
        (
                (function() {
                    function setupAll() {
                        function setupInteractiveAbbr() {
                            const abbrElements = document.querySelectorAll('.interactive-abbr');
                            let currentPopup = null;
                            function closePopup() {
                                if (currentPopup) { currentPopup.remove(); currentPopup = null; }
                            }
                            document.body.addEventListener('click', function(event) {
                                const span = event.target.closest('.interactive-abbr');
                                if (span) {
                                    event.stopPropagation();
                                    closePopup();
                                    const title = span.dataset.title;
                                    const originalText = span.dataset.originalText;
                                    const popupDiv = document.createElement('div');
                                    popupDiv.style.cssText = "position: absolute; background-color: #f8fafc; border: 1px solid #cbd5e1; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); padding: 16px; width: 300px; z-index: 1000; font-family: 'Inter', sans-serif; font-size: 14px; line-height: 1.5; color: #334155; word-wrap: break-word;";
                                    popupDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 8px; color: #1e40af;">' + originalText + '</div><div>' + title + '</div><button class="close-popup-btn" style="position: absolute; top: 8px; right: 8px; background: none; border: none; font-size: 18px; cursor: pointer; color: #64748b;">&times;</button>';
                                    const rect = span.getBoundingClientRect();
                                    let top = rect.bottom + window.scrollY + 5;
                                    let left = rect.left + window.scrollX;
                                    document.body.appendChild(popupDiv);
                                    currentPopup = popupDiv;
                                    if (left + popupDiv.offsetWidth > window.innerWidth) { left = window.innerWidth - popupDiv.offsetWidth - 20; }
                                    if (top + popupDiv.offsetHeight > window.innerHeight + window.scrollY) { top = rect.top + window.scrollY - popupDiv.offsetHeight - 5; }
                                    popupDiv.style.top = top + 'px';
                                    popupDiv.style.left = left + 'px';
                                    popupDiv.querySelector('.close-popup-btn').addEventListener('click', closePopup);
                                } else if (currentPopup && !currentPopup.contains(event.target)) {
                                    closePopup();
                                }
                            });
                            document.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closePopup(); } });
                        }
                        
                        function setupInteractiveProblems() {
                            document.body.addEventListener('click', function(event) {
                                const target = event.target;
                                const showFeedback = (message, color, bgColor, context) => {
                                    // This function is for fill-blank problems and multiple choice.
                                    let feedbackBox;

                                    // For fill-blank, context is the .fill-blank-item
                                    const controlContainerInFillBlank = context.querySelector('.problem-controls');
                                    // For mc, context is the .mc-feedback-container
                                    const isMcContext = context.classList.contains('mc-feedback-container');

                                    if (controlContainerInFillBlank) {
                                        const checkBtn = controlContainerInFillBlank.querySelector('.check-problem-btn');
                                        feedbackBox = controlContainerInFillBlank.querySelector('.feedback-message-box');
                                        if (!feedbackBox) {
                                            feedbackBox = document.createElement('div');
                                            feedbackBox.className = 'feedback-message-box';
                                            controlContainerInFillBlank.appendChild(feedbackBox);
                                        }
                                        feedbackBox.style.marginTop = '8px';
                                        feedbackBox.style.marginBottom = '0';
                                        feedbackBox.style.padding = '8px';
                                        feedbackBox.style.textAlign = 'center';
                                        feedbackBox.style.borderRadius = '6px';
                                        feedbackBox.style.fontSize = '0.9em';
                                        feedbackBox.style.lineHeight = '1.4';
                                        if (checkBtn) {
                                            feedbackBox.style.width = checkBtn.offsetWidth + 'px';
                                        }
                                    } else if (isMcContext) {
                                        feedbackBox = context.querySelector('.feedback-message-box');
                                        if (!feedbackBox) {
                                            feedbackBox = document.createElement('div');
                                            feedbackBox.className = 'feedback-message-box';
                                            context.innerHTML = ''; // Clear previous message
                                            context.appendChild(feedbackBox);
                                        }
                                    } else { // Fallback for table feedback
                                        const feedbackArea = context.querySelector('.table-problem-feedback-area');
                                        if(feedbackArea) {
                                            feedbackArea.textContent = message;
                                            feedbackArea.style.color = color;
                                        }
                                        return; // Table has its own way of showing feedback text
                                    }

                                    if (feedbackBox) {
                                        feedbackBox.textContent = message;
                                        feedbackBox.style.color = color;
                                        feedbackBox.style.backgroundColor = bgColor;
                                    }
                                };


                                // Check and Retry Buttons
                                const checkBtn = target.closest('.check-problem-btn');
                                const retryBtn = target.closest('.retry-btn');
                                
                                if (checkBtn) {
                                    const wrapper = checkBtn.closest('.problem-wrapper');
                                    if (!wrapper) return;
                                    const type = wrapper.dataset.type;

                                    if (type === 'essay') {
                                        const answerSection = wrapper.querySelector('.problem-answer-section');
                                        const textarea = wrapper.querySelector('.essay-answer-input');
                                        answerSection.style.display = 'block';
                                        checkBtn.style.display = 'none';
                                        textarea.disabled = true;
                                    } else if (type === 'fill-blank') {
                                        const item = checkBtn.closest('.fill-blank-item');
                                        let attempts = parseInt(item.dataset.attempts || '3', 10);
                                        if (attempts <= 0) return;
                                        let allCorrect = true;
                                        const inputs = item.querySelectorAll('.blank-input');
                                        const answers = JSON.parse(item.dataset.answers.replace(/&#39;/g, "'") || '[]');
                                        inputs.forEach((input, index) => {
                                            const isCorrect = input.value.trim() === answers[index];
                                            input.classList.toggle('correct', isCorrect);
                                            input.classList.toggle('incorrect', !isCorrect);
                                            if (!isCorrect) allCorrect = false;
                                        });
                                        if (allCorrect) {
                                            showFeedback('정답입니다! 🎉', '#166534', '#dcfce7', item);
                                            inputs.forEach(input => { input.disabled = true; });
                                            checkBtn.style.display = 'none';
                                        } else {
                                            attempts--;
                                            item.dataset.attempts = attempts;
                                            if (attempts > 0) {
                                                showFeedback('오답이 있습니다. (' + attempts + '번 남음)', '#991b1b', '#fee2e2', item);
                                            } else {
                                                showFeedback('아쉬워요. 정답을 확인해보세요! 💪', '#991b1b', '#fee2e2', item);
                                                inputs.forEach((input, i) => {
                                                    if (!input.classList.contains('correct')) {
                                                        input.value = answers[i] || '';
                                                    }
                                                    input.disabled = true;
                                                });
                                                checkBtn.style.display = 'none';
                                            }
                                        }
                                    } else if (type === 'table-fill-blank') {
                                        let attempts = parseInt(wrapper.dataset.attempts || '3', 10);
                                        if (attempts <= 0) return;
                                        let allCorrect = true;
                                        const inputs = wrapper.querySelectorAll('.blank-input');
                                        const answers = JSON.parse(wrapper.dataset.answers.replace(/&#39;/g, "'") || '[]');
                                        inputs.forEach((input, index) => {
                                            const isCorrect = input.value.trim() === answers[index];
                                            input.classList.toggle('correct', isCorrect);
                                            input.classList.toggle('incorrect', !isCorrect);
                                            if (!isCorrect) allCorrect = false;
                                        });
                                        const context = wrapper.querySelector('.problem-controls-wrapper') || wrapper;
                                        if (allCorrect) {
                                            showFeedback('정답입니다! 🎉', '#166534', '#dcfce7', context);
                                            inputs.forEach(input => { input.disabled = true; });
                                            checkBtn.style.display = 'none';
                                        } else {
                                            attempts--;
                                            wrapper.dataset.attempts = attempts;
                                            if (attempts > 0) {
                                                showFeedback('오답이 있습니다. (' + attempts + '번 남음)', '#991b1b', '#fee2e2', context);
                                            } else {
                                                showFeedback('아쉬워요. 정답을 확인해보세요! 💪', '#991b1b', '#fee2e2', context);
                                                inputs.forEach((input, i) => {
                                                    if (!input.classList.contains('correct')) {
                                                        input.value = answers[i] || '';
                                                    }
                                                    input.disabled = true;
                                                });
                                                checkBtn.style.display = 'none';
                                            }
                                        }
                                    }
                                }

                                if (retryBtn) {
                                    const wrapper = retryBtn.closest('.problem-wrapper');
                                    if (!wrapper) return;
                                    const type = wrapper.dataset.type;

                                    if (type === 'essay') {
                                        wrapper.querySelector('.essay-answer-input').value = '';
                                        wrapper.querySelector('.essay-answer-input').disabled = false;
                                        wrapper.querySelector('.problem-answer-section').style.display = 'none';
                                        wrapper.querySelector('.check-problem-btn').style.display = 'inline-block';
                                    } else if (type === 'fill-blank') {
                                        wrapper.querySelectorAll('.fill-blank-item').forEach(item => {
                                            item.dataset.attempts = '3';
                                            item.querySelectorAll('.blank-input').forEach(input => {
                                                input.value = '';
                                                input.classList.remove('correct', 'incorrect');
                                                input.disabled = false;
                                            });
                                            const btn = item.querySelector('.check-problem-btn');
                                            if (btn) btn.style.display = 'inline-block';
                                            const feedbackBox = item.querySelector('.feedback-message-box');
                                            if(feedbackBox) feedbackBox.remove();
                                        });
                                    } else if (type === 'table-fill-blank') {
                                        wrapper.dataset.attempts = '3';
                                        wrapper.querySelectorAll('.blank-input').forEach(input => {
                                            input.value = '';
                                            input.classList.remove('correct', 'incorrect');
                                            input.disabled = false;
                                        });
                                        const btn = wrapper.querySelector('.check-problem-btn');
                                        if(btn) btn.style.display = 'inline-block';
                                        const feedbackArea = wrapper.querySelector('.table-problem-feedback-area');
                                        if (feedbackArea) feedbackArea.textContent = '';
                                    } else if (type === 'ox-quiz') {
                                        wrapper.querySelectorAll('.ox-quiz-item').forEach(item => {
                                            item.querySelectorAll('.ox-choice').forEach(choice => {
                                                choice.classList.remove('correct', 'incorrect');
                                                choice.disabled = false;
                                                choice.innerHTML = choice.classList.contains('o-btn') ? 'O' : 'X';
                                            });
                                        });
                                    } else if (type === 'multiple-choice') {
                                        wrapper.dataset.attempts = '2';
                                        wrapper.dataset.solved = 'false';
                                        wrapper.querySelectorAll('.choice-item').forEach(c => {
                                            c.classList.remove('correct', 'incorrect');
                                            c.style.pointerEvents = 'auto';
                                        });
                                        wrapper.querySelector('.problem-answer-section').style.display = 'none';
                                        wrapper.querySelector('.mc-feedback-container').innerHTML = '';
                                    }
                                }

                                // OX Quiz Choices
                                const oxChoice = target.closest('.ox-choice');
                                if (oxChoice) {
                                    const item = oxChoice.closest('.ox-quiz-item');
                                    if (item.querySelector('.ox-choice[disabled]')) return;
                                    
                                    const correctAnswer = item.dataset.correctAnswer;
                                    const selectedAnswer = oxChoice.classList.contains('o-btn') ? 'O' : 'X';
                                    const isCorrect = selectedAnswer === correctAnswer;
                                    
                                    item.querySelectorAll('.ox-choice').forEach(btn => {
                                        btn.disabled = true;
                                        if ((btn.classList.contains('o-btn') && correctAnswer === 'O') || (btn.classList.contains('x-btn') && correctAnswer === 'X')) {
                                            btn.classList.add('correct');
                                            btn.innerHTML = '✅';
                                        }
                                    });

                                    if (!isCorrect) {
                                        oxChoice.classList.add('incorrect');
                                        oxChoice.innerHTML = '❌';
                                    }
                                }

                                // Multiple Choice
                                const mcChoice = target.closest('.choice-item');
                                if (mcChoice) {
                                    const wrapper = mcChoice.closest('.problem-wrapper');
                                    let solved = wrapper.dataset.solved === 'true';
                                    if (solved || mcChoice.classList.contains('incorrect')) return;

                                    let attempts = parseInt(wrapper.dataset.attempts || '2', 10);
                                    const isCorrect = mcChoice.dataset.correct === 'true';
                                    const answerSection = wrapper.querySelector('.problem-answer-section');
                                    const feedbackContainer = wrapper.querySelector('.mc-feedback-container');

                                    if (isCorrect) {
                                        showFeedback('정답입니다! 🎉', '#166534', '#dcfce7', feedbackContainer);
                                        mcChoice.classList.add('correct');
                                        wrapper.dataset.solved = 'true';
                                        wrapper.querySelectorAll('.choice-item').forEach(c => c.style.pointerEvents = 'none');
                                        if(answerSection) answerSection.style.display = 'block';
                                    } else {
                                        attempts--;
                                        wrapper.dataset.attempts = attempts;
                                        mcChoice.classList.add('incorrect');
                                        mcChoice.style.pointerEvents = 'none';

                                        if (attempts > 0) {
                                            showFeedback('아쉽네요. 1번의 기회가 남았어요.', '#991b1b', '#fee2e2', feedbackContainer);
                                        } else {
                                            showFeedback('오답입니다. 정답을 확인해보세요.', '#991b1b', '#fee2e2', feedbackContainer);
                                            const correctChoice = wrapper.querySelector('.choice-item[data-correct="true"]');
                                            if(correctChoice) correctChoice.classList.add('correct');
                                            wrapper.dataset.solved = 'true';
                                            wrapper.querySelectorAll('.choice-item').forEach(c => c.style.pointerEvents = 'none');
                                            if(answerSection) answerSection.style.display = 'block';
                                        }
                                    }
                                }
                            });
                        }

                        function setupLineDrawingQuizzes() {
                            document.querySelectorAll('.problem-wrapper[data-type="line-drawing-quiz"]').forEach(wrapper => {
                                const container = wrapper.querySelector('.line-drawing-container');
                                const canvas = wrapper.querySelector('.line-drawing-canvas');
                                const ctx = canvas.getContext('2d');
                                const rightList = wrapper.querySelector('.line-drawing-list.right');
                                const checkBtn = wrapper.querySelector('.check-problem-btn');
                                const retryBtn = wrapper.querySelector('.retry-btn');
                                
                                let isDrawing = false;
                                let lineStartPoint = null;
                                let drawnLines = [];
                                let isSolved = false;

                                const alignHeights = () => {
                                    const leftItems = Array.from(wrapper.querySelectorAll('.line-drawing-list.left .line-drawing-item'));
                                    const rightItems = Array.from(wrapper.querySelectorAll('.line-drawing-list.right .line-drawing-item'));

                                    leftItems.forEach(item => item.style.minHeight = '');
                                    rightItems.forEach(item => item.style.minHeight = '');

                                    requestAnimationFrame(() => {
                                        const rightItemsById = new Map();
                                        rightItems.forEach(item => rightItemsById.set(item.dataset.id, item));

                                        leftItems.forEach(leftItem => {
                                            const rightItem = rightItemsById.get(leftItem.dataset.id);
                                            if (rightItem) {
                                                const leftHeight = leftItem.offsetHeight;
                                                const rightHeight = rightItem.offsetHeight;
                                                const maxHeight = Math.max(leftHeight, rightHeight);
                                                leftItem.style.minHeight = `${maxHeight}px`;
                                                rightItem.style.minHeight = `${maxHeight}px`;
                                            }
                                        });
                                    });
                                };
                                
                                const getPointCoords = (pointEl) => {
                                    const rect = pointEl.getBoundingClientRect();
                                    const containerRect = container.getBoundingClientRect();
                                    return {
                                        x: rect.left - containerRect.left + rect.width / 2,
                                        y: rect.top - containerRect.top + rect.height / 2,
                                    };
                                };

                                const drawLine = (startCoords, endCoords, color = '#60a5fa', width = 4) => {
                                    ctx.beginPath();
                                    ctx.moveTo(startCoords.x, startCoords.y);
                                    ctx.lineTo(endCoords.x, endCoords.y);
                                    ctx.strokeStyle = color;
                                    ctx.lineWidth = width;
                                    ctx.lineCap = 'round';
                                    ctx.stroke();
                                };

                                const redrawAllLines = (showResult = false) => {
                                    if(!canvas.width || !canvas.height) return;
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    drawnLines.forEach(line => {
                                        const startEl = container.querySelector(`.connection-point[data-side="left"][data-id="${line.leftId}"]`);
                                        const endEl = container.querySelector(`.connection-point[data-side="right"][data-id="${line.rightId}"]`);
                                        if (startEl && endEl) {
                                            const startCoords = getPointCoords(startEl);
                                            const endCoords = getPointCoords(endEl);
                                            let color = '#60a5fa';
                                            if (showResult) {
                                                color = line.leftId === line.rightId ? '#22c55e' : '#ef4444';
                                            }
                                            drawLine(startCoords, endCoords, color, showResult ? 6 : 4);
                                        }
                                    });
                                };

                                const resizeCanvas = () => {
                                    if(container.clientWidth > 0 && container.clientHeight > 0) {
                                      canvas.width = container.clientWidth;
                                      canvas.height = container.clientHeight;
                                      alignHeights();
                                      redrawAllLines(isSolved);
                                    }
                                };

                                const getEventCoords = (e) => {
                                    const rect = container.getBoundingClientRect();
                                    const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                                    const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                                    return { x: clientX - rect.left, y: clientY - rect.top };
                                }
                                
                                const getEndEventCoords = (e) => {
                                    const rect = container.getBoundingClientRect();
                                    const clientX = e.clientX || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0);
                                    const clientY = e.clientY || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0);
                                    return { clientX, clientY, x: clientX - rect.left, y: clientY - rect.top };
                                }

                                const handleMove = (e) => {
                                    if (!isDrawing || !lineStartPoint) return;
                                    e.preventDefault();
                                    const coords = getEventCoords(e);
                                    redrawAllLines();
                                    const startCoords = getPointCoords(lineStartPoint);
                                    drawLine(startCoords, coords);
                                };

                                const handleEnd = (e) => {
                                    if (!isDrawing || !lineStartPoint) return;
                                    e.preventDefault();
                                    
                                    const endCoords = getEndEventCoords(e);
                                    const endPointEl = document.elementFromPoint(endCoords.clientX, endCoords.clientY);
                                    const endPoint = endPointEl ? endPointEl.closest('.connection-point') : null;

                                    if (endPoint && endPoint !== lineStartPoint && endPoint.dataset.side !== lineStartPoint.dataset.side) {
                                        const leftId = lineStartPoint.dataset.side === 'left' ? lineStartPoint.dataset.id : endPoint.dataset.id;
                                        const rightId = lineStartPoint.dataset.side === 'right' ? lineStartPoint.dataset.id : endPoint.dataset.id;
                                        
                                        drawnLines = drawnLines.filter(line => line.leftId !== leftId && line.rightId !== rightId);

                                        drawnLines.push({ leftId, rightId });
                                    }
                                    
                                    lineStartPoint.classList.remove('selected');
                                    lineStartPoint = null;
                                    isDrawing = false;
                                    
                                    window.removeEventListener('mousemove', handleMove);
                                    window.removeEventListener('mouseup', handleEnd);
                                    window.removeEventListener('touchmove', handleMove);
                                    window.removeEventListener('touchend', handleEnd);

                                    redrawAllLines();
                                };

                                const handleStart = (e) => {
                                    if (isSolved) return;
                                    const point = e.target.closest('.connection-point');
                                    if (!point) return;
                                    e.preventDefault();
                                    
                                    isDrawing = true;
                                    lineStartPoint = point;
                                    point.classList.add('selected');

                                    drawnLines = drawnLines.filter(line => {
                                        if (point.dataset.side === 'left') return line.leftId !== point.dataset.id;
                                        return line.rightId !== point.dataset.id;
                                    });
                                    redrawAllLines();
                                    
                                    window.addEventListener('mousemove', handleMove);
                                    window.addEventListener('mouseup', handleEnd);
                                    window.addEventListener('touchmove', handleMove, { passive: false });
                                    window.addEventListener('touchend', handleEnd, { passive: false });
                                };
                                
                                const initQuiz = () => {
                                    const rightItems = Array.from(rightList.children);
                                    // Shuffle only if not already solved (i.e., on first load or retry)
                                    if (!isSolved) {
                                        for (let i = rightItems.length - 1; i > 0; i--) {
                                            const j = Math.floor(Math.random() * (i + 1));
                                            [rightItems[i], rightItems[j]] = [rightItems[j], rightItems[i]];
                                        }
                                        rightItems.forEach(item => rightList.appendChild(item));
                                    }
                                    
                                    isSolved = false;
                                    drawnLines = [];
                                    checkBtn.disabled = false;
                                    container.querySelectorAll('.connection-point').forEach(p => p.classList.remove('selected'));
                                    
                                    setTimeout(resizeCanvas, 50); // Give a short timeout for rendering
                                };
                                
                                checkBtn.addEventListener('click', () => {
                                    if (isSolved) return;
                                    isSolved = true;
                                    redrawAllLines(true);
                                    checkBtn.disabled = true;
                                });

                                retryBtn.addEventListener('click', initQuiz);

                                // Init
                                initQuiz();
				setTimeout(initQuiz, 100);
                                window.addEventListener('resize', resizeCanvas);
                                container.addEventListener('mousedown', handleStart);
                                container.addEventListener('touchstart', handleStart, { passive: false });
                            });
                        }

                        setupInteractiveAbbr(); 
                        setupInteractiveProblems(); 
                        setupLineDrawingQuizzes();
                    }

                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', setupAll);
                    } else {
                        setupAll();
                    }
                })()
            )()
    </script>
</body></html>
